

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.jpg">
  <link rel="icon" href="/img/avatar.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Haktiong">
  <meta name="keywords" content="">
  
    <meta name="description" content="MySQL锁篇1. 一条update语句1update tab_user set name&#x3D;&amp;#x27;曹操&amp;#x27; where id &#x3D; 1;  执行流程：  2. MySQL锁介绍在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改一部分数据时，MySQL会通过锁定防止其他用户读取同一数据。 在处理并发读或者写时，通过实现一个由两种类型的锁组成的锁系统来解决问题。两种锁通常被称为*">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL锁篇">
<meta property="og:url" content="https://haktiong.gitee.io/2022/05/27/MySQL%E9%94%81%E7%AF%87/index.html">
<meta property="og:site_name" content="Haktiong&#39;s Blog">
<meta property="og:description" content="MySQL锁篇1. 一条update语句1update tab_user set name&#x3D;&amp;#x27;曹操&amp;#x27; where id &#x3D; 1;  执行流程：  2. MySQL锁介绍在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改一部分数据时，MySQL会通过锁定防止其他用户读取同一数据。 在处理并发读或者写时，通过实现一个由两种类型的锁组成的锁系统来解决问题。两种锁通常被称为*">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://haktiong.gitee.io/img/mysql.jpeg">
<meta property="article:published_time" content="2022-05-27T15:45:00.000Z">
<meta property="article:modified_time" content="2025-03-04T02:52:11.631Z">
<meta property="article:author" content="Haktiong">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://haktiong.gitee.io/img/mysql.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>MySQL锁篇 - Haktiong&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"haktiong.gitee.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Haktiong</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL锁篇"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-27 23:45" pubdate>
          2022年5月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          151 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL锁篇</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="MySQL锁篇"><a href="#MySQL锁篇" class="headerlink" title="MySQL锁篇"></a><strong>MySQL锁篇</strong></h1><h2 id="1-一条update语句"><a href="#1-一条update语句" class="headerlink" title="1. 一条update语句"></a>1. 一条update语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update tab_user set name=&#x27;曹操&#x27; where id = 1;<br></code></pre></td></tr></table></figure>

<p>执行流程：</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249289.jpeg" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-MySQL锁介绍"><a href="#2-MySQL锁介绍" class="headerlink" title="2. MySQL锁介绍"></a>2. MySQL锁介绍</h2><p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改一部分数据时，MySQL会通过锁定防止其他用户读取同一数据。</p>
<p>在处理并发读或者写时，通过实现一个由两种类型的锁组成的锁系统来解决问题。两种锁通常被称为**共享锁(shared lock)<strong>和</strong>排他锁(exclusive lock)<strong>，也叫</strong>读锁(read lock)<strong>和</strong>写锁(write lock)**。</p>
<p>读锁是共享的，是互相不阻塞的。多个客户端在同一时刻可以同时读取同一个资源，而不互相干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。</p>
<h3 id="2-1-锁分类"><a href="#2-1-锁分类" class="headerlink" title="2.1 锁分类"></a>2.1 锁分类</h3><p><strong>按锁粒度分：</strong></p>
<ul>
<li>全局锁：锁整Database，由MySQL的SQL layer层实现</li>
<li>表级锁：锁某Table，由MySQL的SQL layer层实现</li>
<li>行级锁：锁某Row的索引，也可锁定行索引之间的间隙，由存储引擎实现【InnoDB】</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249062.jpeg" srcset="/img/loading.gif" lazyload></p>
<p><strong>按锁功能分：</strong></p>
<ul>
<li><strong>共享锁Shared Locks（S锁，也叫读锁）</strong>： 为了方便理解，下文我们全部使用<strong>读锁</strong>来称呼<ul>
<li>加了读锁的记录，允许其他事务再加读锁</li>
<li>加锁方式：select…lock in share mode</li>
</ul>
</li>
<li><strong>排他锁Exclusive Locks（X锁，也叫写锁）</strong>：为了方便理解，下文我们全部使用<strong>写锁</strong>来称呼<ul>
<li>加了写锁的记录，不允许其他事务再加读锁或者写锁</li>
<li>加锁方式：select…for update</li>
</ul>
</li>
</ul>
<h3 id="2-2-什么是全局锁？"><a href="#2-2-什么是全局锁？" class="headerlink" title="2.2 什么是全局锁？"></a>2.2 什么是全局锁？</h3><p>全局锁是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p>加全局锁的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush tables with read lock;<br></code></pre></td></tr></table></figure>

<p>释放全局锁的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables;<br></code></pre></td></tr></table></figure>

<p>或者断开加锁session的连接，自动释放全局锁。</p>
<p>说到全局锁用于备份这个事情，还是很危险的。因为如果在主库上加全局锁，则整个数据库将不能写入，备份期间影响业务运行，如果在从库上加全局锁，则会导致不能执行主库同步过来的操作，造成主从延迟。</p>
<p>对于innodb这种支持事务的引擎，使用mysqldump备份时可以使用–single-transaction参数，利用mvcc提供一致性视图，而不使用全局锁，不会影响业务的正常运行。而对于有MyISAM这种不支持事务的表，就只能通过全局锁获得一致性视图，对应的mysqldump参数为–lock-all-tables。</p>
<p>举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">提交请求锁定所有数据库中的所有表，以保证数据的一致性，全局读锁</span><br>mysqldump -uroot -p --host=localhost --all-databases --lock-all-tables &gt; /root/db.sql<br><span class="hljs-meta prompt_"># </span><span class="language-bash">一致性视图</span><br>mysqldump -uroot -p --host=localhost --all-databases --single-transaction &gt; /root/db.sql<br></code></pre></td></tr></table></figure>

<h2 id="3-表级锁"><a href="#3-表级锁" class="headerlink" title="3. 表级锁"></a>3. 表级锁</h2><h3 id="3-1-什么是表级锁？"><a href="#3-1-什么是表级锁？" class="headerlink" title="3.1 什么是表级锁？"></a>3.1 什么是表级锁？</h3><p>MySQL的表级锁有四种：</p>
<ul>
<li>表读锁（Table Read Lock）</li>
<li>表写锁（Table Write Lock）</li>
<li>元数据锁（meta data lock，MDL)</li>
<li>自增锁(AUTO-INC Locks)</li>
</ul>
<h3 id="3-2-表读锁、写锁"><a href="#3-2-表读锁、写锁" class="headerlink" title="3.2 表读锁、写锁"></a>3.2 表读锁、写锁</h3><h4 id="1）表锁相关命令"><a href="#1）表锁相关命令" class="headerlink" title="1）表锁相关命令"></a>1）表锁相关命令</h4><p>MySQL 实现的表级锁定的争用状态变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看表锁定状态<br>mysql&gt; show status like &#x27;table%&#x27;;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249659.jpeg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>table_locks_immediate：产生表级锁定的次数；</li>
<li>table_locks_waited：出现表级锁定争用而发生等待的次数；</li>
</ul>
<p>表锁有两种表现形式：</p>
<ul>
<li><p>表读锁（Table Read Lock）</p>
</li>
<li><p>表写锁（Table Write Lock）</p>
</li>
</ul>
<p>手动增加表锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">lock table 表名称 read(write),表名称2 read(write)，其他;<br># 举例：<br>lock table t read; #为表t加读锁<br>lock table t write; #为表t加写锁<br></code></pre></td></tr></table></figure>

<p>查看表锁情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show open tables;<br></code></pre></td></tr></table></figure>

<p>删除表锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables;<br></code></pre></td></tr></table></figure>

<h4 id="2）表锁演示"><a href="#2）表锁演示" class="headerlink" title="2）表锁演示"></a>2）表锁演示</h4><h5 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE mylock (<br>id int(11) NOT NULL AUTO_INCREMENT,<br>NAME varchar(20) DEFAULT NULL,<br>PRIMARY KEY (id)<br>);<br>INSERT INTO mylock (id,NAME) VALUES (1, &#x27;a&#x27;);<br>INSERT INTO mylock (id,NAME) VALUES (2, &#x27;b&#x27;);<br>INSERT INTO mylock (id,NAME) VALUES (3, &#x27;c&#x27;);<br>INSERT INTO mylock (id,NAME) VALUES (4, &#x27;d&#x27;);<br></code></pre></td></tr></table></figure>

<h5 id="2-读锁演示：mylock表加read锁【读阻塞写】"><a href="#2-读锁演示：mylock表加read锁【读阻塞写】" class="headerlink" title="2. 读锁演示：mylock表加read锁【读阻塞写】"></a>2. 读锁演示：mylock表加read锁【读阻塞写】</h5><table>
<thead>
<tr>
<th>时间</th>
<th><strong>session01</strong></th>
<th><strong>session02</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>连接MySQL</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>获得表mylock的Read Lock锁定：<br/>lock table mylock read;</td>
<td>连接MySQL</td>
</tr>
<tr>
<td>T3</td>
<td>当前Session可以查询该表记录：<br/>select * from mylock;</td>
<td>其他Session也可以查询该表的记录：<br/>select * from mylock;</td>
</tr>
<tr>
<td>T4</td>
<td>当前Session不能查询其他没有锁定的表：<br />select * from t;</td>
<td>其他Session可以查询或更新未锁定的表：<br />update t set c&#x3D;’张飞’ where id&#x3D;1</td>
</tr>
<tr>
<td>T5</td>
<td>当前Session插入或更新锁定的表会提示错误：<br />insert into mylock (name) values(‘e’)；</td>
<td>其他Session插入或更新锁定表<strong>会一直等待</strong>获取锁：<br />insert into mylock (name) values(‘e’)；</td>
</tr>
<tr>
<td>T6</td>
<td>释放锁： unlock tables;</td>
<td>插入成功：</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- Session01<br># 获得表mylock的Read Lock锁定：<br>lock table mylock read;<br># 当前Session可以查询该表记录：<br>select * from mylock;<br># 当前Session不能查询其他没有锁定的表：<br>select * from t;<br># 当前Session插入或更新锁定的表会提示错误：<br>insert into mylock (name) values(&#x27;e&#x27;);<br># 释放锁：<br>unlock tables;<br><br>-- Session02<br># 其他Session也可以查询该表的记录：<br>select * from mylock;<br># 其他Session可以查询或更新未锁定的表：<br>update t set c=&#x27;张飞&#x27; where id=1;<br># 其他Session插入或更新锁定表会一直等待获取锁：<br>insert into mylock (name) values(&#x27;e&#x27;)<br></code></pre></td></tr></table></figure>

<h5 id="3-写锁演示：mylock表加write锁【写阻塞读】"><a href="#3-写锁演示：mylock表加write锁【写阻塞读】" class="headerlink" title="3. 写锁演示：mylock表加write锁【写阻塞读】"></a>3. 写锁演示：mylock表加write锁【写阻塞读】</h5><table>
<thead>
<tr>
<th>时间</th>
<th><strong>session01</strong></th>
<th><strong>session02</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>连接MySQL</td>
<td>待session1开启锁后，session2再获取连接</td>
</tr>
<tr>
<td>T2</td>
<td>获得表mylock的write锁：<br/>lock table mylock write；</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>当前session对锁定表的查询+更新+插入操作都可以执行：<br/>select * from mylock where id&#x3D;1;<br/>insert into mylock (name) values(‘e’);</td>
<td>连接MySQL</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>其他session对锁定表的查询被阻塞，需要等待锁被释放<br/>select * from mylock where id&#x3D;1;</td>
</tr>
<tr>
<td>T5</td>
<td>释放锁： unlock tables;</td>
<td>获得锁，返回查询结果：</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：MySQL有缓存，如果在查询过程中没有被阻塞说明查询到的是缓存数据。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- Session01<br># 获得表mylock的write锁：<br>lock table mylock write;<br># 当前session对锁定表的查询+更新+插入操作都可以执行：<br>select * from mylock where id=1;<br>insert into mylock (name) values(&#x27;e&#x27;);<br># 释放锁：<br>unlock tables;<br><br>-- Session02<br># 注意：待session1开启锁后，session2再获取连接<br># 其他session对锁定表的查询被阻塞，需要等待锁被释放<br>select * from mylock where id=1;<br># 获得锁，返回查询结果：<br></code></pre></td></tr></table></figure>

<h3 id="3-3-元数据锁"><a href="#3-3-元数据锁" class="headerlink" title="3.3 元数据锁"></a>3.3 元数据锁</h3><h4 id="1）元数据锁介绍"><a href="#1）元数据锁介绍" class="headerlink" title="1）元数据锁介绍"></a>1）元数据锁介绍</h4><p>元数据锁不需要显式指定，在访问一个表的时候会被自动加上，锁的作用是保证读写的正确性。</p>
<p>可以想象一下：如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，<strong>在</strong> <strong>MySQL 5.5</strong> <strong>版本中引入了元数据锁</strong>，当对一个表做增删改查操作的时候，<strong>加 元数据 读锁</strong>；当要对表做结构变更操作的时候，<strong>加 元数据 写锁</strong>。</p>
<ul>
<li><strong>读锁是共享的，是互相不阻塞的</strong>：因此你可以有多个线程同时对一张表加读锁，保证数据在读取的过程中不会被其他线程修改。</li>
<li><strong>写锁则是排他的：</strong>也就是说一个写锁会阻塞其他的写锁和读锁，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<h4 id="2）元数据锁演示"><a href="#2）元数据锁演示" class="headerlink" title="2）元数据锁演示"></a>2）元数据锁演示</h4><table>
<thead>
<tr>
<th>时间</th>
<th><strong>session01</strong></th>
<th><strong>session02</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>开启事务：begin</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>加元数据读锁： select * from mylock;</td>
<td>修改表结构： alter table mylock add f int;</td>
</tr>
<tr>
<td>T3</td>
<td>提交&#x2F;回滚事务： commit&#x2F;rollback 释放锁</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>获取锁，修改完成</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- Session01<br># 开启事务：<br>begin<br># 加元数据读锁：<br>select * from mylock;<br># 提交/回滚事务：<br>commit<br># 释放锁<br><br>-- Session02<br># 修改表结构：<br>alter table mylock add f int;<br># 获取锁，修改完成<br></code></pre></td></tr></table></figure>

<h3 id="3-4-自增锁-AUTO-INC-Locks"><a href="#3-4-自增锁-AUTO-INC-Locks" class="headerlink" title="3.4 自增锁(AUTO-INC Locks)"></a>3.4 自增锁(AUTO-INC Locks)</h3><p>AUTO-INC锁是一种特殊的表级锁，发生涉及AUTO_INCREMENT列的事务性插入操作时产生。</p>
<h2 id="4-行级锁"><a href="#4-行级锁" class="headerlink" title="4. 行级锁"></a>4. 行级锁</h2><h3 id="4-1-什么是行级锁？"><a href="#4-1-什么是行级锁？" class="headerlink" title="4.1 什么是行级锁？"></a>4.1 什么是行级锁？</h3><p>MySQL的<strong>行级锁</strong>，是由<strong>存储引擎</strong>来实现的，这里我们主要讲解<strong>InnoDB</strong>的行级锁。<strong>InnoDB行锁</strong>是通过给索引上的<strong>索引项加锁来实现的</strong>，因此InnoDB这种行锁实现特点：<strong>只有通过索引条件检索的数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>
<ul>
<li>InnoDB的行级锁，按照锁定范围来说，分为四种：<ul>
<li>记录锁（Record Locks）：锁定索引中一条记录。</li>
<li>间隙锁（Gap Locks）：要么锁住索引记录中间的值，要么锁住第一个索引记录前面的值或者最后一个索引记录后面的值。</li>
<li>临键锁（Next-Key Locks）：是索引记录上的记录锁和在索引记录之前的间隙锁的组合（间隙锁 + 记录锁）。</li>
<li>插入意向锁(Insert Intention Locks)：做insert操作时添加的对记录id的锁。</li>
</ul>
</li>
<li>InnoDB的行级锁，按照功能来说，分为两种：<ul>
<li>读锁：允许一个事务去读一行，阻止其他事务更新目标行数据。同时阻止其他事务加写锁，但不阻止其他事务加读锁。</li>
<li>写锁：允许获得排他锁的事务更新数据，阻止其他事务获取或修改数据。同时阻止其他事务加读锁和写锁。</li>
</ul>
</li>
</ul>
<h4 id="如何加行级锁？"><a href="#如何加行级锁？" class="headerlink" title="如何加行级锁？"></a>如何加行级锁？</h4><ul>
<li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加写锁；</li>
<li>对于普通SELECT语句，InnoDB不会加任何锁</li>
<li>事务可以通过以下语句手动给记录集加共享锁或排他锁。</li>
</ul>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t1_simple` (<br>`id` int(11) NOT NULL,<br>`pubtime` int(11) NULL DEFAULT NULL,<br>PRIMARY KEY (`id`) USING BTREE,<br>INDEX `idx_pu`(`pubtime`) USING BTREE<br>) ENGINE = InnoDB;<br>INSERT INTO `t1_simple` VALUES (1, 10);<br>INSERT INTO `t1_simple` VALUES (4, 3);<br>INSERT INTO `t1_simple` VALUES (6, 100);<br>INSERT INTO `t1_simple` VALUES (8, 5);<br>INSERT INTO `t1_simple` VALUES (10, 1);<br>INSERT INTO `t1_simple` VALUES (100, 20);<br></code></pre></td></tr></table></figure>

<p><strong>添加读锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t1_simple WHERE id=4 LOCK IN SHARE MODE; <br></code></pre></td></tr></table></figure>

<p><strong>添加写锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t1_simple WHERE id=4 FOR UPDATE;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-行锁四兄弟：记录、间隙、临键和插入意向锁"><a href="#4-2-行锁四兄弟：记录、间隙、临键和插入意向锁" class="headerlink" title="4.2 行锁四兄弟：记录、间隙、临键和插入意向锁"></a>4.2 行锁四兄弟：记录、间隙、临键和插入意向锁</h3><h4 id="4-2-1-记录锁"><a href="#4-2-1-记录锁" class="headerlink" title="4.2.1 记录锁"></a>4.2.1 记录锁</h4><p>记录锁（Record Locks）仅仅锁住索引记录的一行，在单条索引记录上加锁。记录锁锁住的永远是索引，而非记录本身，即使该表上没有任何显示索引，那么innodb会在后台创建一个隐藏的聚簇索引索引，那么锁住的就是这个隐藏的聚簇索引索引。</p>
<p>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 加记录读锁<br>select * from t1_simple where id = 1 lock in share mode;<br>-- 加记录写锁<br>select * from t1_simple where id = 1 for update;<br>-- 新增，修改，删除加记录写锁<br>insert into t1_simple values (2, 22);<br>update t1_simple set pubtime=33 where id =2;<br>delete from t1_simple where id =2<br></code></pre></td></tr></table></figure>

<h4 id="4-2-2-间隙锁"><a href="#4-2-2-间隙锁" class="headerlink" title="4.2.2 间隙锁"></a>4.2.2 间隙锁</h4><p>（1）间隙锁(Gap Locks)，仅仅锁住一个索引区间（开区间，不包括双端端点）。</p>
<p>（2）在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。</p>
<p>（3）间隙锁可用于防止幻读，保证索引间隙不会被插入数据</p>
<p><strong>主键id索引的行锁区间划分图：</strong></p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249338.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>session1执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">begin;<br>select * from t1_simple where id &gt; 4 for update;<br>commit;<br></code></pre></td></tr></table></figure>

<p>session2执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t1_simple values (7,100); -- 阻塞<br>insert into t1_simple values (3,100); -- 成功<br></code></pre></td></tr></table></figure>

<h4 id="4-2-3-临键锁"><a href="#4-2-3-临键锁" class="headerlink" title="4.2.3 临键锁"></a>4.2.3 临键锁</h4><p>（1）临键锁(Next-Key Locks)相当于记录锁 + 间隙锁【左开右闭区间】，例如（5,8]</p>
<p>（2）默认情况下，innodb使用临键锁来锁定记录，但在不同的场景中会退化</p>
<p>（3）当查询的索引含有唯一属性的时候，临键锁会进行优化，将其降级为记录锁，即仅锁住索引本身，不是范围。</p>
<p><strong>普通索引index(pubtime)行锁的区间划分图：</strong></p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249263.jpeg" srcset="/img/loading.gif" lazyload></p>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>退化成的锁类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>使用Unique index 精确匹配【&#x3D;】，且记录存在</td>
<td>记录锁</td>
</tr>
<tr>
<td>使用Unique index 精确匹配【&#x3D;】，且记录不存在</td>
<td>间隙锁</td>
</tr>
<tr>
<td>使用Unique index 范围匹配【&lt;和&gt;】</td>
<td>临键锁</td>
</tr>
</tbody></table>
<p>当前数据库中的记录信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t1_simple;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249956.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>session1执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">begin;<br>select * from t1_simple where pubtime = 20 for update;<br>-- 临键锁区间(10,20],(20,100]<br></code></pre></td></tr></table></figure>

<p>session2执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t1_simple values (16, 19); -- 阻塞<br>select * from t1_simple where pubtime = 20 for update; -- 阻塞<br>insert into t1_simple values (16, 50); -- 阻塞<br>insert into t1_simple values (16, 101); -- 成功<br></code></pre></td></tr></table></figure>

<h4 id="4-2-4-插入意向锁"><a href="#4-2-4-插入意向锁" class="headerlink" title="4.2.4 插入意向锁"></a>4.2.4 插入意向锁</h4><p>（1）插入意向锁(Insert Intention Locks)是一种间隙锁，不是意向锁，在insert操作时产生。</p>
<p>（2）在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。</p>
<p>（3）假设有一个记录索引包含键值10和100，不同的事务分别插入60和70，每个事务都会产生一个加在10-100之间的插入意向锁，获取在插入行上的写锁，但是不会被互相锁住，因为数据行并不冲突。</p>
<p>（4）插入意向锁不会阻止任何锁，对于插入的记录会持有一个记录锁。</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249334.jpeg" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-3-加锁规则【非常重要】"><a href="#4-3-加锁规则【非常重要】" class="headerlink" title="4.3 加锁规则【非常重要】"></a>4.3 加锁规则【非常重要】</h3><p><strong>主键索引</strong></p>
<ul>
<li>等值条件，命中，加记录锁</li>
<li>等值条件，未命中，加间隙锁</li>
<li>范围条件，命中，包含where条件的临键区间，加临键锁</li>
<li>范围条件，没有命中，加间隙锁</li>
</ul>
<p><strong>辅助索引</strong></p>
<ul>
<li>等值条件，命中，命中记录的辅助索引项 + 主键索引项加记录锁，辅助索引项两侧加间隙锁</li>
<li>等值条件，未命中，加间隙锁</li>
<li>范围条件，命中，包含where条件的临键区间加临键锁。命中记录的id索引项加记录锁</li>
<li>范围条件，没有命中，加间隙锁</li>
</ul>
<h3 id="4-4-意向锁"><a href="#4-4-意向锁" class="headerlink" title="4.4 意向锁"></a>4.4 意向锁</h3><h4 id="1）什么是意向锁？相当于存储引擎级别的表锁"><a href="#1）什么是意向锁？相当于存储引擎级别的表锁" class="headerlink" title="1）什么是意向锁？相当于存储引擎级别的表锁"></a>1）什么是意向锁？相当于存储引擎级别的表锁</h4><p>InnoDB也实现了表级锁，也就是意向锁【Intention Locks】。意向锁是MySQL内部使用的，不需要用户干预。<strong>意向锁和行锁可以共存</strong>，意向锁的主要作用是为了<strong>全表更新数据时的提升性能</strong>。否则在全表更新数据时，需要先检索该范是否某些记录上面有行锁。那么将是一件非常繁琐且耗时操作。</p>
<p><strong>举个栗子：</strong></p>
<p>事务A修改user表的记录r，会给记录r上一把行级的写锁，同时会给user表上一把意向写锁（IX），这时事务B要给user表上一个表级的写锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存，且满足事务隔离性的要求。</p>
<p>当我们需要加一个写锁时，需要根据意向锁去判断表中有没有数据行被锁定；</p>
<p>（1）如果行锁，则需要遍历每一行数据去确认；</p>
<p>（2）如果表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。</p>
<h4 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h4><ul>
<li>表明：“某个事务正在某些行持有了锁、或该事务准备去持有锁”</li>
<li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存</li>
</ul>
<h4 id="3）意向锁和读锁【S锁】、写锁【X锁】的兼容关系"><a href="#3）意向锁和读锁【S锁】、写锁【X锁】的兼容关系" class="headerlink" title="3）意向锁和读锁【S锁】、写锁【X锁】的兼容关系"></a>3）意向锁和读锁【S锁】、写锁【X锁】的兼容关系</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249554.jpeg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>意向锁相互兼容：因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。</li>
<li>表级S锁和X、IX锁不兼容：因为上了表级S锁后，不允许其他事务再加X锁。</li>
<li>表级X锁和 IS、IX、S、X不兼容：因为上了表级X锁后，会修改数据。</li>
</ul>
<blockquote>
<p>注意：上了行级写锁后，行级写锁不会因为有别的事务上了意向写锁而堵塞，一个MySQL是允许多个行级写锁同时存在的，只要他们不是针对相同的数据行</p>
</blockquote>
<h3 id="4-5-锁相关参数"><a href="#4-5-锁相关参数" class="headerlink" title="4.5 锁相关参数"></a>4.5 锁相关参数</h3><p>InnoDB所使用的<strong>行级锁定</strong>争用状态查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249968.jpeg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li>
<li>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；</li>
<li>Innodb_row_lock_time_avg：每次等待所花平均时间；</li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li>
<li>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；</li>
</ul>
<p>对于这5个状态变量，比较重要的主要是：</p>
<ul>
<li>Innodb_row_lock_time_avg（等待平均时长）</li>
<li>Innodb_row_lock_waits（等待总次数）</li>
<li>Innodb_row_lock_time（等待总时长）这三项。</li>
</ul>
<p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p>
<p>查看事务、锁的sql：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看锁的SQL<br>select * from information_schema.innodb_locks;<br>select * from information_schema.innodb_lock_waits;<br># 查看事务SQL<br>select * from information_schema.innodb_trx;<br># 查看未关闭的事务详情<br>SELECT<br>a.trx_id,a.trx_state,a.trx_started,a.trx_query,<br>b.ID,b.USER,b.DB,b.COMMAND,b.TIME,b.STATE,b.INFO,<br>c.PROCESSLIST_USER,c.PROCESSLIST_HOST,c.PROCESSLIST_DB,d.SQL_TEXT<br>FROM<br>information_schema.INNODB_TRX a<br>LEFT JOIN information_schema.PROCESSLIST b ON a.trx_mysql_thread_id = b.id<br>AND b.COMMAND = &#x27;Sleep&#x27;<br>LEFT JOIN PERFORMANCE_SCHEMA.threads c ON b.id = c.PROCESSLIST_ID<br>LEFT JOIN PERFORMANCE_SCHEMA.events_statements_current d ON d.THREAD_ID =<br>c.THREAD_ID;<br></code></pre></td></tr></table></figure>

<h2 id="5-行锁分析实战"><a href="#5-行锁分析实战" class="headerlink" title="5. 行锁分析实战"></a>5. 行锁分析实战</h2><p>在介绍完一些背景知识之后，接下来将选择几个有代表性的例子，来详细分析MySQL的加锁处理。从最简单的例子说起，下面两条简单的SQL，他们加的什么锁？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- SQL1：<br>select * from t1 where id = 10;<br>-- SQL2：<br>delete from t1 where id = 10;<br></code></pre></td></tr></table></figure>

<p>针对这个问题，该怎么回答？</p>
<p>能想象到的一个答案是：</p>
<ul>
<li>SQL1：不加锁。因为MySQL是使用多版本并发控制的，读不加锁。</li>
<li>SQL2：对id &#x3D; 10的记录加写锁 (走主键索引)</li>
</ul>
<p>这个答案对吗？</p>
<p>说不上来。即可能是正确的，也有可能是错误的，已知条件不足，这个问题没有答案。必须还要知道以下的一些前提，前提不同，能给出的答案也就不同。要回答这个问题，还缺少哪些前提条件？</p>
<ul>
<li><strong>前提一：</strong>id列是不是主键？</li>
<li><strong>前提二：</strong>当前系统的隔离级别是什么？</li>
<li><strong>前提三：</strong>id列如果不是主键，那么id列上有索引吗？</li>
<li><strong>前提四：</strong>id列上如果有二级索引，那么这个索引是唯一索引吗？</li>
<li><strong>前提五：</strong>两个SQL的执行计划是什么？索引扫描？全表扫描？</li>
</ul>
<p>没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我们将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？</p>
<blockquote>
<p>注：下面的这些组合，需要做一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准！！！</p>
</blockquote>
<p><strong>读已提交【RC】隔离级别</strong></p>
<ul>
<li>组合一：id列是主键，</li>
<li>组合二：id列是二级唯一索引</li>
<li>组合三：id列是二级非唯一索引</li>
<li>组合四：id列上没有索引</li>
</ul>
<p><strong>可重复读【RR】隔离级别</strong></p>
<ul>
<li>组合五：id列是主键</li>
<li>组合六：id列是二级唯一索引</li>
<li>组合七：id列是二级非唯一索引</li>
<li>组合八：id列上没有索引</li>
</ul>
<p><strong>Serializable隔离级别</strong></p>
<p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？</p>
<p>事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。</p>
<h3 id="5-1-读已提交RC"><a href="#5-1-读已提交RC" class="headerlink" title="5.1 读已提交RC"></a>5.1 读已提交RC</h3><p>注：在前面八种组合下，也就是RC，RR隔离级别下SQL1：<strong>select操作均不加锁，采用的是快照读</strong>，因此在下面的讨论中就忽略了，<strong>主要讨论SQL2：delete操作的加锁。</strong></p>
<h4 id="1）组合一：id主键"><a href="#1）组合一：id主键" class="headerlink" title="1）组合一：id主键"></a>1）组合一：id主键</h4><p>这个组合，是最简单，最容易分析的组合。<strong>id是主键，RC隔离级别</strong>，给定SQL： <code>delete from t1 where id = 10</code> ; 只需要将主键上id &#x3D; 10的记录加上写锁即可。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249139.jpeg" srcset="/img/loading.gif" lazyload></p>
<p><strong>结论</strong>：id是主键时，此SQL只需要在id&#x3D;10这条记录上加写锁即可。</p>
<h4 id="2）组合二：id唯一索引"><a href="#2）组合二：id唯一索引" class="headerlink" title="2）组合二：id唯一索引"></a>2）组合二：id唯一索引</h4><p>这个组合，<strong>id不是主键，而是一个Unique的二级索引键值</strong>。那么在RC隔离级别下，<code>delete from t1where id = 10</code>; 需要加什么锁呢？</p>
<p>见下图：</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249318.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id&#x3D;10的记录后，首先会将unique索引上的id&#x3D;10索引记录加上<strong>写锁</strong>，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name &#x3D; ‘d’ 对应的主键索引项加<strong>写锁</strong>。</p>
<p><strong>为什么聚簇索引上的记录也要加锁？</strong></p>
<p>试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id &#x3D; 100 where name &#x3D; ‘a’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新&#x2F;删除需要串行执行的约束。</p>
<p><strong>结论</strong>：若id列是unique列，其上有unique索引。那么SQL需要加两个<strong>写锁</strong>，一个对应于id unique索引上的id &#x3D; 10的记录，另一把锁对应于聚簇索引上的【name&#x3D;’d’,id&#x3D;10】的记录。</p>
<h4 id="3）组合三：id非唯一索引"><a href="#3）组合三：id非唯一索引" class="headerlink" title="3）组合三：id非唯一索引"></a>3）组合三：id非唯一索引</h4><p>相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id &#x3D; 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？</p>
<p>同样见下图：</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249132.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>根据此图，可以看到，首先，id列索引上，满足id &#x3D; 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p>
<p><strong>结论</strong>：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p>
<h4 id="4）组合四：id无索引"><a href="#4）组合四：id无索引" class="headerlink" title="4）组合四：id无索引"></a>4）组合四：id无索引</h4><p>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id &#x3D; 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。</p>
<p>对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？</p>
<p>这个答案也有很多：有人说会在表上加<strong>写锁</strong>；有人说会将聚簇索引上，选择出来的id &#x3D; 10;的记录加上<strong>写锁</strong>。那么实际情况呢？</p>
<p>请看下图：</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250399.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了<strong>写锁</strong>。无论记录是否满足条件，全部被加上<strong>写锁</strong>。既不是加表锁，也不是在满足条件的记录上加行锁。</p>
<p>有人可能会问？为什么不是只在满足条件的记录上加锁呢？</p>
<p>这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。</p>
<blockquote>
<p>注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p>
</blockquote>
<p><strong>结论：</strong>若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上<strong>写锁</strong>。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁&#x2F;放锁动作不会省略。</p>
<p>上面的四个组合，都是在RC隔离级别下的加锁行为，接下来的四个组合，是在RR隔离级别下的加锁行为。</p>
<h3 id="5-2-可重复RR"><a href="#5-2-可重复RR" class="headerlink" title="5.2 可重复RR"></a>5.2 可重复RR</h3><h4 id="1）组合五：id主键"><a href="#1）组合五：id主键" class="headerlink" title="1）组合五：id主键"></a>1）组合五：id主键</h4><p>与组合一是一致的</p>
<h4 id="2）组合六：id唯一索引"><a href="#2）组合六：id唯一索引" class="headerlink" title="2）组合六：id唯一索引"></a>2）组合六：id唯一索引</h4><p>与组合二是一致的</p>
<h4 id="3）组合七：id非唯一索引"><a href="#3）组合七：id非唯一索引" class="headerlink" title="3）组合七：id非唯一索引"></a>3）组合七：id非唯一索引</h4><p><strong>还记得MySQL的四种隔离级别的区别吗？</strong></p>
<ul>
<li><strong>RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。</strong></li>
</ul>
<p><strong>那么RR隔离级别下，如何防止幻读呢？</strong></p>
<p>看下面这幅图：</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250577.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>相对于组合三最大的区别在于，组合七中多了一个间隙锁。<strong>其实这个多出来的间隙锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。</strong></p>
<p>所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id &#x3D; 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。记录本身的一致性是可重复性，使用MVCC来解决。</p>
<p><strong>如何保证两次当前读返回一致的记录？</strong>那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，间隙锁应运而生。</p>
<p><strong>结论：</strong></p>
<p>RR隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id &#x3D; 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的写锁，加GAP上的间隙锁，然后加主键聚簇索引上的记录写锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录写锁，但是仍旧需要加间隙锁，最后返回结束。</p>
<h4 id="4）组合八：id无索引"><a href="#4）组合八：id无索引" class="headerlink" title="4）组合八：id无索引"></a>4）组合八：id无索引</h4><p>组合八，RR隔离级别下的最后一种情况，<strong>id列上没有索引</strong>。此时**SQL：delete from t1 where id &#x3D; 10;**没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250071.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了<strong>写锁</strong>。其次，聚簇索引每条记录间的间隙，也同时被加上了间隙锁。这个示例表，只有6条记录，一共需要6个记录锁，7个间隙锁。试想，如果表上有1000万条记录呢？</p>
<p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p>
<p>当然，跟组合四类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semiconsistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加间隙锁。</p>
<p><strong>semi-consistent read</strong>如何触发？要么是RC隔离级别；要么是RR隔离级别，同时设置了<strong>innodb_locks_unsafe_for_binlog</strong> 参数。</p>
<p><strong>结论：</strong>在RR隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有间隙，杜绝所有的并发 更新&#x2F;删除&#x2F;插入 操作。当然，也可以通过触发semi-consistentread，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p>
<h3 id="5-3-串行化Serializable"><a href="#5-3-串行化Serializable" class="headerlink" title="5.3 串行化Serializable"></a>5.3 串行化Serializable</h3><p>对于SQL2来说，Serializable隔离级别与RR隔离级别组合八情况完全一致，因此不做介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from t1 where id = 10<br></code></pre></td></tr></table></figure>

<p>Serializable隔离级别，影响的是SQL1这条SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t1 where id = 10<br></code></pre></td></tr></table></figure>

<p>在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，<strong>MVCC</strong>并发控制降级为<strong>LBCC</strong>。</p>
<p><strong>结论：</strong></p>
<p>在MySQL&#x2F;InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p>
<h3 id="5-4-复杂SQL加锁分析"><a href="#5-4-复杂SQL加锁分析" class="headerlink" title="5.4 复杂SQL加锁分析"></a>5.4 复杂SQL加锁分析</h3><p>再来看一个稍微复杂点的SQL，用于说明MySQL加锁的另外一个逻辑。</p>
<p>SQL用例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from t1 where pubtime &gt; 1 and pubtime &lt; 20 and userid=&#x27;hero&#x27; and commit is not null;<br></code></pre></td></tr></table></figure>

<p><strong>如图中的SQL，会加什么锁？</strong></p>
<p>假定在RR隔离级别下，同时，假设SQL走的是idx_t1_pu（pubtime，userid）索引</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250227.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>在详细分析这条SQL的加锁情况前，还需要有一个知识储备，那就是一个SQL中的where条件如何拆分？</p>
<p>在这里，我直接给出分析后的结果：</p>
<ul>
<li><strong>Index key</strong>：pubtime &gt; 1 and puptime &lt; 20。此条件，用于确定SQL在idx_t1_pu索引上的查询范围。</li>
<li><strong>Index Filter</strong>：userid &#x3D; ‘hero’ 。此条件，可以在idx_t1_pu索引上进行过滤，但不属于IndexKey。</li>
<li><strong>Table Filter</strong>：comment is not NULL。此条件，在idx_t1_pu索引上无法过滤，只能在SQL-Layer上过滤。</li>
</ul>
<p>在分析出SQL where条件的构成之后，再来看看这条SQL的加锁情况 （默认隔离级别RR）</p>
<p>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250630.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>从图中可以看出，在RR隔离级别下，由Index Key所确定的范围，被加上了间隙锁；Index Filter锁给定的条件视MySQL的版本而定【图中，用红色箭头标出的写锁是否要加，与ICP有关】</p>
<ul>
<li>不支持ICP，因此Index Filter在MySQL Server层过滤，不满足Index Filter的记录，也需要加上记录写锁；</li>
<li>支持了ICP，则在index上过滤，则不满足Index Filter的记录，无需加记录写锁；</li>
</ul>
<p>而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要写锁。最后，选取出了一条满足条件的记录 [8，hero,d,5,handsome] ，但是加锁的数量，要远远大于满足条件的记录数量。</p>
<p><strong>结论：</strong></p>
<p>在RR隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。</p>
<ul>
<li>Index Key确定的范围，需要加上间隙锁；</li>
<li>Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足Index Filter的记录，不加写锁，否则需要写锁；</li>
<li>Table Filter过滤条件，无论是否满足，都需要加写锁。</li>
</ul>
<h2 id="6-死锁原理"><a href="#6-死锁原理" class="headerlink" title="6. 死锁原理"></a>6. 死锁原理</h2><p>深入理解MySQL如何加锁，有两个比较重要的作用：</p>
<ul>
<li>可以根据MySQL的加锁规则，写出不会发生死锁的SQL；</li>
<li>可以根据MySQL的加锁规则，定位出线上产生死锁的原因；</li>
<li>可以根据MySQL的加锁规则，透过现象看本质，理解数据库层 面 阻塞执行的根本原因</li>
</ul>
<h3 id="6-1-什么是死锁？"><a href="#6-1-什么是死锁？" class="headerlink" title="6.1 什么是死锁？"></a>6.1 什么是死锁？</h3><h4 id="情况01"><a href="#情况01" class="headerlink" title="情况01"></a>情况01</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t1_deadlock` (<br>`id` int(11) NOT NULL,<br>`name` varchar(100) DEFAULT NULL,<br>`age` int(11) NOT NULL,<br>`address` varchar(255) DEFAULT NULL,<br>PRIMARY KEY (`id`),<br>KEY `idx_age` (`age`) USING BTREE,<br>KEY `idx_name` (`name`) USING BTREE<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;<br>Insert into t1_deadlock(id,name,age,address) values (1,&#x27;刘备&#x27;,18,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (2,&#x27;关羽&#x27;,17,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (3,&#x27;张飞&#x27;,16,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (4,&#x27;关羽&#x27;,16,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (5,&#x27;诸葛亮&#x27;,35,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (6,&#x27;曹孟德&#x27;,32,&#x27;魏国&#x27;);<br></code></pre></td></tr></table></figure>

<p>下面，来看看两个死锁的例子 <strong>一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁</strong>：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th><strong>session01</strong></th>
<th><strong>session02</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td>T2</td>
<td>select * from t1_deadlock where id&#x3D;1 for<br/>update;</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>delete from t1_deadlock where<br/>id&#x3D;5;</td>
</tr>
<tr>
<td>T4</td>
<td>update t1_deadlock set name&#x3D;’qqq’ where<br/>id&#x3D;5;</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>死锁</td>
<td>delete from t1_deadlock where<br/>id&#x3D;1;</td>
</tr>
<tr>
<td>T6</td>
<td>commit;</td>
<td>commit;</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250569.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- Session01<br>begin;<br>select * from t1_deadlock where id=1 for update;<br>update t1_deadlock set name=&#x27;qqq&#x27; where id=5;<br>commit;<br>-- Session02<br>begin;<br>delete from t1_deadlock where id=5;<br>delete from t1_deadlock where id=1;<br>-- 死锁<br>commit;<br></code></pre></td></tr></table></figure>

<h4 id="情况02"><a href="#情况02" class="headerlink" title="情况02"></a>情况02</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250050.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t1_deadlock03` (<br>`id` int(11) NOT NULL AUTO_INCREMENT,<br>`cnt` varchar(32) DEFAULT NULL,<br>PRIMARY KEY (`id`),<br>UNIQUE index `idx_cnt` (`cnt`) USING BTREE<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;<br>insert into t1_deadlock03(id,cnt) values (1,&#x27;abc-130-sz&#x27;);<br>select * from t1_deadlock03<br>-- Session01<br>begin;<br>delete from t1_deadlock03 where cnt=&#x27;abc-130-sz&#x27;;<br>insert into t1_deadlock03(cnt) values (&#x27;abc-130-sz&#x27;);<br>commit;<br>-- Session01<br>begin;<br>delete from t1_deadlock03 where cnt=&#x27;abc-130-sz&#x27;;<br>commit;<br></code></pre></td></tr></table></figure>

<p><strong>结论：</strong></p>
<p>死锁的发生与否，并不在于事务中有多少条SQL语句，【<strong>死锁的关键在于</strong>】：两个(或以上)的Session【加锁的顺序】不一致。</p>
<p>查询最近一次死锁日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW ENGINE INNODB STATUS;<br></code></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs perl">------------------------<br>LATEST DETECTED DEADLOCK<br>------------------------<br><span class="hljs-number">2022</span>-<span class="hljs-number">10</span>-<span class="hljs-number">21</span> <span class="hljs-number">22</span>:<span class="hljs-number">31</span>:09 <span class="hljs-number">0x7ff508111700</span><br>*** (<span class="hljs-number">1</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">6083</span>, ACTIVE <span class="hljs-number">5</span> sec starting <span class="hljs-keyword">index</span> <span class="hljs-keyword">read</span><br>mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br>LOCK WAIT <span class="hljs-number">2</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">1</span> row lock(s)<br>MySQL thread id <span class="hljs-number">690</span>, OS thread handle <span class="hljs-number">140690379863808</span>, query id <span class="hljs-number">4831</span><br><span class="hljs-number">192.168</span>.<span class="hljs-number">200.1</span> root updating<br><span class="hljs-keyword">delete</span> from t1_deadlock03 where cnt =<span class="hljs-string">&#x27;abc-130-sz&#x27;</span><br>*** (<span class="hljs-number">1</span>) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">92</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> idx_cnt of table<br><span class="hljs-string">`hello`</span>.<span class="hljs-string">`t1_deadlock03`</span> trx id <span class="hljs-number">6083</span> lock_mode X waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> PHYSICAL RECORD: n_fields <span class="hljs-number">2</span>; compact <span class="hljs-keyword">format</span>; info<br>bits <span class="hljs-number">32</span><br><span class="hljs-number">0</span>: len <span class="hljs-number">10</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">6162632</span>d3133302d737a; asc abc-<span class="hljs-number">130</span>-sz;;<br><span class="hljs-number">1</span>: len <span class="hljs-number">4</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">80000002</span>; asc ;;<br>*** (<span class="hljs-number">2</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">6078</span>, ACTIVE <span class="hljs-number">8</span> sec inserting<br>mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br><span class="hljs-number">4</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">3</span> row lock(s), undo <span class="hljs-keyword">log</span> entries <span class="hljs-number">2</span><br>MySQL thread id <span class="hljs-number">696</span>, OS thread handle <span class="hljs-number">140690379052800</span>, query id <span class="hljs-number">4835</span><br><span class="hljs-number">192.168</span>.<span class="hljs-number">200.1</span> root update<br>insert into t1_deadlock03(cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;abc-130-sz&#x27;</span>)<br>*** (<span class="hljs-number">2</span>) HOLDS THE LOCK(S):<br>RECORD LOCKS space id <span class="hljs-number">92</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> idx_cnt of table<br><span class="hljs-string">`hello`</span>.<span class="hljs-string">`t1_deadlock03`</span> trx id <span class="hljs-number">6078</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> PHYSICAL RECORD: n_fields <span class="hljs-number">2</span>; compact <span class="hljs-keyword">format</span>; info<br>bits <span class="hljs-number">32</span><br><span class="hljs-number">0</span>: len <span class="hljs-number">10</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">6162632</span>d3133302d737a; asc abc-<span class="hljs-number">130</span>-sz;;<br><span class="hljs-number">1</span>: len <span class="hljs-number">4</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">80000002</span>; asc ;;<br>*** (<span class="hljs-number">2</span>) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">92</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> idx_cnt of table<br><span class="hljs-string">`hello`</span>.<span class="hljs-string">`t1_deadlock03`</span> trx id <span class="hljs-number">6078</span> lock mode S waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> PHYSICAL RECORD: n_fields <span class="hljs-number">2</span>; compact <span class="hljs-keyword">format</span>; info<br>bits <span class="hljs-number">32</span><br><span class="hljs-number">0</span>: len <span class="hljs-number">10</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">6162632</span>d3133302d737a; asc abc-<span class="hljs-number">130</span>-sz;;<br><span class="hljs-number">1</span>: len <span class="hljs-number">4</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">80000002</span>; asc ;;<br>*** WE ROLL BACK TRANSACTION (<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h3 id="6-2-如何避免死锁呢？"><a href="#6-2-如何避免死锁呢？" class="headerlink" title="6.2 如何避免死锁呢？"></a>6.2 如何避免死锁呢？</h3><p>MySQL默认会主动探知死锁，并回滚某一个影响最小的事务。等另一事务执行完成之后，再重新执行该事务。</p>
<ol>
<li><p>注意程序的逻辑：根本的原因是程序逻辑的顺序交叠，最常见的是交差更新</p>
</li>
<li><p>保持事务的轻量：越是轻量的事务，占有越少的锁资源，这样发生死锁的几率就越小</p>
</li>
<li><p>提高运行的速度：避免使用子查询，尽量使用主键等等</p>
</li>
<li><p>尽量快提交事务，减少持有锁的时间：越早提交事务，锁就越早释放</p>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%90%8E%E7%AB%AF/" class="category-chain-item">后端</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%90%8E%E7%AB%AF/MySQL/" class="category-chain-item">MySQL</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%90%8E%E7%AB%AF/MySQL/MySQL%E8%BF%9B%E9%98%B6/" class="category-chain-item">MySQL进阶</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MySQL/">#MySQL</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL锁篇</div>
      <div>https://haktiong.gitee.io/2022/05/27/MySQL锁篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Haktiong</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/08/MySQL%E7%B4%A2%E5%BC%95%E7%AF%87/" title="MySQL索引篇">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL索引篇</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/03/MySQL%E4%BA%8B%E5%8A%A1%E7%AF%87/" title="MySQL事务篇">
                        <span class="hidden-mobile">MySQL事务篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
