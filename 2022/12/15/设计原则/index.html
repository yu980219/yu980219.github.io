

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.jpg">
  <link rel="icon" href="/img/avatar.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Haktiong">
  <meta name="keywords" content="">
  
    <meta name="description" content="六大设计原则文章摘自《设计模式之禅(第二版)》- 秦小波 一、单一职责原则 英文名称是Single Responsibility Principle，简称是SRP。 原话解释：There should never be more than one reason for a class to change.  定义：应该有且仅有一个原因引起类的变更。 示例：电话通话的时候有4个过程发生：拨号、通话、">
<meta property="og:type" content="article">
<meta property="og:title" content="六大设计原则">
<meta property="og:url" content="https://haktiong.gitee.io/2022/12/15/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/index.html">
<meta property="og:site_name" content="Haktiong&#39;s Blog">
<meta property="og:description" content="六大设计原则文章摘自《设计模式之禅(第二版)》- 秦小波 一、单一职责原则 英文名称是Single Responsibility Principle，简称是SRP。 原话解释：There should never be more than one reason for a class to change.  定义：应该有且仅有一个原因引起类的变更。 示例：电话通话的时候有4个过程发生：拨号、通话、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://haktiong.gitee.io/img/default.jpeg">
<meta property="article:published_time" content="2022-12-14T18:38:00.000Z">
<meta property="article:modified_time" content="2025-03-04T02:52:11.634Z">
<meta property="article:author" content="Haktiong">
<meta property="article:tag" content="设计原则">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://haktiong.gitee.io/img/default.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>六大设计原则 - Haktiong&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"haktiong.gitee.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Haktiong</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="六大设计原则"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-15 02:38" pubdate>
          2022年12月15日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          166 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">六大设计原则</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h1><p>文章摘自《设计模式之禅(第二版)》- 秦小波</p>
<h2 id="一、单一职责原则"><a href="#一、单一职责原则" class="headerlink" title="一、单一职责原则"></a>一、单一职责原则</h2><blockquote>
<p>英文名称是Single Responsibility Principle，简称是SRP。</p>
<p>原话解释：<em>There should never be more than one reason for a class to change.</em></p>
</blockquote>
<p><strong>定义：应该有且仅有一个原因引起类的变更。</strong></p>
<p><strong>示例</strong>：电话通话的时候有4个过程发生：拨号、通话、回应、挂机，那我们写一个接口。</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221213231244890.png" srcset="/img/loading.gif" lazyload alt="image-20221213231244890"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPhone</span> &#123;<br>    <span class="hljs-comment">//拨通电话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dial</span><span class="hljs-params">(String phoneNumber)</span>;<br>    <span class="hljs-comment">//通话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chat</span><span class="hljs-params">(Object o)</span>;<br>    <span class="hljs-comment">//通话完毕，挂电话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hangup</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情，看看上面的接口只负责一件事情吗？是只有一个原因引起变化吗？好像不是！</p>
<p>IPhone这个接口可不是只有一个职责，它包含了两个职责：一个是协议管理，一个是数据传送。</p>
<ul>
<li><p><code>dial()</code>和<code>hangup()</code>两个方法实现的是协议管理，分别负责拨号接通和挂机；</p>
</li>
<li><p><code>chat()</code>实现的是数据的传送，把我们说的话转换成模拟信号或数字信号传递到对方，然后再把对方传递过来的信号还原成我们听得懂的语言。</p>
</li>
</ul>
<p><strong>思考：</strong></p>
<p>协议接通的变化会引起这个接口或实现类的变化吗？会的！</p>
<p>那数据传送（想想看，电话不仅仅可以通话，还可以上网）的变化会引起这个接口或实现类的变化吗？会的！</p>
<p>通过这样的分析，我们发现类图上的IPhone接口包含了两个职责，而且这两个职责的变化不相互影响，那就考虑拆分成两个接口。</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221213232355372.png" srcset="/img/loading.gif" lazyload alt="image-20221213232355372"></p>
<p>这样的设计才是完美的，一个类实现了两个接口，把两个职责融合在一个类中。</p>
<p><em>你会觉得这个Phone有两个原因引起变化了呀，是的，但是别忘记了我们是面向接口编程，我们对外公布的是接口而不是实现类。</em></p>
<p><strong>单一职责的好处：</strong></p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>
<li>可读性提高，复杂性降低，那当然可读性提高了；</li>
<li>可维护性提高，可读性提高，那当然更容易维护了；</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<p><strong>注意：</strong>单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因<strong>项目</strong>而异，因<strong>环境</strong>而异。</p>
<h2 id="二、里氏替换原则"><a href="#二、里氏替换原则" class="headerlink" title="二、里氏替换原则"></a>二、里氏替换原则</h2><blockquote>
<p>里氏替换原则：Liskov Substitution Principle，LSP</p>
</blockquote>
<p>在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下<strong>优点</strong>：</p>
<ul>
<li><p>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；</p>
</li>
<li><p>提高代码的重用性；</p>
</li>
<li><p>子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；</p>
</li>
<li><p>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；</p>
</li>
<li><p>提高产品或项目的开放性。</p>
</li>
</ul>
<p>自然界的所有事物都是优点和缺点并存的，即使是鸡蛋，有时候也能挑出骨头来，继承的<strong>缺点</strong>如下：</p>
<ul>
<li>继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；</li>
<li>降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；</li>
<li>增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。</li>
</ul>
<p><strong>定义：</strong></p>
<p><strong>第一种定义：</strong></p>
<p>也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）</p>
<p><strong>第二种定义：</strong></p>
<p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p>
<p><strong>解释：</strong>第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。</p>
<hr>
<p>这里的示例带有违规词语，暂时省略。</p>
<p><strong>总结：</strong>采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。</p>
<h2 id="三、依赖倒置原则"><a href="#三、依赖倒置原则" class="headerlink" title="三、依赖倒置原则"></a>三、依赖倒置原则</h2><blockquote>
<p>依赖倒置原则（Dependence Inversion Principle,DIP）</p>
<p>High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.</p>
</blockquote>
<p>翻译过来，包含三层含义：</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。</li>
</ul>
<p>高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。</p>
<p>那什么是抽象？什么又是细节呢？在Java语言中，</p>
<p>抽象就是指接口或抽象类，两者都是不能直接被实例化的；</p>
<p>细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。</p>
<p>依赖倒置原则在Java语言中的表现就是：</p>
<ul>
<li><p>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</p>
</li>
<li><p>接口或抽象类不依赖于实现类；</p>
</li>
<li><p>实现类依赖接口或抽象类。</p>
</li>
</ul>
<p>更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。</p>
<p><strong>示例：</strong></p>
<p>现在的汽车越来越便宜了，一个卫生间的造价就可以买到一辆不错的汽车，有汽车就必然有人来驾驶，司机驾驶奔驰车的类图。</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221214004905796.png" srcset="/img/loading.gif" lazyload alt="image-20221214004905796"></p>
<p>奔驰车可以提供一个方法run，代表车辆运行，</p>
<p><strong>司机源代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123;<br>    <span class="hljs-comment">//司机的主要职责就是驾驶汽车</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(Benz benz)</span>&#123;<br>        benz.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>司机通过调用奔驰车的run方法开动奔驰车</p>
<p><strong>奔驰车源代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> &#123;<br>    <span class="hljs-comment">//汽车肯定会跑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;奔驰汽车开始运行...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>场景类源代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Driver</span> <span class="hljs-variable">zhangSan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br>        <span class="hljs-type">Benz</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br>        <span class="hljs-comment">//张三开奔驰车</span><br>        zhangSan.drive(benz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过以上的代码，完成了司机开动奔驰车的场景，到目前为止，这个司机开奔驰车的项目没有任何问题。我们常说“危难时刻见真情”，我们把这句话移植到技术上就成了“变更才显真功夫”，业务需求变更永无休止，技术前进就永无止境，在发生变更时才能发觉我们的设计或程序是否是松耦合。我们在一段貌似磐石的程序上加上一块小石头：张三司机不仅要开奔驰车，还要开宝马车，又该怎么实现呢？麻烦出来了，那好，我们走一步是一步，我们先把宝马车产生出来</p>
<p><strong>宝马车源代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BMW</span> &#123;<br>    <span class="hljs-comment">//宝马车当然也可以开动了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;宝马汽车开始运行...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>宝马车也产生了，但是我们却没有办法让张三开动起来，为什么？张三没有开动宝马车的方法呀！一个拿有C驾照的司机竟然只能开奔驰车而不能开宝马车，这也太不合理了！在现实世界都不允许存在这种情况，何况程序还是对现实世界的抽象，我们的设计出现了问题：司机类和奔驰车类之间是紧耦合的关系，其导致的结果就是系统的可维护性大大降低，可读性降低，两个相似的类需要阅读两个文件，你乐意吗？还有稳定性，什么是稳定性？固化的、健壮的才是稳定的，这里只是增加了一个车类就需要修改司机类，这不是稳定性，这是易变性。被依赖者的变更竟然让依赖者来承担修改的成本，这样的依赖关系谁肯承担！</p>
<p>根据以上证明，如果不使用依赖倒置原则就会加重类间的耦合性，降低系统的稳定性，增加并行开发引起的风险，降低代码的可读性和可维护性。承接上面的例子，引入依赖倒置原则后的类图。</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221214005252180.png" srcset="/img/loading.gif" lazyload alt="image-20221214005252180"></p>
<p>建立两个接口：IDriver和ICar，分别定义了司机和汽车的各个职能，司机就是驾驶汽车，必须实现drive()方法。</p>
<p><strong>司机接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IDriver</span> &#123;<br>    <span class="hljs-comment">//是司机就应该会驾驶汽车</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(ICar car)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>司机类的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IDriver</span>&#123;<br>    <span class="hljs-comment">//司机的主要职责就是驾驶汽车</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(ICar car)</span>&#123;<br>        car.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在IDriver中，通过传入ICar接口实现了抽象之间的依赖关系，Driver实现类也传入了ICar接口，至于到底是哪个型号的Car，需要在高层模块中声明。</p>
<p><strong>汽车接口及两个实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICar</span> &#123;<br>    <span class="hljs-comment">//是汽车就应该能跑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span>&#123;<br>    <span class="hljs-comment">//汽车肯定会跑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;奔驰汽车开始运行...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BMW</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span>&#123;<br>    <span class="hljs-comment">//宝马车当然也可以开动了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;宝马汽车开始运行...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在业务场景中，我们贯彻“抽象不应该依赖细节”，也就是我们认为抽象（ICar接口）不依赖BMW和Benz两个实现类（细节），因此在高层次的模块中应用都是抽象。</p>
<p><strong>业务场景：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IDriver</span> <span class="hljs-variable">zhangSan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br>        <span class="hljs-type">ICar</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br>        <span class="hljs-comment">//张三开奔驰车</span><br>        zhangSan.drive(benz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Client属于高层业务逻辑，它对低层模块的依赖都建立在抽象上，zhangSan的表面类型是IDriver，Benz的表面类型是ICar，也许你要问，在这个高层模块中也调用到了低层模块，比如new Driver()和new Benz()等，如何解释？确实如此，zhangSan的表面类型是IDriver，是一个接口，是抽象的、非实体化的，在其后的所有操作中，zhangSan都是以IDriver类型进行操作，屏蔽了细节对抽象的影响。当然，张三如果要开宝马车，也很容易，我们只要修改业务场景类就可以。</p>
<p><strong>张三驾驶宝马车的实现过程：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IDriver</span> <span class="hljs-variable">zhangSan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br>        <span class="hljs-type">ICar</span> <span class="hljs-variable">bmw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>();<br>        <span class="hljs-comment">//张三开奔驰车</span><br>        zhangSan.drive(bmw);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在新增加低层模块时，只修改了业务场景类，也就是高层模块，对其他低层模块如Driver类不需要做任何修改，业务就可以运行，把“变更”引起的风险扩散降到最低。</p>
<p><strong>总结：</strong></p>
<p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以：</p>
<ul>
<li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</li>
<li>变量的表面类型尽量是接口或者是抽象类</li>
<li>任何类都不应该从具体类派生</li>
<li>尽量不要覆写基类的方法</li>
<li>结合里氏替换原则使用</li>
</ul>
<h2 id="四、接口隔离原则"><a href="#四、接口隔离原则" class="headerlink" title="四、接口隔离原则"></a>四、接口隔离原则</h2><p>接口分为两种：</p>
<ul>
<li>实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，这是一种接口。比如你定义Person这个类，然后使用Person zhangSan&#x3D;new Person()产生了一个实例，这个实例要遵从的标准就是Person这个类，Person类就是zhangSan的接口。疑惑？看不懂？不要紧，那是因为让Java语言浸染的时间太长了，只要知道从这个角度来看，Java中的类也是一种接口。</li>
<li>类接口（Class Interface），Java中经常使用的interface关键字定义的接口。</li>
</ul>
<p>什么是隔离？</p>
<ul>
<li>Clients should not be forced to depend upon interfaces that they don’t use.（客户端不应该依赖它不需要的接口。）</li>
<li>The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）</li>
</ul>
<p>这两个定义概括为一句话：<strong>建立单一接口，不要建立臃肿庞大的接口。</strong></p>
<p><strong>示例：</strong></p>
<p>我们举例来说明接口隔离原则到底对我们提出了什么要求。现在男生对小姑娘的称呼，使用频率最高的应该是“美女”了吧，你在大街上叫一声：“嗨，美女！”估计10个有8个回头，其中包括那位著名的如花。美女的标准各不相同，首先就需要定义一下什么是美女：首先要面貌好看，其次是身材要窈窕，然后要有气质，当然了，这三者各人的排列顺序不一样，总之要成为一名美女就必须具备：面貌、身材和气质，我们用类图体现一下星探（当然，你也可以把自己想象成星探）找美女的过程。</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215013157868.png" srcset="/img/loading.gif" lazyload alt="image-20221215013157868"></p>
<p>定义了一个IPettyGirl接口，声明所有的美女都应该有goodLooking、niceFigure和greatTemperament，然后又定义了一个抽象类AbstractSearcher，其作用就是搜索美女并显示其信息，只要美女都按照这个规范定义，Searcher（星探）就轻松多了。</p>
<p><strong>美女类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPettyGirl</span> &#123;<br>    <span class="hljs-comment">//要有姣好的面孔</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//要有好身材</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//要有气质</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>美女实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PettyGirl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPettyGirl</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//美女都有名字</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PettyGirl</span><span class="hljs-params">(String _name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=_name;<br>    &#125;<br>    <span class="hljs-comment">//脸蛋漂亮</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---脸蛋很漂亮!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//气质要好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---气质非常好!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//身材要好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---身材非常棒!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过三个方法，把对美女的要求都定义出来了，按照这个标准，如花姑娘被排除在美女标准之外了。有美女，就有搜索美女的星探。</p>
<p><strong>星探抽象类源代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSearcher</span> &#123;<br>    <span class="hljs-keyword">protected</span> IPettyGirl pettyGirl;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractSearcher</span><span class="hljs-params">(IPettyGirl _pettyGirl)</span>&#123;<br>        <span class="hljs-built_in">this</span>.pettyGirl = _pettyGirl;<br>    &#125;<br>    <span class="hljs-comment">//搜索美女，列出美女信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>星探类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Searcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSearcher</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Searcher</span><span class="hljs-params">(IPettyGirl _pettyGirl)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_pettyGirl);<br>    &#125;<br>    <span class="hljs-comment">//展示美女的信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;--------美女的信息如下：---------------&quot;</span>);<br>        <span class="hljs-comment">//展示面容</span><br>        <span class="hljs-built_in">super</span>.pettyGirl.goodLooking();<br>        <span class="hljs-comment">//展示身材</span><br>        <span class="hljs-built_in">super</span>.pettyGirl.niceFigure();<br>        <span class="hljs-comment">//展示气质</span><br>        <span class="hljs-built_in">super</span>.pettyGirl.greatTemperament();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>场景中的两个角色美女和星探都已经出现了，需要写一个场景类来串联起各个角色。</p>
<p><strong>场景类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-comment">//搜索并展示美女信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义一个美女</span><br>        <span class="hljs-type">IPettyGirl</span> <span class="hljs-variable">yanYan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PettyGirl</span>(<span class="hljs-string">&quot;嫣嫣&quot;</span>);<br>        <span class="hljs-type">AbstractSearcher</span> <span class="hljs-variable">searcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Searcher</span>(yanYan);<br>        searcher.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>——–美女的信息如下：—————</p>
<p>嫣嫣—脸蛋很漂亮!</p>
<p>嫣嫣—身材非常棒!</p>
<p>嫣嫣—气质非常好!</p>
</blockquote>
<p>思考一下IPettyGirl这个接口，这个接口是否做到了最优化设计？</p>
<p>我们的审美观点都在改变，美女的定义也在变化。唐朝的杨贵妃如果活在现在这个年代非羞愧而死不可，为什么？胖呀！但是胖并不影响她入选中国四大美女，说明当时的审美观与现在是有差异的。当然，随着时代的发展我们的审美观也在变化，当你发现有一个女孩，脸蛋不怎么样，身材也一般般，但是气质非常好，我相信大部分人都会把这样的女孩叫美女，审美素质提升了，就产生了气质型美女，但是我们的接口却定义了美女必须是三者都具备，按照这个标准，气质型美女就不能算美女，那怎么办？可能你要说了，我重新扩展一个美女类，只实现greatTemperament方法，其他两个方法置空，什么都不写，不就可以了吗？聪明，但是行不通！为什么呢？星探AbstractSearcher依赖的是IPettyGirl接口，它有三个方法，你只实现了两个方法，星探的方法是不是要修改？我们上面的程序打印出来的信息少了两条，还让星探怎么去辨别是不是美女呢？</p>
<p>分析到这里，我们发现接口IPettyGirl的设计是有缺陷的，过于庞大了，容纳了一些可变的因素，根据接口隔离原则，星探AbstractSearcher应该依赖于具有部分特质的女孩子，而我们却把这些特质都封装了起来，放到了一个接口中，封装过度了！问题找到了，我们重新设计一下类图。</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215013744728.png" srcset="/img/loading.gif" lazyload alt="image-20221215013744728"></p>
<p>把原IPettyGirl接口拆分为两个接口，一种是外形美的美女IGoodBodyGirl，这类美女的特点就是脸蛋和身材极棒，超一流，但是没有审美素质，比如随地吐痰，文化程度比较低；</p>
<p>另外一种是气质美的美女IGreatTemperamentGirl，谈吐和修养都非常高。</p>
<p>我们把一个比较臃肿的接口拆分成了两个专门的接口，灵活性提高了，可维护性也增加了，不管以后是要外形美的美女还是气质美的美女都可以轻松地通过PettyGirl定义。</p>
<p><strong>两种类型的美女定义：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGoodBodyGirl</span> &#123;<br>    <span class="hljs-comment">//要有姣好的面孔</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//要有好身材</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGreatTemperamentGirl</span> &#123;<br>    <span class="hljs-comment">//要有气质</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>按照脸蛋、身材、气质都具备才算美女，实现类实现两个接口</p>
<p><strong>最标准的美女：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PettyGirl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IGoodBodyGirl</span>,IGreatTemperamentGirl &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//美女都有名字</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PettyGirl</span><span class="hljs-params">(String _name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=_name;<br>    &#125;<br>    <span class="hljs-comment">//脸蛋漂亮</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---脸蛋很漂亮!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//气质要好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---气质非常好!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//身材要好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---身材非常棒!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过这样的重构以后，不管以后是要气质美女还是要外形美女，都可以保持接口的稳定。当然，你可能要说了，以后可能审美观点再发生改变，只有脸蛋好看就是美女，那这个IGoodBody接口还是要修改的呀，确实是，但是设计是有限度的，不能无限地考虑未来的变更情况，否则就会陷入设计的泥潭中而不能自拔。</p>
<p>以上把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，让星探AbstractSearcher依赖两个专用的接口比依赖一个综合的接口要灵活。接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。</p>
<p><strong>定义：</strong></p>
<p>接口隔离原则是对接口进行规范约束，其包含以下4层含义：</p>
<ul>
<li>接口要尽量小</li>
<li>接口要高内聚</li>
<li>定制服务</li>
<li>接口设计是有限度的</li>
</ul>
<h2 id="五、迪米特法则"><a href="#五、迪米特法则" class="headerlink" title="五、迪米特法则"></a>五、迪米特法则</h2><blockquote>
<p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least KnowledgePrinciple，LKP）</p>
</blockquote>
<p>虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。</p>
<p>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。</p>
<p><strong>定义：</strong></p>
<ol>
<li><strong>只和朋友交流</strong></li>
</ol>
<p>迪米特法则还有一个英文解释是：Only talk to your immediate friends（只与直接的朋友通信。）</p>
<p><strong>示例：</strong></p>
<p>老师想让体育委员确认一下全班女生来齐没有，就对他说：“你去把全班女生清一下。”</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215015101115.png" srcset="/img/loading.gif" lazyload alt="image-20221215015101115"></p>
<p>Teacher类的commond方法负责发送命令给体育会员，命令他清点女生。</p>
<p><strong>老师类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-comment">//老师对学生发布命令，清一下女生</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commond</span><span class="hljs-params">(GroupLeader groupLeader)</span>&#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">listGirls</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">//初始化女生</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>            listGirls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>());<br>        &#125;<br>        <span class="hljs-comment">//告诉体育委员开始执行清查任务</span><br>        groupLeader.countGirls(listGirls);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>老师只有一个方法commond，先定义出所有的女生，然后发布命令给体育委员，去清点一下女生的数量。</p>
<p><strong>体育委员类实现过程：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupLeader</span> &#123;<br>    <span class="hljs-comment">//清查女生数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countGirls</span><span class="hljs-params">(List&lt;Girl&gt; listGirls)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;女生数量是：&quot;</span>+listGirls.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>老师类和体育委员类都对女生类产生依赖，而且女生类不需要执行任何动作。</p>
<p><strong>女生类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>故事中的三个角色都已经有了，再定义一个场景类来描述这个故事：</p>
<p><strong>场景类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Teacher teacher= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        <span class="hljs-comment">//老师发布命令</span><br>        teacher.commond(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupLeader</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>女生数量是：20</p>
</blockquote>
<p>体育委员按照老师的要求对女生进行了清点，并得出了数量。我们回过头来思考一下这个程序有什么问题，首先确定Teacher类有几个朋友类，它仅有一个朋友类——</p>
<p>GroupLeader。为什么Girl不是朋友类呢？Teacher也对它产生了依赖关系呀！</p>
<p>朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类，而Girl这个类就是出现在commond方法体内，因此不属于Teacher类的朋友类。</p>
<p>迪米特法则告诉我们一个类只和朋友类交流，但是我们刚刚定义的commond方法却与Girl类有了交流，声明了一个<code>List&lt;Girls&gt;</code>动态数组，也就是与一个陌生的类Girl有了交流，这样就破坏了Teacher的健壮性。方法是类的一个行为，类竟然不知道自己的行为与其他类产生依赖关系，这是不允许的，严重违反了迪米特法则。</p>
<p>问题已经发现，我们修改一下程序，将类图稍作修改。</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215015414863.png" srcset="/img/loading.gif" lazyload alt="image-20221215015414863"></p>
<p>在类图中去掉Teacher对Girl类的依赖关系</p>
<p><strong>修改后的老师类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-comment">//老师对学生发布命令，清一下女生</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commond</span><span class="hljs-params">(GroupLeader groupLeader)</span>&#123;<br>        <span class="hljs-comment">//告诉体育委员开始执行清查任务</span><br>        groupLeader.countGirls();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>修改后的体育委员类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupLeader</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Girl&gt; listGirls;<br>    <span class="hljs-comment">//传递全班的女生进来</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GroupLeader</span><span class="hljs-params">(List&lt;Girl&gt; _listGirls)</span>&#123;<br>        <span class="hljs-built_in">this</span>.listGirls = _listGirls;<br>    &#125;<br>    <span class="hljs-comment">//清查女生数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countGirls</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;女生数量是：&quot;</span>+<span class="hljs-built_in">this</span>.listGirls.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在GroupLeader类中定义了一个构造函数，通过构造函数传递了依赖关系</p>
<p><strong>修改后的场景类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//产生一个女生群体</span><br>        List&lt;Girl&gt; listGirls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Girl&gt;();<br>        <span class="hljs-comment">//初始化女生</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>            listGirls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>());<br>        &#125;<br>        Teacher teacher= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        <span class="hljs-comment">//老师发布命令</span><br>        teacher.commond(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupLeader</span>(listGirls));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对程序进行了简单的修改，把Teacher中对<code>List&lt;Girl&gt;</code>的初始化移动到了场景类中，同时在GroupLeader中增加了对Girl的注入，避开了Teacher类对陌生类Girl的访问，降低了系统间的耦合，提高了系统的健壮性。</p>
<p><strong>注意：</strong>一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。</p>
<ol start="2">
<li><strong>朋友间也是有距离的</strong></li>
</ol>
<p><strong>示例：</strong></p>
<p>我们在安装软件的时候，经常会有一个导向动作，第一步是确认是否安装，第二步确认License，再然后选择安装目录……这是一个典型的顺序执行动作，具体到程序中就是：调用一个或多个类，先执行第一个方法，然后是第二个方法，根据返回结果再来看是否可以调用第三个方法，或者第四个方法，等等</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215015851748.png" srcset="/img/loading.gif" lazyload alt="image-20221215015851748"></p>
<p>很简单的类图，实现软件安装的过程，其中first方法定义第一步做什么，second方法定义第二步做什么，third方法定义第三步做什么。</p>
<p><strong>导向类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wizard</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(System.currentTimeMillis());<br>    <span class="hljs-comment">//第一步</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第一个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-comment">//第二步</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第二个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-comment">//第三个方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">third</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第三个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Wizard类中分别定义了三个步骤方法，每个步骤中都有相关的业务逻辑完成指定的任务，我们使用一个随机函数来代替业务执行的返回值。</p>
<p><strong>InstallSoftware类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstallSoftware</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installWizard</span><span class="hljs-params">(Wizard wizard)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> wizard.first();<br>        <span class="hljs-comment">//根据first返回的结果，看是否需要执行second</span><br>        <span class="hljs-keyword">if</span>(first&gt;<span class="hljs-number">50</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> wizard.second();<br>            <span class="hljs-keyword">if</span>(second&gt;<span class="hljs-number">50</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">third</span> <span class="hljs-operator">=</span> wizard.third();<br>                <span class="hljs-keyword">if</span>(third &gt;<span class="hljs-number">50</span>)&#123;<br>                    wizard.first();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>场景类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InstallSoftware</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstallSoftware</span>();<br>        invoker.installWizard(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上程序很简单，运行结果和随机数有关，每次的执行结果都不相同，需要读者自己运行并查看结果。程序虽然简单，但是隐藏的问题可不简单，思考一下程序有什么问题。</p>
<p>Wizard类把太多的方法暴露给InstallSoftware类，两者的朋友关系太亲密了，耦合关系变得异常牢固。如果要将Wizard类中的first方法返回值的类型由int改为boolean，就需要修改InstallSoftware类，从而把修改变更的风险扩散开了。因此，这样的耦合是极度不合适的，我们需要对设计进行重构，</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215020213522.png" srcset="/img/loading.gif" lazyload alt="image-20221215020213522"></p>
<p>在Wizard类中增加一个installWizard方法，对安装过程进行封装，同时把原有的三个<strong>public</strong>方法修改为<strong>private</strong>方法，</p>
<p><strong>修改后的导向类实现过程：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wizard</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(System.currentTimeMillis());<br>    <span class="hljs-comment">//第一步</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第一个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-comment">//第二步</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第二个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-comment">//第三个方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">third</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第三个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//软件安装过程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installWizard</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.first();<br>        <span class="hljs-comment">//根据first返回的结果，看是否需要执行second</span><br>        <span class="hljs-keyword">if</span>(first&gt;<span class="hljs-number">50</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.second();<br>            <span class="hljs-keyword">if</span>(second&gt;<span class="hljs-number">50</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">third</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.third();<br>                <span class="hljs-keyword">if</span>(third &gt;<span class="hljs-number">50</span>)&#123;<br>                    <span class="hljs-built_in">this</span>.first();<br>            	&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将三个步骤的访问权限修改为private，同时把InstallSoftware中的方法installWizad移动到Wizard方法中。通过这样的重构后，Wizard类就只对外公布了一个public方法，即使要修改first方法的返回值，影响的也仅仅只是Wizard本身，其他类不受影响，这显示了类的高内聚特性。</p>
<p>对InstallSoftware类进行少量的修改。</p>
<p><strong>修改后的InstallSoftware类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstallSoftware</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installWizard</span><span class="hljs-params">(Wizard wizard)</span>&#123;<br>        <span class="hljs-comment">//直接调用</span><br>        wizard.installWizard();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过进行重构，类间的耦合关系变弱了，结构也清晰了，变更引起的风险。</p>
<p>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。</p>
<p><strong>注意：</strong></p>
<p>迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。</p>
<ol start="3">
<li><strong>是自己的就是自己的</strong></li>
</ol>
<p>在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？</p>
<p>你可以坚持这样一个原则：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。</p>
<ol start="4">
<li><strong>谨慎使用Serializable</strong></li>
</ol>
<p>在实际应用中，这个问题是很少出现的，即使出现也会立即被发现并得到解决。是怎么回事呢？举个例子来说，在一个项目中使用RMI（Remote Method Invocation，远程方法调用）方式传递一个VO（Value Object，值对象），这个对象就必须实现Serializable接口（仅仅是一个标志性接口，不需要实现具体的方法），也就是把需要网络传输的对象进行序列化，否则就会出现NotSerializableException异常。突然有一天，客户端的VO修改了一个属性的访问权限，从private变更为public，访问权限扩大了，如果服务器上没有做出相应的变更，就会报序列化失败，就这么简单。但是这个问题的产生应该属于项目管理范畴，一个类或接口在客户端已经变更了，而服务器端却没有同步更新，难道不是项目管理的失职吗？</p>
<h2 id="六、开闭原则"><a href="#六、开闭原则" class="headerlink" title="六、开闭原则"></a>六、开闭原则</h2><p><strong>定义：</strong>Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）</p>
<p>软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p><strong>示例：</strong></p>
<p>以书店销售书籍为例</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215021804080.png" srcset="/img/loading.gif" lazyload alt="image-20221215021804080"></p>
<p>IBook定义了数据的三个属性：名称、价格和作者。小说类NovelBook是一个具体的实现类，是所有小说书籍的总称，BookStore指的是书店。</p>
<p>书籍接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBook</span> &#123;<br>    <span class="hljs-comment">//书籍有名称</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//书籍有售价</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//书籍有作者</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAuthor</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>目前书店只出售小说类书籍。</p>
<p>小说类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NovelBook</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBook</span> &#123;<br>    <span class="hljs-comment">//书籍名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//书籍的价格</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> price;<br>    <span class="hljs-comment">//书籍的作者</span><br>    <span class="hljs-keyword">private</span> String author;<br>    <span class="hljs-comment">//通过构造函数传递书籍数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NovelBook</span><span class="hljs-params">(String _name,<span class="hljs-type">int</span> _price,String _author)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = _name;<br>        <span class="hljs-built_in">this</span>.price = _price;<br>        <span class="hljs-built_in">this</span>.author = _author;<br>    &#125;<br>    <span class="hljs-comment">//获得作者是谁</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAuthor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.author;<br>    &#125;<br>    <span class="hljs-comment">//书籍叫什么名字</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>    <span class="hljs-comment">//获得书籍的价格</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.price;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>书店售书类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> ArrayList&lt;IBook&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;IBook&gt;();<br>    <span class="hljs-comment">//static静态模块初始化数据，实际项目中一般是由持久层完成</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;天龙八部&quot;</span>,<span class="hljs-number">3200</span>,<span class="hljs-string">&quot;金庸&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;巴黎圣母院&quot;</span>,<span class="hljs-number">5600</span>,<span class="hljs-string">&quot;雨果&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;悲惨世界&quot;</span>,<span class="hljs-number">3500</span>,<span class="hljs-string">&quot;雨果&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;JPM&quot;</span>,<span class="hljs-number">4300</span>,<span class="hljs-string">&quot;兰陵笑笑生&quot;</span>));<br>    &#125;<br>    <span class="hljs-comment">//模拟书店买书</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> NumberFormat.getCurrencyInstance();<br>        formatter.setMaximumFractionDigits(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;-----------书店卖出去的书籍记录如下：-----------&quot;</span>);<br>        <span class="hljs-keyword">for</span>(IBook book:bookList)&#123;<br>            System.out.println(<span class="hljs-string">&quot;书籍名称：&quot;</span> + book.getName()+<span class="hljs-string">&quot;\t书籍作者：&quot;</span> +<br>            book.getAuthor()+<span class="hljs-string">&quot;\t书籍价格：&quot;</span>+ formatter.format (book.getPrice()/<br>            <span class="hljs-number">100.0</span>)+<span class="hljs-string">&quot;元&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>—————–书店卖出去的书籍记录如下：————–</p>
<p>书籍名称：天龙八部 书籍作者：金庸 书籍价格：￥25.60元</p>
<p>书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：￥50.40元</p>
<p>书籍名称：悲惨世界 书籍作者：雨果 书籍价格：￥28.00元</p>
<p>书籍名称：JPM 书籍作者：兰陵笑笑生 书籍价格：￥38.70元</p>
</blockquote>
<p>项目投产了，书籍正常销售出去，书店也赢利了。从2008年开始，全球经济开始下滑，对零售业影响比较大，书店为了生存开始打折销售：所有40元以上的书籍9折销售，其他的8折销售。对已经投产的项目来说，这就是一个变化，我们应该如何应对这样一个需求变化？</p>
<ul>
<li>修改接口</li>
</ul>
<p>在IBook上新增加一个方法getOffPrice()，专门用于进行打折处理，所有的实现类实现该方法。但是这样修改的后果就是，实现类NovelBook要修改，BookStore中的main方法也修改，同时IBook作为接口应该是稳定且可靠的，不应该经常发生变化，否则接口作为契约的作用就失去了效能。因此，该方案否定。</p>
<ul>
<li>修改实现类</li>
</ul>
<p>修改NovelBook类中的方法，直接在getPrice()中实现打折处理，好办法，我相信大家在项目中经常使用的就是这样的办法，通过class文件替换的方式可以完成部分业务变化（或是缺陷修复）。该方法在项目有明确的章程（团队内约束）或优良的架构设计时，是一个非常优秀的方法，但是该方法还是有缺陷的。例如采购书籍人员也是要看价格的，由于该方法已经实现了打折处理价格，因此采购人员看到的也是打折后的价格，会因信息不对称而出现决策失误的情况。因此，该方案也不是一个最优的方案。</p>
<ul>
<li>通过扩展实现变化</li>
</ul>
<p>增加一个子类OffNovelBook，覆写getPrice方法，高层次的模块（也就是static静态模块区）通过OffNovelBook类产生新的对象，完成业务变化对系统的最小化开发。好办法，修改也少，风险也小</p>
<p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215022202797.png" srcset="/img/loading.gif" lazyload alt="image-20221215022202797"></p>
<p>OffNovelBook类继承了NovelBook，并覆写了getPrice方法，不修改原有的代码。</p>
<p>打折销售的小说类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OffNovelBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NovelBook</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OffNovelBook</span><span class="hljs-params">(String _name,<span class="hljs-type">int</span> _price,String _author)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_name,_price,_author);<br>    &#125;<br>    <span class="hljs-comment">//覆写销售价格</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//原价</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">selfPrice</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.getPrice();<br>        <span class="hljs-type">int</span> offPrice=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(selfPrice&gt;<span class="hljs-number">4000</span>)&#123; <span class="hljs-comment">//原价大于40元，则打9折</span><br>            offPrice = selfPrice * <span class="hljs-number">90</span> /<span class="hljs-number">100</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            offPrice = selfPrice * <span class="hljs-number">80</span> /<span class="hljs-number">100</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> offPrice;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很简单，仅仅覆写了getPrice方法，通过扩展完成了新增加的业务。</p>
<p>书店打折销售类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> ArrayList&lt;IBook&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;IBook&gt;();<br>    <span class="hljs-comment">//static静态模块初始化数据，实际项目中一般是由持久层完成</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;天龙八部&quot;</span>,<span class="hljs-number">3200</span>,<span class="hljs-string">&quot;金庸&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;巴黎圣母院&quot;</span>,<span class="hljs-number">5600</span>,<span class="hljs-string">&quot;雨果&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;悲惨世界&quot;</span>,<span class="hljs-number">3500</span>,<span class="hljs-string">&quot;雨果&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;JPM&quot;</span>,<span class="hljs-number">4300</span>,<span class="hljs-string">&quot;兰陵笑笑生&quot;</span>));<br>    &#125;<br>    <span class="hljs-comment">//模拟书店买书</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> NumberFormat.getCurrencyInstance();<br>        formatter.setMaximumFractionDigits(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;-----------书店卖出去的书籍记录如下：-----------&quot;</span>);<br>        <span class="hljs-keyword">for</span>(IBook book:bookList)&#123;<br>            System.out.println(<span class="hljs-string">&quot;书籍名称：&quot;</span> + book.getName()+<span class="hljs-string">&quot;\t书籍作者：&quot;</span> + book.getAuthor()+ <span class="hljs-string">&quot;\t书籍价格：&quot;</span> + formatter.format (book.getPrice()/<span class="hljs-number">100.0</span>)+<span class="hljs-string">&quot;元&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们只修改了粗体部分，其他的部分没有任何改动，运行结果如下所示。</p>
<blockquote>
<p>———————-书店卖出去的书籍记录如下：———————</p>
<p>书籍名称：天龙八部 书籍作者：金庸 书籍价格：￥25.60元</p>
<p>书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：￥50.40元</p>
<p>书籍名称：悲惨世界 书籍作者：雨果 书籍价格：￥28.00元</p>
<p>书籍名称：JPM 书籍作者：兰陵笑笑生 书籍价格：￥38.70元</p>
</blockquote>
<p>OK，打折销售开发完成了。看到这里，各位可能有想法了：增加了一个OffNoveBook类后，你的业务逻辑还是修改了，你修改了static静态模块区域。这部分确实修改了，该部分属于高层次的模块，是由持久层产生的，在业务规则改变的情况下高层模块必须有部分改变以适应新业务，改变要尽量地少，防止变化风险的扩散。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="category-chain-item">设计模式</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">#设计原则</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>六大设计原则</div>
      <div>https://haktiong.gitee.io/2022/12/15/设计原则/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Haktiong</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年12月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">23种设计模式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="微服务">
                        <span class="hidden-mobile">微服务</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
