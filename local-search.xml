<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Fiddler基础教程</title>
    <link href="/2025/03/05/Fiddler/"/>
    <url>/2025/03/05/Fiddler/</url>
    
    <content type="html"><![CDATA[<p>配置Fiddler教程：<a href="https://blog.csdn.net/2401_84182665/article/details/138395109">https://blog.csdn.net/2401_84182665/article/details/138395109</a></p><h2 id="一、Fiddler简介"><a href="#一、Fiddler简介" class="headerlink" title="一、Fiddler简介"></a>一、Fiddler简介</h2><ul><li>Fiddler是位于客户端和服务器端的HTTP代理</li><li>目前最常用的nttp抓包工具之一</li><li>功能非常强大，是web调试的利器<ul><li>监控浏览器所有的HTTP&#x2F;HTTPS流量查看、分析请求内容细节</li><li>伪造客户端请求和服务器响应</li><li>测试网站的性能</li><li>解密HTTPS的web会话</li><li>全局、局部断点功能</li><li>第三方插件</li></ul></li><li>场景使用场景<ul><li>接口调试、接口测试、线上环境调试、web性能分析</li><li>判断前后端bug、开发环境hosts配置、mock、弱网断网测试</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112041987.png"></p><h2 id="二、Fiddler原理"><a href="#二、Fiddler原理" class="headerlink" title="二、Fiddler原理"></a>二、Fiddler原理</h2><p>启动fiddler时，会设置一个系统代理，代理端口是8888</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112049726.png"></p><p>如何验证？</p><p>打开谷歌浏览器</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112113938.png"></p><p>如果把fiddler关掉，再看代理服务器，就会被关闭</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112215974.png"></p><p>这就是为什么fiddler可以抓到浏览器的包</p><h2 id="三、HTTP协议"><a href="#三、HTTP协议" class="headerlink" title="三、HTTP协议"></a>三、HTTP协议</h2><ul><li>Hyper Text Transfer Protocol(超文本传输协议)</li><li>用于从万维网服务器传输超文本（资源）到本地浏览器的传送协议</li><li>HTTP协议是基于TCP的应用层（高层协议）协议，它不关心数据传输的细节，主要是用来规定客户端和服务端的数据传输格式，最初是用来向客户端传输HTML页面的内容。默认端口是80</li><li>http是基于请求与响应模式的、无状态的、应用层的协议</li></ul><p>请求百度，并将资源保存为txt</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112221584.png"></p><p><img src="E:\markdown图片\Fiddler\image-20250225165634373.png" alt="image-20250225165634373"></p><h3 id="3-1-HTTP请求报文"><a href="#3-1-HTTP请求报文" class="headerlink" title="3.1 HTTP请求报文"></a>3.1 HTTP请求报文</h3><p>HTTP请求报文主要由请求行、请求头部、空一行、请求正文4部分组成</p><p>前面三个是一定有的，但是请求正文不一定会有。</p><p><strong>请求报文：</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112226104.png"></p><h4 id="请求方法（Request-Method）"><a href="#请求方法（Request-Method）" class="headerlink" title="请求方法（Request Method）"></a>请求方法（Request Method）</h4><table><thead><tr><th>请求方法</th><th>备注</th></tr></thead><tbody><tr><td>GET</td><td>请求资源</td></tr><tr><td>POST</td><td>提交资源</td></tr><tr><td>Head</td><td>获取响应头</td></tr><tr><td>PUT</td><td>替换资源</td></tr><tr><td>DELETE</td><td>删除资源</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，用于测试或诊断</td></tr></tbody></table><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><ul><li>Uniform Resource Locator：统一资源定位符<ul><li>用于描述网上的资源</li></ul></li><li>格式：schema:&#x2F;&#x2F;host[:port#]&#x2F;path&#x2F;…&#x2F;[?query-string]<ul><li>scheme：协议，如http，https，ftp等</li><li>host：域名或者IP地址</li><li>port：端口</li><li>path：资源路径</li></ul></li><li>query-string：发送的参数<ul><li>如：<a href="https://www.baidu.com/s?wd=%E6%9F%A0%E6%AA%AC%E7%8F%AD">https://www.baidu.com/s?wd=柠檬班</a></li></ul></li></ul><h4 id="请求头（Request-Header）"><a href="#请求头（Request-Header）" class="headerlink" title="请求头（Request Header）"></a>请求头（Request Header）</h4><table><thead><tr><th>请求头</th><th>描述</th></tr></thead><tbody><tr><td>Host</td><td>主机IP地址或域名</td></tr><tr><td>User-Agent</td><td>客户端相关信息，如操作系统、浏览器等信息</td></tr><tr><td>Accept</td><td>指定客户端接收信息类型，如<code>image/jpg</code>、<code>text/html</code>、<code>application/json</code></td></tr><tr><td>Accept-Charset</td><td>客户端接受的字符集，如<code>gb2312</code>、<code>iso-8859-1</code></td></tr><tr><td>Accept-Encoding</td><td>可接受的内容编码，如<code>gzip</code></td></tr><tr><td>Accept-Language</td><td>接受的语言，如<code>Accept-Language:zh-cn</code></td></tr><tr><td>Authorization</td><td>客户端提供给服务端，进行权限认证的信息</td></tr><tr><td>Cookie</td><td>携带的Cookie信息</td></tr><tr><td>Referer</td><td>当前文档的URL，即从哪个链接过来的</td></tr><tr><td>Content-Type</td><td>请求体内容类型，如<code>Content-Type:application/x-www-form-urlencoded</code></td></tr><tr><td>Content-Length</td><td>数据长度</td></tr><tr><td>Cache-Control</td><td>缓存机制，如<code>Cache-Control:no-cache</code></td></tr><tr><td>Pragma</td><td>防止页面被缓存，和<code>Cache-Control:no-cache</code>作用一样</td></tr></tbody></table><h3 id="3-2-HTTP响应报文"><a href="#3-2-HTTP响应报文" class="headerlink" title="3.2 HTTP响应报文"></a>3.2 HTTP响应报文</h3><p>HTTP响应报文主要由状态行、消息报头、空一行、响应正文4部分组成</p><p><strong>响应报文：</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112231897.png"></p><h4 id="状态码-Status-Code"><a href="#状态码-Status-Code" class="headerlink" title="状态码(Status Code)"></a>状态码(Status Code)</h4><p>用以表示网页服务器http响应状态的3位数字代码</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>提示信息，请求被成功接收</td></tr><tr><td>2xx</td><td>成功，请求被成功处理 200</td></tr><tr><td>3xx</td><td>重定向相关 304</td></tr><tr><td>4xx</td><td>客户端错误 404</td></tr><tr><td>5xx</td><td>服务器端错误 500</td></tr></tbody></table><h4 id="响应头-Response-Header"><a href="#响应头-Response-Header" class="headerlink" title="响应头(Response Header)"></a>响应头(Response Header)</h4><table><thead><tr><th>响应头</th><th>描述</th></tr></thead><tbody><tr><td>Server</td><td>HTTP服务器的软件信息</td></tr><tr><td>Date</td><td>响应报文的时间</td></tr><tr><td>Expires</td><td>指定缓存过期时间</td></tr><tr><td>Set-Cookie</td><td>设置Cookie</td></tr><tr><td>Last-Modified</td><td>资源最后修改时间</td></tr><tr><td>Content-Type</td><td>响应的类型和字符集，如<code>Content-Type:text/html;charset=utf-8</code></td></tr><tr><td>Content-Length</td><td>内容长度</td></tr><tr><td>Connection</td><td>如<code>Keep-Alive</code>，表示保持TCP连接不关闭，不会永久保持连接，服务器可设置</td></tr><tr><td>Location</td><td>指明重定向的位置，新的URL地址，如304的情况</td></tr></tbody></table><h2 id="四、FIddler工具栏"><a href="#四、FIddler工具栏" class="headerlink" title="四、FIddler工具栏"></a>四、FIddler工具栏</h2><h3 id="添加备注"><a href="#添加备注" class="headerlink" title="添加备注"></a>添加备注</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112236179.png"></p><h3 id="重放（快捷键R）"><a href="#重放（快捷键R）" class="headerlink" title="重放（快捷键R）"></a>重放（快捷键R）</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112239260.png"></p><p>重放多次，按住shift+r，可以设置重放的次数</p><h3 id="删除（可根据条件删除）"><a href="#删除（可根据条件删除）" class="headerlink" title="删除（可根据条件删除）"></a>删除（可根据条件删除）</h3><p>快捷键：ctrl+x</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112243199.png"></p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>对所有请求做解码</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112246492.png"></p><h3 id="保存会话的数量"><a href="#保存会话的数量" class="headerlink" title="保存会话的数量"></a>保存会话的数量</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112249111.png"></p><h3 id="选择要监听的程序"><a href="#选择要监听的程序" class="headerlink" title="选择要监听的程序"></a>选择要监听的程序</h3><p>按住拖动到应用上</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112252081.png"></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>快捷键：ctrl+f</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112254627.png"></p><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>保存所有的会话保存为saz后缀的文件</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112257975.png"></p><h3 id="快捷打开浏览器"><a href="#快捷打开浏览器" class="headerlink" title="快捷打开浏览器"></a>快捷打开浏览器</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112300510.png"></p><h3 id="清除浏览器缓存"><a href="#清除浏览器缓存" class="headerlink" title="清除浏览器缓存"></a>清除浏览器缓存</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112303391.png"></p><h3 id="编码解码工具"><a href="#编码解码工具" class="headerlink" title="编码解码工具"></a>编码解码工具</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112306625.png"></p><h3 id="本机信息"><a href="#本机信息" class="headerlink" title="本机信息"></a>本机信息</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112309470.png"></p><h2 id="五、会话列表"><a href="#五、会话列表" class="headerlink" title="五、会话列表"></a>五、会话列表</h2><h3 id="Session-List-会话列表"><a href="#Session-List-会话列表" class="headerlink" title="Session List(会话列表)"></a>Session List(会话列表)</h3><ul><li>Fiddler抓取到的每条http请求(每一条称为一个session)</li><li>主要包含了请求的ID编号、状态码、协议、主机名、URL、内容类型、body大小、进程信息、自定义备注等信息</li></ul><ol><li>【#】HTTP Request的顺序从 1开始，技照页面加载请求的顺序递增</li><li>【Result】HTTP 响应的状态，可以参考这里。</li><li>【Protocol】读求使用的协议(如 HTTP&#x2F;HTTPS&#x2F;FTP)</li><li>【Host】请求地址的城名</li><li>【URL】请求的服务器路径和文件名，也包括 GET @数</li><li>【BODY】读求的大小，以 byte 为单位</li><li>【Caching】请末的续存过期时间或缓存控制 header 等值</li><li>【Content-Type】请求响应的类型(Content-Type)</li><li>【Process】发出此清求的 Windows 进程及进程 ID</li><li>【Comments】用户通过脚本或者右健菜单给此 session 增加的备注</li><li>【Custom】用户可以通过脚本设置的自定义值</li></ol><h2 id="六、命令行"><a href="#六、命令行" class="headerlink" title="六、命令行"></a>六、命令行</h2><h3 id="QUICK-EXEC"><a href="#QUICK-EXEC" class="headerlink" title="QUICK EXEC"></a>QUICK EXEC</h3><p>可输入HELP，查看所有命令。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112314836.png"></p><h3 id="切换是否作为系统代理"><a href="#切换是否作为系统代理" class="headerlink" title="切换是否作为系统代理"></a>切换是否作为系统代理</h3><p>点击之后，fiddler就不作为系统代理了</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112318011.png"></p><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>点击一次是请求前断点</p><p>点击两次是响应后断点：返回后还没有发给客户端</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112321594.png"></p><h3 id="会话数量"><a href="#会话数量" class="headerlink" title="会话数量"></a>会话数量</h3><p>会话数量以及选择了几个</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112324741.png"></p><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112328636.png"></p><h2 id="七、辅助工具"><a href="#七、辅助工具" class="headerlink" title="七、辅助工具"></a>七、辅助工具</h2><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>HTTP请求的性能和其他数据分析，如DNS解析的时间，建立TCP&#x2F;IP连接的时间消耗等信息</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112331372.png"></p><h3 id="检查器"><a href="#检查器" class="headerlink" title="检查器"></a>检查器</h3><p>用非常多的形式，展示请求报文和响应报文</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112334828.png"></p><h3 id="AutoResponder（自动响应器）（重要）"><a href="#AutoResponder（自动响应器）（重要）" class="headerlink" title="* AutoResponder（自动响应器）（重要）"></a>* AutoResponder（自动响应器）（重要）</h3><p>AutoResponder可用于拦截某一请求，进行如下操作:</p><ul><li><p>重定向到本地的资源</p></li><li><p>使用Fiddler的内置响应</p></li><li><p>自定义响应</p></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112338330.png"></p><p>比如想更换网页上的这张图片，右键复制这张图片的地址</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112340970.png"></p><p>给它来一个内置的404响应</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112343918.png"></p><p>再次请求页面，发现图片被拦截</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112347211.png"></p><p>除了内置的响应，可以自定义文件来替换，让响应不从服务器回来，而是从本地返回</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112350168.png"></p><p>选择好文件，点击save，图片被更换</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112352816.png"></p><p><strong>除此之外，还可以替换js文件等，这对生产环境的调试很有帮助！</strong></p><h4 id="应用场景（测试接口）："><a href="#应用场景（测试接口）：" class="headerlink" title="应用场景（测试接口）："></a>应用场景（测试接口）：</h4><p>拖动左侧响应到右侧来</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112356861.png"></p><p>右键，编辑响应</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112359911.png"></p><p>更改返回体内容，点击save</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112402437.png"></p><p>可以进行极端测试，比如测试响应体什么都不填的时候，前端页面时什么样子的</p><p><strong>PS：使用其他功能时，记得关闭该选项 enable</strong></p><h3 id="Composer（设计者）"><a href="#Composer（设计者）" class="headerlink" title="Composer（设计者）"></a>Composer（设计者）</h3><p>可以模拟请求，点击Execute</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112405452.png"></p><p>也可以拖动左侧的请求过来，它会把这些参数（请求头和请求体等）都放到composer中，以便做一些接口测试。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112408139.png"></p><p><strong>可以验证一些后端的数据格式的校验，以防用户绕过前端而通过后端的请求</strong></p><p><strong>也可以抓到很多请求拖动过来，进行重放（可以批量拖动），连点三下，可以选择一部分请求进行execute</strong></p><h3 id="Filters（过滤器）"><a href="#Filters（过滤器）" class="headerlink" title="Filters（过滤器）"></a>Filters（过滤器）</h3><p>点击对号，开启过滤</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112411592.png"></p><p><strong>PS：使用其他功能时，记得关闭该选项</strong></p><h4 id="只展示局域网的请求或网络上的请求"><a href="#只展示局域网的请求或网络上的请求" class="headerlink" title="只展示局域网的请求或网络上的请求"></a>只展示局域网的请求或网络上的请求</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112414687.png"></p><h4 id="只展示某主机下的请求"><a href="#只展示某主机下的请求" class="headerlink" title="只展示某主机下的请求"></a>只展示某主机下的请求</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112418120.png"></p><h4 id="只展示某个进程下的请求"><a href="#只展示某个进程下的请求" class="headerlink" title="只展示某个进程下的请求"></a>只展示某个进程下的请求</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112421209.png"></p><h4 id="只展示-x2F-隐藏url包含了什么"><a href="#只展示-x2F-隐藏url包含了什么" class="headerlink" title="只展示&#x2F;隐藏url包含了什么"></a>只展示&#x2F;隐藏url包含了什么</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112426528.png"></p><h4 id="只展示-x2F-隐藏header包含了什么"><a href="#只展示-x2F-隐藏header包含了什么" class="headerlink" title="只展示&#x2F;隐藏header包含了什么"></a>只展示&#x2F;隐藏header包含了什么</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112429314.png"></p><h4 id="删除所有的请求的某个header"><a href="#删除所有的请求的某个header" class="headerlink" title="删除所有的请求的某个header"></a>删除所有的请求的某个header</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112431900.png"></p><h4 id="给所有的请求设置header"><a href="#给所有的请求设置header" class="headerlink" title="给所有的请求设置header"></a>给所有的请求设置header</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112434572.png"></p><h4 id="为某个条件设置断点"><a href="#为某个条件设置断点" class="headerlink" title="为某个条件设置断点"></a>为某个条件设置断点</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112439759.png"></p><h4 id="过滤某个响应状态码的请求"><a href="#过滤某个响应状态码的请求" class="headerlink" title="过滤某个响应状态码的请求"></a>过滤某个响应状态码的请求</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112442278.png"></p><h4 id="过滤某个响应类型或响应内容大小的请求"><a href="#过滤某个响应类型或响应内容大小的请求" class="headerlink" title="过滤某个响应类型或响应内容大小的请求"></a>过滤某个响应类型或响应内容大小的请求</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112444706.png"></p><h4 id="阻塞js、css、image等请求"><a href="#阻塞js、css、image等请求" class="headerlink" title="阻塞js、css、image等请求"></a>阻塞js、css、image等请求</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112447111.png"></p><h4 id="过滤或设置响应"><a href="#过滤或设置响应" class="headerlink" title="过滤或设置响应"></a>过滤或设置响应</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112449511.png"></p><h2 id="八、断点"><a href="#八、断点" class="headerlink" title="八、断点"></a>八、断点</h2><h3 id="全局断点"><a href="#全局断点" class="headerlink" title="全局断点"></a>全局断点</h3><p>设置全局的请求前断点，或响应后断点</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112452009.png"></p><p>或者点击命令行下方空白处设置断点</p><p>请求前断点：可以在发送请求前进行数据篡改（头部信息等）</p><p>响应后断点：得到响应后可以修改返回体</p><p>（可以让返回数据完全没有，进行一些极端测试）</p><p>（也可以模拟网络中断，响应体被fiddler拦截，客户端迟迟收不到响应，看会做出什么响应）</p><h3 id="局部断点"><a href="#局部断点" class="headerlink" title="局部断点"></a>局部断点</h3><p><strong>一般情况下，使用局部断点，而不用全局断点，全局断点会拦截所有请求</strong></p><ol><li><p>在命令行使用局部断点（请求前断点）</p><p>bpu 内容</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112454882.png"></p><p>再次输入bpu，取消断点</p></li><li><p>在命令行使用局部断点（响应后断点）</p><p>bpafter 内容</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112457630.png"></p><p>再次输入bpu，取消断点</p></li></ol><h2 id="九、弱网测试"><a href="#九、弱网测试" class="headerlink" title="九、弱网测试"></a>九、弱网测试</h2><p>勾选，模拟网络限速</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112459842.png"></p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>点击按钮</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112502227.png"></p><p>搜索simulate，代码中每请求1KB延迟了300ms，每响应1KB延迟150ms</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112507084.png"></p><p>可以根据需求设置弱网程度</p><h2 id="十、HTTPS和APP抓包"><a href="#十、HTTPS和APP抓包" class="headerlink" title="十、HTTPS和APP抓包"></a>十、HTTPS和APP抓包</h2><ul><li>点击Tools &gt;Options &gt;HTTPS</li><li>勾选Decrypt HTTPs Traffic</li></ul><p>设置好之后，即可抓取https请求</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112509824.png"></p><p>如果开启之后还是抓不到，重置删除所有证书</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112512309.png"></p><p>弹出安装证书选项，安装证书。</p><p>判断是否安装成功，打开windows证书管理器</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112515218.png"></p><p>查找证书</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112517505.png"></p><p>搜索fiddler</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/20250304112519791.png"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fiddler</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GeoServer基础教程</title>
    <link href="/2024/12/09/GeoServer%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <url>/2024/12/09/GeoServer%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="GeoServer基础教程"><a href="#GeoServer基础教程" class="headerlink" title="GeoServer基础教程"></a>GeoServer基础教程</h1><h2 id="一、GeoServer介绍及安装"><a href="#一、GeoServer介绍及安装" class="headerlink" title="一、GeoServer介绍及安装"></a>一、GeoServer介绍及安装</h2><p>GeoServer是一个用Java编写的开源软件服务器，允许用户共享和编辑地理空间数据。它为互操作性而设计，使用开放标准发布来自任何主要空问数据源的数据。</p><p>官网：<a href="https://geoserver.org/">https://geoserver.org/</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>作为一个社区驱动的项目，GeoServer由来自世界各地的不同个人和组织开发、测试和支持。</p><p>GeoServer实现了行业标准的OGC协议，如Web要素服务(WFS)、Web地图服务(WMS)和Web覆盖服务(WCS)。其他格式和发布选项作为扩展提供，包括Web处理服务(WPS)和Web地图瓦片服务(WMTS)</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412032344487.png"></p><p>GeoServer作为一款优秀的开源GIS服务器，在开源方案越来越流行的今天成为企事业单位从事GIS相关项目活动必须考虑的一个选择。</p><p>相较于商业GIS软件如ArcGIS Server、SuperMap iServer等地图服务器软件，GeoServer能实现绝大多数场景下项目对GIS功能的要求，而且有活跃的社区支持，在实际生产中也越来越受到决策者和开发者的青睐。</p><p>最重要的可能是它的开源性质了，任何个人和单位都可以免费下载使用它。这恐怕是他相较于商业软件受欢迎的重要因素了。作为GIS开发人员，能够使用GeoServer进行开源GIS项目的研发，也成为一名合格GIS从业者的基本要求。GeoServer作为一款优秀的开源GIS服务器软件，也成为GIS初学者了解开源GIS方案最佳的实践方案。</p><h3 id="GeoServer的诞生历史"><a href="#GeoServer的诞生历史" class="headerlink" title="GeoServer的诞生历史"></a>GeoServer的诞生历史</h3><p>GeoServer于2001年由总部位于纽约的非盈利技术孵化器open planning project(TOPP)启动。TOPP正在创建一套工具，以实现开放民主，并帮助政府更加透明。第一个是GeoServer，这是因为人们认识到，共享空问数据的能力将(成为)大大增强公民参与政府和城市规划的一套。</p><p>GeoServer的创始人设想了一个类似于万维网的地理空间网。通过万维网，人们可以搜索和下载文本。通过地理空问网，人们可以搜索和下载空问数据。数据提供者将能够直接将他们的数据发布到这个网站上，用户可以直接访问它，而不是现在存在的问接和繁琐的数据共享方法。</p><p>GeoServer的相关人员创建了GeoTools项目，这是一个开源的GIS Java工具包。通过GeoTools，增加了对shapefile、Oracle数据库、ArcSDE集成等的支持。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412032347381.png"></p><p>大约在GeoServer成立的同时，OpenGIS联合会(现在的open geospatial联合会)正在开发Web要素服务标准。它使用GML(地理标记语言)，一种互操作的数据格式，指定了一种协议，使空问数据直接在web上可用。还创建了一个Web地图服务，一个用于创建和显示从空问数据创建的地图图像的协议。</p><p>其他项目变得相互关联。Refractions Research创建了一个免费开放的空问数据库PostGIS，使GeoServer能够连接到一个免费的数据库。另外，MetaCarta最初创建了OpenLayers,一个基于开源浏览器的地图查看工具。这些工具一起增强了GeoServer的功能。</p><p>这使得使用开源技术路线构建GIS工作流成为可能，数据可以从PostGIS流入GeoServer、再应用OpenLayers将GeoServer发布的地图服务在前端进行展现和互操作。</p><p>GeoServer现在可以从十几个空间数据源读取数据，并以多种不同的格式输出。现在已经是第二个十年了，GeoServer正在继续它的使命，让所有人都能更容易地访问空问数据。</p><h3 id="Geoserver在不同平台上的安装"><a href="#Geoserver在不同平台上的安装" class="headerlink" title="Geoserver在不同平台上的安装"></a>Geoserver在不同平台上的安装</h3><p>GeoServer可以安装在不同的操作系统平台上:</p><ul><li>Windows</li><li>Mac OS</li><li>Linux</li></ul><p>同时，GeoServer也有两种安装方式：</p><ul><li><p>二进制文件安装</p></li><li><p>web 存档文件安装(webarchive)即war包安装。</p></li></ul><p>需要注意的是，不同于桌面软件.exe形式的安装，GeoServer只需要下载后在安装目录中执行&#x2F;bin&#x2F;startup.bat或&#x2F;bin&#x2F;startup.sh命令即可。</p><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><p>在讲下一节GeoServer两种安装方式之前，请确保你的操作系统已经安装了JAVA环境:</p><p>确保您的系统上安装了Java运行时环境(JRE)。GeoServer需要java8或java11环境，正如open jdk windows安装程序所提供的那样。</p><p>选择版本下载：<a href="https://sourceforge.net/projects/geoserver/files/GeoServer/">https://sourceforge.net/projects/geoserver/files/GeoServer/</a></p><ul><li><strong>tomcat11</strong>必须保证<strong>jdk11</strong>，否则启动会报错</li><li>如果我们使用Java8环境，那么GeoServer的适配版本在2.9.x到2.22.x之间。关于这一点一定要注意，理论上总是说可以向下兼容，但进行实践的时候似乎总是很难做到。</li><li>亲测：geoserver选择<strong>2.22.5</strong>，tomcat使用<strong>8.0.50</strong>，可以使用<strong>jdk8</strong>，其他版本未知</li></ul><ol><li>二进制文件下载:(与平台无关，下载即可)</li></ol><p><a href="http://geoserver.org/release/stable/">http://geoserver.org/release/stable/</a></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412032351569.png"></p><p>进入安装目录，在bin目录下找到startup.bat，启动GeoServer程序。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412040054745.png"></p><p>访问：<a href="http://localhost:8080/geoserver">http://localhost:8080/geoserver</a></p><ol start="2"><li>web 存档文件(war包)下载:(与平台无关，下载即可)</li></ol><p><a href="http://geoserver.org/release/stable/">http://geoserver.org/release/stable/</a></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412032357322.png"></p><p>解压后将war包放在tomcat安装目录webapps下，重新启动tomcat。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412040016947.png"></p><p>访问：<a href="http://localhost:8080/geoserver">http://localhost:8080/geoserver</a></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412040052938.png"></p><hr><p>GeoServer在不同的操作系统上安装并运行我们可以理解，下面我们主要讨论GeoServer的两种安装方式:</p><p>二进制文件安装在Windows上安装GeoServer的一种方法是使用与平台无关的二进制文件。这个版本是捆绑在Jetty中的GeoServer web应用程序，Jetty是一个轻量级和可移植的应用服务器。它具有在所有操作系统中工作非常相似的优点，并且设置起来非常简单。(可以将jetty理解为tomcat，此处即为内嵌了GeoServerweb应用程序的tomcat)</p><p>web 存档文件安装(web archive)即war包安装。GeoServer应用程序被打包为独立servlet，用于现有应用程序服务器，如ApacheTomcat和Jetty。这里是将GeoServer作为现有servlet容器(如Tomcat)的一部分运行。</p><p>另外一种常用的部署是将GeoServer部署在Linux平台上，这也是我平时常用的部署方式其方式方法和在Windows上部署类似，不同之处是你需要部署Liunx版本(tar.gz)的tomcat,且执行的命令是 &#x2F;sh startup.sh</p><h2 id="二、GeoServer-Web管理界面"><a href="#二、GeoServer-Web管理界面" class="headerlink" title="二、GeoServer Web管理界面"></a>二、GeoServer Web管理界面</h2><h3 id="GeoServer首次登录"><a href="#GeoServer首次登录" class="headerlink" title="GeoServer首次登录"></a>GeoServer首次登录</h3><p>GeoServer有一个基于浏览器的web管理界面应用程序，用于配置GeoServer的所有方面，从添加和发布数据到更改服务设置。</p><ul><li>可通过web浏览器访问web管理界面</li></ul><p>网址为:http:&#x2F;&#x2F;<host>:<port>&#x2F;geoserver</p><ul><li>如果是默认安装</li></ul><p>则访问地址为:<a href="http://localhost:8080/geoserver">http://localhost:8080/geoserver</a></p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>要更改任何服务器设置或配置数据，必须首先对用户进行身份验证。导航到web界面的右上角以登录到GeoServer。默认管理凭据为:</p><p>User name: admin</p><p>Password: geoserver</p><p>很多新手或者长时间不用GeoServer的人会不清楚或忘记默认用户名和密码，一定要牢记。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412040935910.png"></p><h2 id="三、使用GeoServer发布shapefile文件"><a href="#三、使用GeoServer发布shapefile文件" class="headerlink" title="三、使用GeoServer发布shapefile文件"></a>三、使用GeoServer发布shapefile文件</h2><p>实验数据下载地址：<br><a href="https://docs.geoserver.org/stable/en/user/_downloads/30e405b790e068c43354367cb08e71bc/nyc_roads.zip">https://docs.geoserver.org/stable/en/user/_downloads/30e405b790e068c43354367cb08e71bc/nyc_roads.zip</a></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041023777.png"></p><p>shapefile实际上是文件的集合(扩展名:.shp、.dbf、.shx、.pj，有时还有其他文件)。所有这些文件都需要存在于同一目录中，以便GeoServer能够准确读取它们。</p><p>在使用GeoServer时，强烈建议使用.prj文件(虽然不是必需的)，因为它包含有价值的投影信息。如果没有它，GeoServer可能无法加载shapefile。</p><ol><li>创建一个工作区</li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041026098.png"></p><ol start="2"><li>创建新的数据存储</li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041028164.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041031419.png"></p><ol start="3"><li>新建一个图层</li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041036827.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041040604.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041041378.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041042802.png"></p><ol start="4"><li>查看图层</li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041043168.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041045239.png"></p><h2 id="四、使用GeoServer发布GeoTIFF影像"><a href="#四、使用GeoServer发布GeoTIFF影像" class="headerlink" title="四、使用GeoServer发布GeoTIFF影像"></a>四、使用GeoServer发布GeoTIFF影像</h2><h3 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h3><p>TIFF (Tag Image File Format)图像文件是图形图像处理中常用的格式之一,其图像格式很复杂,但由于它对图像信息的存放灵活多变,可以支持很多色彩系统,而且独立于操作系统.</p><p>因此得到了广泛应用。在各种地理信息系统、摄影测量与遥感等应用中,要求图像具有地理编码信息,例如图像所在的坐标系、比例尺、图像上点的坐标、经纬度、长度单位及角度单位等等。对于存储和读取这些信息,纯TEF 格式的图像文件是很难做到的,而GeOTIFF 作为TIFF 的一种扩展,在TIFF 的基础上定义了一些GeoTag(地理标签),来对各种坐标系统、椭球基准、投影信息等进行定义和存储,使图像数据和地理数据存储在同一图像文件中,这样就为广大用户制作和使用带有地理信息的图像提供了方便的途径。</p><hr><p>步骤同上</p><ol><li>添加新的数据存储-GeoTIFF</li><li>发布图层</li></ol><h2 id="五、安装postgreSQL和postgis"><a href="#五、安装postgreSQL和postgis" class="headerlink" title="五、安装postgreSQL和postgis"></a>五、安装postgreSQL和postgis</h2><blockquote><p>安装时，须保证pgsql和postgis版本对应，我这里选择的是</p><p>pgsql：13.18.1</p><p>postgis：pg13x64-3.5.0-1</p><p>而且postgis必须安装在postgreSQL文件夹下，不能安装在pgsql文件夹下的任何子文件夹内，否则会报错。</p><p>如果pgsql的版本大于等于15，navicat是打不开的。</p></blockquote><p><strong>安装postgreSQL</strong>：<a href="https://www.postgresql.org/">https://www.postgresql.org/</a></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041515423.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041517235.png"></p><p>测试服务是否已经启动</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041526193.png"></p><p>随着pgSQL安装会自动安装一个manager管理软件</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041527947.png"></p><p>本地的pgSQL</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041529598.png"></p><hr><p><strong>安装postgis插件</strong></p><p><a href="https://download.osgeo.org/postgis/windows/">https://download.osgeo.org/postgis/windows/</a></p><p>勾选创建一个空间数据库</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041652394.png"></p><p>postgis库和普通的库区别就在于，在扩展里，多了postgis的扩展</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412041739152.png"></p><h2 id="六、使用GeoServer发布Postgis数据表"><a href="#六、使用GeoServer发布Postgis数据表" class="headerlink" title="六、使用GeoServer发布Postgis数据表"></a>六、使用GeoServer发布Postgis数据表</h2><h3 id="1-创建postgis数据库"><a href="#1-创建postgis数据库" class="headerlink" title="1.创建postgis数据库"></a>1.创建postgis数据库</h3><p>打开pgAdmin，先进行汉化</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061624052.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061625432.png"></p><hr><p><strong>在前几章已经创建了postgis数据库，那如何新建一个postgis数据库？</strong></p><ol><li>模板方式</li></ol><p>在数据库上右键 - 创建 -数据库</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061627624.png"></p><p>选择之间创建好的postgis模板的数据库，使用它的模板</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061633534.png"></p><ol start="2"><li>使用命令</li></ol><p>在创建好的空白数据库上 -  右键 - 查询工具</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061634838.png"></p><p>使用下方命令，点击执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> EXTENSION postgis;<br><span class="hljs-keyword">CREATE</span> EXTENSION postgis_topology;<br><span class="hljs-keyword">CREATE</span> EXTENSION postgis_sfcgal;<br><span class="hljs-keyword">CREATE</span> EXTENSION fuzzystrmatch;<br><span class="hljs-keyword">CREATE</span> EXTENSION address_standardizer;<br><span class="hljs-keyword">CREATE</span> EXTENSION address_standardizer_data_us;<br><span class="hljs-keyword">CREATE</span> EXTENSION postgis_tiger_geocoder;<br></code></pre></td></tr></table></figure><p>即可在扩展中看到</p><h3 id="2-下载实验数据"><a href="#2-下载实验数据" class="headerlink" title="2.下载实验数据"></a>2.下载实验数据</h3><blockquote><p>下载地址：<a href="https://docs.geoserver.org/stable/en/user/%20downloads/bbd4b941ceb36074c9d19feab3f57609/nyc%20b%20uildings.zip">https://docs.geoserver.org/stable/en/user/%20downloads/bbd4b941ceb36074c9d19feab3f57609/nyc%20b%20uildings.zip</a></p></blockquote><p>导入数据到pgsql中</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061644427.png"></p><h3 id="3-启动geoserver"><a href="#3-启动geoserver" class="headerlink" title="3.启动geoserver"></a>3.启动geoserver</h3><p>启动geoserver，使用test工作区</p><p>点击【存储仓库】，添加新的数据存储，选择postgis</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061649224.png"></p><p>填写pg数据库的连接参数，其他保持默认：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061654723.png"></p><p>选择nyc_buildings，点击发布</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061653058.png"></p><p>其他保持默认，但需要计算一下边框</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061655054.png"></p><p>点击保存，发布图层</p><p>点击图层预览，搜索nyc，可以预览</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061658353.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412061658461.png"></p><h2 id="七、使用openLayers调用geoserver发布的wms服务"><a href="#七、使用openLayers调用geoserver发布的wms服务" class="headerlink" title="七、使用openLayers调用geoserver发布的wms服务"></a>七、使用openLayers调用geoserver发布的wms服务</h2><blockquote><p>openlayers官网：<a href="https://openlayers.org/">https://openlayers.org/</a></p></blockquote><p>点击QuickStart，复制代码下来</p><p>现在官网已经使用npm方式，没有html静态代码了</p><p>注意：</p><ol><li>实例中本来是用cdn，但现在貌似访问不到了</li><li>请求地图png需要科学上网</li><li>shape样例用的北京市中心的shape，下载网址：<a href="https://gitcode.com/open-source-toolkit/d07f9/blob/main/geoserver%E7%BB%83%E4%B9%A0%E6%95%B0%E6%8D%AE.rar%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%A5%BD%E5%90%8E%E5%8F%91%E5%B8%83%E5%9B%BE%E5%B1%82">https://gitcode.com/open-source-toolkit/d07f9/blob/main/geoserver%E7%BB%83%E4%B9%A0%E6%95%B0%E6%8D%AE.rar，下载好后发布图层</a></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--注意：openlayers 原版的比较慢，这里引起自己服务器版--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://openlayers.vip/examples/css/ol.css&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">       <span class="hljs-comment">/* 注意：这里必须给高度，否则地图初始化之后不显示；一般是计算得到高度，然后才初始化地图 */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.map</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--注意：openlayers 原版的比较慢，这里引起自己服务器版--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://openlayers.vip/examples/resources/ol.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>OpenLayers example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>My Map<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--地图容器，需要指定 id --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> ol.<span class="hljs-title class_">Map</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 地图容器</span></span><br><span class="language-javascript">        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;map&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-comment">// 地图图层，比如底图、矢量图等</span></span><br><span class="language-javascript">        <span class="hljs-attr">layers</span>: [</span><br><span class="language-javascript">          <span class="hljs-keyword">new</span> ol.<span class="hljs-property">layer</span>.<span class="hljs-title class_">Tile</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 谷歌底图</span></span><br><span class="language-javascript">            <span class="hljs-attr">source</span>: <span class="hljs-keyword">new</span> ol.<span class="hljs-property">source</span>.<span class="hljs-title function_">OSM</span>()</span><br><span class="language-javascript">          &#125;)</span><br><span class="language-javascript">        ],</span><br><span class="language-javascript">        <span class="hljs-comment">// 地图视野</span></span><br><span class="language-javascript">        <span class="hljs-attr">view</span>: <span class="hljs-keyword">new</span> ol.<span class="hljs-title class_">View</span>(&#123;</span><br><span class="language-javascript">          <span class="hljs-comment">// 定位</span></span><br><span class="language-javascript">          <span class="hljs-attr">center</span>: ol.<span class="hljs-property">proj</span>.<span class="hljs-title function_">fromLonLat</span>([<span class="hljs-number">37.41</span>, <span class="hljs-number">8.82</span>]),</span><br><span class="language-javascript">          <span class="hljs-comment">// 缩放</span></span><br><span class="language-javascript">          <span class="hljs-attr">zoom</span>: <span class="hljs-number">4</span></span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建一个html，把上述代码粘贴到里面</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412070331342.png"></p><p>在上面的基础上，再添加geoserver WMS资源，添加到ol.Map中的layers下和 ol.layer.Tile同级</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> ol.<span class="hljs-property">layer</span>.<span class="hljs-title class_">Image</span>(&#123;<br>          <span class="hljs-attr">source</span>: <span class="hljs-keyword">new</span> ol.<span class="hljs-property">source</span>.<span class="hljs-title class_">ImageWMS</span>(&#123;<br>            <span class="hljs-attr">ratio</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:8080/geoserver/test/wms&quot;</span>,<br>            <span class="hljs-attr">crossOrigin</span>: <span class="hljs-string">&#x27;anonymous&#x27;</span>, <span class="hljs-comment">//跨域声明</span><br>            <span class="hljs-attr">params</span>: &#123;<br>              <span class="hljs-string">&#x27;FORMAT&#x27;</span>: <span class="hljs-string">&#x27;image/png&#x27;</span>,<br>              <span class="hljs-string">&quot;VERSION&quot;</span>: <span class="hljs-string">&#x27;1.1.1&#x27;</span>,<br>              <span class="hljs-string">&quot;exceptions&quot;</span>: <span class="hljs-string">&#x27;application/vnd.oge.se_inimage&#x27;</span>,<br>              <span class="hljs-string">&quot;LAYERS&quot;</span>: <span class="hljs-string">&#x27;test:community_price&#x27;</span><br>            &#125;<br>          &#125;)<br>        &#125;)<br></code></pre></td></tr></table></figure><p>url：地图服务的url地址，在F12的请求url中找</p><p>params：在请求参数中都能找到</p><p>接下来找定位：</p><p>在图层预览这里鼠标移动到正中心，查看它的经纬度坐标，填入</p><p><strong>ol.proj.fromLonLat</strong>方法中</p><p><strong>解决tomcat跨域问题：</strong></p><p>tomcat安装目录下 conf - web.xml，589左右</p><p>添加下面代码，重启tomcat：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CorsFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.apache.catalina.filters.CorsFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>cors.allowed.origins<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>cors.allowed.methods<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>GET,POST,HEAD,OPTIONS,PUT<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>cors.allowed.headers<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>cors.exposed.headers<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>Access-Control-Allow-Origin,Access-Control-Allow-Credentials<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>cors.support.credentials<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CorsFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>全部配置好后，打开网页</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412070444909.png"></p><h2 id="八、使用geoserver生产wmts瓦片"><a href="#八、使用geoserver生产wmts瓦片" class="headerlink" title="八、使用geoserver生产wmts瓦片"></a>八、使用geoserver生产wmts瓦片</h2><p>确定要生成瓦片这两个选项打勾</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082314716.png"></p><p>生成过的图层在下方都会生成瓦片服务</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082320791.png"></p><p>点击按钮生成瓦片，（后面的是清空瓦片的意思）</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082321253.png"></p><p>create new task就是生成瓦片的任务，它把遥感影响切分成小块任务，当你在浏览器访问时，访问对应的瓦片回来，不用浏览器实时用wms去渲染，提高它的访问速度，用的是空间和时间的概念。</p><ol><li>Type of operation: 可以选择，生成全部，生成缺失的瓦片，移除瓦片。</li><li>Grid Set:生成瓦片时，用什么坐标系，用什么策略。</li><li>Zoom start + Zoom stop: 起始缩放级别和最终缩放级别</li><li>Modifiable Parameters: 默认即可</li><li>Bounding box: 指定切片范围</li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082322451.png"></p><p>提交之后会给出切片的进程信息，如果再次刷新没有了，就是进程结束了。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082326421.png" alt="image-20241208232641388"></p><hr><p>geoserver生成的瓦片都是默认在内存中</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082332806.png"></p><p>如何让他生成在磁盘上？官网介绍，需要配置web.xml并重启项目</p><blockquote><p>官方文档：<a href="https://docs.geoserver.org/latest/en/user/geowebcache/config.html#changing-the-cache-directory">https://docs.geoserver.org/latest/en/user/geowebcache/config.html#changing-the-cache-directory</a></p></blockquote><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082332071.png"></p><p>先清空掉内存中的瓦片，会提示从磁盘中清空0B的瓦片，也说明瓦片根本没有生成在磁盘上</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082337243.png"></p><p>停止geoserver，在tomcat中的geoserver找到web.xml</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082334060.png"></p><p>配置瓦片输出地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>GEOWEBCACHE_CACHE_DIR<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>C:\Users\yu\Desktop\cache<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再次启动geoserver，重新生成瓦片</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082338957.png"></p><p>查看对应文件夹，已经生成到了对应的文件夹下</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082341565.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082341215.png"></p><hr><p>在网络集下可以以某个为模板，创建新的瓦片策略。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082345485.png"></p><p>制作好后，要在图层 - Tile Caching 中增加瓦片策略</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082350404.png"></p><h2 id="九、WMTS瓦片的迁移使用"><a href="#九、WMTS瓦片的迁移使用" class="headerlink" title="九、WMTS瓦片的迁移使用"></a>九、WMTS瓦片的迁移使用</h2><p>核心思路：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412082352907.png"></p><p>上节课说，如果服务特别大，瓦片特别多，一个节点可能生成不过来，这时候就用其他几个子节点来帮忙。</p><p>比如一共有15个瓦片，让节点1生成1-10，节点2生成11-13，节点3生成14-15</p><ol><li><p><strong>在目标GIS服务器上发布wms服务，不生产瓦片。(或者发布空服务，只是为了构建bbox)</strong></p></li><li><p><strong>在其他GeoServer服务器上创建wms服务，生产wmts瓦片。</strong></p></li><li><p><strong>将所有其他GeoServer服务器上生产的wmts瓦片复制到目标GeoServer服务器对应服务瓦片目录下。</strong></p></li></ol><p>建立四个tomcat服务，server是负责对外提供服务，node负责生成瓦片</p><p>四个tomcat服务，需要更改tomcat端口以及其他端口，geoserver中需要更改缓存生成的位置，依次启动服务</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412090009844.png"></p><p>在node1中生成0-10层的瓦片，node2生成11-13，node3生成14-15</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412090009460.png"></p><p>为什么要生成空服务server，就是为了让它自动确定边界，边框正确，容器范围足够大，才能正常展示。</p><p>复制其他节点cache文件夹下的所有瓦片，到server的cache文件夹下的瓦片目录下。</p><hr><h2 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h2><p><a href="https://www.bilibili.com/video/BV1co4y1C7NJ/">GeoServer中文版软件使用教程</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
      <category>GIS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>geoserver</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArcGIS入门</title>
    <link href="/2024/12/01/ArcGis%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2024/12/01/ArcGis%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ArcGIS入门教程"><a href="#ArcGIS入门教程" class="headerlink" title="ArcGIS入门教程"></a>ArcGIS入门教程</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>ArcGis是一款地理信息系统软件，它用于创建、管理、分析和分享地图空间数据，支持地图制作，空间可视化，空间分析以及遥感处理，并且广泛应用于城市规划、环境保护、交通管理等领域。</p><h2 id="二、软件下载及安装"><a href="#二、软件下载及安装" class="headerlink" title="二、软件下载及安装"></a>二、软件下载及安装</h2><p>这里以10.8举例，解压安装包</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260151916.png" alt="image-20241126015107845"></p><p>双击ArcGIS_Desktop_1081.exe进行常规安装</p><p>使用Crack中的AfCore.dll文件替换安装路径下的bin目录下的同名文件完成破解。</p><p>双击DesktopChinese_CN.msi，进行安装汉化。</p><h3 id="软件分类"><a href="#软件分类" class="headerlink" title="软件分类"></a>软件分类</h3><p>安装好之后你会获得4个客户端：ArcCatalog、ArcGlobe、ArcMap、ArcScene</p><p>平时用的最多的就是ArcMap</p><p>三维的就是ArcScene</p><p>ArcGlobe比较类似于图形地球，把所有的图层都投影到这个球上</p><p>ArcCatalog，可以管理文件夹连接，工具箱，应用程序等</p><p>在搜索栏中搜索ArcMap，打开软件。</p><h2 id="三、熟悉软件操作页面"><a href="#三、熟悉软件操作页面" class="headerlink" title="三、熟悉软件操作页面"></a>三、熟悉软件操作页面</h2><p>【文件】-【新建】打开的是mxt类型的文档</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260154006.png" alt="image-20241126015419940"></p><p>这时候我们可以创建一个空白地图，下方的gdb就是我们在安装软件的时候设置的一个数据库。</p><h3 id="3-1-功能区"><a href="#3-1-功能区" class="headerlink" title="3.1 功能区"></a>3.1 功能区</h3><p>上方是功能区，在上方右键可以把常用的功能放出来；</p><p>左侧是内容列表，它可以展示我们放在当前这个地图文档的所有图层；</p><p>右面是目录和搜索，可以固定在右侧，可以用文件夹连接的方式连接到我们电脑的文件。</p><h3 id="3-2-基本设置"><a href="#3-2-基本设置" class="headerlink" title="3.2 基本设置"></a>3.2 基本设置</h3><p>点击上方【自定义】-【ArcMap选项】，把滚轮设置为惯用方式</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260249468.png" alt="image-20241126024943430"></p><p>点击上方【文件】-【地图文档属性】，将存储数据源的相对路径名打上对号，这个时候只要地图文档和数据源的相对路径没有改变，就不会有找不到数据源的情况了。</p><h3 id="3-3-视图"><a href="#3-3-视图" class="headerlink" title="3.3 视图"></a>3.3 视图</h3><p>中间区域是视图区域，下方可以选择数据视图和布局视图</p><p>把数据拖进来的时候，在数据视图里面可以进行编辑等操作，如果想要出图的时候，会放到布局视图里面。</p><ol><li><p>在页面和打印设置中，可以设置横向和纵向；</p></li><li><p>设置比例尺，图片整体会放大；</p></li><li><p>鼠标选中选择元素光标的话，就可以对数据框进行拖动；</p></li><li><p>数据框不想变的话，选择上方平移；</p></li></ol><h2 id="四、ArcGIS中的文件类型"><a href="#四、ArcGIS中的文件类型" class="headerlink" title="四、ArcGIS中的文件类型"></a>四、ArcGIS中的文件类型</h2><h3 id="4-1-mxd"><a href="#4-1-mxd" class="headerlink" title="4.1 mxd"></a>4.1 mxd</h3><p>地图文档：存放所有图层，标注，属性，布局等</p><h3 id="4-2-shapefile"><a href="#4-2-shapefile" class="headerlink" title="4.2 shapefile"></a>4.2 shapefile</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260302939.png" alt="image-20241126030206904"></p><p>点线面要素，它包含了很多后缀名</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260302805.png" alt="image-20241126030246765"></p><ol><li><p><strong>shp</strong>：存储空间数据</p></li><li><p><strong>dbf</strong>：存放的是一些属性</p></li><li><p><strong>shx</strong>：存储空间与属性数据关系，相当于索引</p><p>…除了这些还有很多，这些都是shapefile的组成</p></li></ol><p>新建一个点文件，设置一下坐标系：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260305452.png" alt="image-20241126030504425"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260306231.png" alt="image-20241126030626189"></p><h3 id="4-3-栅格（DEM）"><a href="#4-3-栅格（DEM）" class="headerlink" title="4.3 栅格（DEM）"></a>4.3 栅格（DEM）</h3><p>它的后缀名包括：TIFF、esri grid、JPGE等</p><p>我们随便点开一张图片，当把图片放大到一定程度，可以发现它是由一个个方格组成的，就叫栅格，每个方格里就是一个像元，在ArcGIS里每个像元都存储了一些数据；</p><p>比如高程数据就是DEM，等等</p><h3 id="4-4-数据库"><a href="#4-4-数据库" class="headerlink" title="4.4 数据库"></a>4.4 数据库</h3><p><strong>gdb和mdb</strong></p><p>在使用ArcGIS的时候，除了把点线面要输创建为shapefile以外，还可以自己创建一个数据库，</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260310393.png" alt="image-20241126031015364"></p><p>随便创建一个</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260310019.png" alt="image-20241126031051000"></p><p>文件地理数据库就是gdb，个人地理数据库就是mdb，他们使用起来没有太大的区别</p><p>现在在文件数据库中创建点线面要素</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260312579.png" alt="image-20241126031236533"></p><p>创建一个线要素</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260313922.png" alt="image-20241126031316887"></p><p>选择坐标系，一直点下一步即可</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260314746.png" alt="image-20241126031438723"></p><p>数据库和外面创建的shapefile的区别是</p><p>shapefile每一个文件都是单独个体，在数据库中相当于对每个文件进行了管理。</p><p>在移动数据库中文件的时候，只能通过这个数据库来移动</p><p>这是刚刚创建的数据库：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260316287.png" alt="image-20241126031655252"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411260317793.png" alt="image-20241126031711745"></p><p>我们需要拷贝给别人的时候，需要整个数据库都拷贝给别人，虽然没有那么方便，但对整个数据库都进行了统一管理，在编辑要素的时候，可以做到调整一个要素，其他所有要素都会关联的更改。</p><p><strong>总结：</strong></p><ol><li>不管是数据库要素类还是shapefile要素类，都包含了，点、线、面三要素</li><li>一般存放在数据库中的栅格文件都是以esri grid保存的</li></ol><h2 id="五、坐标系"><a href="#五、坐标系" class="headerlink" title="五、坐标系"></a>五、坐标系</h2><p>坐标系分为：地理坐标系、投影坐标系</p><h3 id="5-1-地理坐标系"><a href="#5-1-地理坐标系" class="headerlink" title="5.1 地理坐标系"></a>5.1 地理坐标系</h3><p>地球的自然表面有高山也有洼地，是崎岖不平的，我们要使用数学法则来描述他，就必须找到一个相对规则的数学面。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261022155.png" alt="image-20241126102206112"></p><ol><li><strong>大地水准面。</strong></li></ol><p>大地水准面是地球表面的第一级逼近。假设当海水处于完全静止的平衡状态时，从海平面延伸到所有大陆下部，而与地球重力方向处处正交的一个连续、闭合的曲面，这就是大地水准面。重力等势面</p><ol start="2"><li><strong>地球椭球体。</strong></li></ol><p>大地水准面可以近似成一个规则成椭球体，但并不是完全规则，其形状接近一个扁率极小的椭圆绕短轴旋转所形成的规则椭球体，这个椭球体称为地球椭球体。它是地球的第二级逼近</p><p><strong>地心坐标系</strong>：以总体地球为参考、以地球质心为中心的参考椭球为基准而建立的坐标系，如WGS84、CGCS2000。严格意义上，质心坐标系不存在大地原点的说法。</p><p><strong>参心坐标系</strong>：在特定区域内与地球表面吻合，大地原点是参考椭球与大地水准面相切的点，如Beijing54、Xian80。</p><p>我们经常做项目使用的坐标系为2000坐标系。</p><table><thead><tr><th><strong>坐标系名</strong></th><th><strong>北京54</strong></th><th><strong>西安80</strong></th><th><strong>WGS84</strong></th><th><strong>CGCS2000</strong></th></tr></thead><tbody><tr><td>参考椭球体</td><td>Krasovsky_1940</td><td>Xian_1980(IAG75）</td><td>WGS84</td><td>CGCS2000</td></tr><tr><td>基准面</td><td>D_Beijing_1954</td><td>D_Xian_1980</td><td>D_WGS_1984</td><td>D_China_2000</td></tr><tr><td>ArcGIS中的名称</td><td>GCS_Beijing_1954</td><td>GCS_Xian_1980</td><td>GCS_WGS_1984</td><td>GCS_China_Geodetic_Coordinate_System_2000</td></tr><tr><td>ArcGIS中的WKID</td><td>4214</td><td>4610</td><td>4326</td><td>4490</td></tr></tbody></table><p><strong>GCJ-02（火星坐标系）</strong>：GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。它其实就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被大家称为“火星坐标系统”。WGS加密，腾讯、高德在用。————————————————</p><p><strong>BD09（百度自己的坐标系）</strong>：BD09经纬度投影属于百度坐标系，它是在(GCJ02)标准经纬度的基础上进行GCJ-02加偏之后，再加上百度自身的加偏算法，也就是在标准经纬度的基础之上进行了两次加偏。。</p><h3 id="5-2-投影坐标系"><a href="#5-2-投影坐标系" class="headerlink" title="5.2 投影坐标系"></a>5.2 投影坐标系</h3><p>在地球椭球面和平面之间建立点与点之间函数关系的数学方法，称为地图投影。地球椭球表面是一种不可能展开的曲面，要把这样一个曲面表现到平面上，就会发生裂隙或褶皱。地图投影的变形通常有：<strong>长度变形、面积变形和角度变形</strong>。在实际应用中，根据使用地图的目的，限定某种变形。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261028563.png" alt="image-20241126102817532"></p><p><strong>通用横轴墨卡托投影</strong>：简称UTM，是一种国际标准化的地图投影法，使用笛卡儿坐标系，标记南纬80°至北纬84°之间的所有位置。</p><p><strong>高斯-克吕格投影</strong>：又名”等角横切椭圆柱投影”。我国基本比例尺地形图除1：100万以外均采用高斯-克吕格投影</p><p><strong>高斯－克吕格投影分带规定</strong>：该投影是国家基本比例尺地形图的数学基础，为控制变形，采用分带投影的方法，在比例尺1：2.5万—1：50万图上采用6°分带，对比例尺为1：1万及大于1：1万的图采用3°分带。。6°分带法：从格林威治零度经线起，每6°分为一个投影带，全球共分为60个投影带。3°分带法：从东经1°30′起，每3°为一带，将全球划分为120个投影带。</p><hr><p><strong>动态投影</strong></p><p>现在打开ArcGIS，新建一个空白地图</p><p>右下角显示的是未知单位</p><p>也就是说整个地图中是没有坐标系的</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261038611.png" alt="image-20241126103812561"></p><p>当我们从右侧拖进第一个要素的的时候，就动态的把第一个要素的坐标系设置为了这个图层的坐标系</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261042211.png" alt="image-20241126104222157"></p><p>这时候地图文档的坐标系动态匹配了图层的坐标系，现在是WGS 84的坐标系</p><p>我们再向这个图层中拖入WGS 84墨卡托投影的坐标系，系统会将这个坐标系换算成WGS 84的坐标系。</p><hr><p><strong>地图坐标系</strong>：整个地图文档的动态投影的属性（右下角），它的坐标系就是地图坐标系</p><p><strong>真实坐标系</strong>：图层在现实情况下真实所在的位置</p><p><strong>属性坐标系</strong>：图层右击，属性，源，投影坐标系。</p><p>使用工具【定义投影】强行把坐标系更改之后，地理位置会发生偏移，如下</p><p>1.比如我们有一个点的经纬度是(111.753052.31.671735):</p><p>2.它在2000..GK ZONE 37下的坐标为:(37571411,3505699)</p><p>3.它在WGS 1984 UTM 49N下的坐标为:(571382.3505699)</p><p>4.如果我们通过定义投影把2000..GK ZONE 37坐标系强行更改为WGS 1984 UTM 49N，那么这个点就变成了: WGS 1984 UTM 49N下坐标为(37571411,3505699)的点</p><hr><p><strong>工具箱</strong></p><p>对于没有坐标系的数据，需要定义它的投影</p><p>把shapefile中的prj文件删掉，这时候导入shapefile，ArcGIS会提示虽然有坐标，但是没有坐标系。</p><p>工具箱里找到定义投影</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261106711.png" alt="image-20241126110656669"></p><p>可以定义坐标系的数据。</p><h2 id="六、要素编辑以及属性表的使用"><a href="#六、要素编辑以及属性表的使用" class="headerlink" title="六、要素编辑以及属性表的使用"></a>六、要素编辑以及属性表的使用</h2><h3 id="6-1-创建要素"><a href="#6-1-创建要素" class="headerlink" title="6.1 创建要素"></a>6.1 创建要素</h3><h4 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h4><ol><li><p>shape数据直接导入</p></li><li><p>csv数据：</p></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261118520.png" alt="image-20241126111814469"></p><p>右键，显示xy数据</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261118601.png" alt="image-20241126111859578"></p><p>x字段选x列，y字段选y列，可以使用编辑指定坐标系</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261121428.png" alt="image-20241126112139373"></p><ol start="3"><li>CAD数据：</li></ol><p>直接拖入CAD素材，这是一个没有空间参考坐标系的文件，它会自动被解析成5种类型的文件</p><p>Annotation：注记类型，可以转换为数据库注记</p><p>Point：点要素</p><p>Polyline：线文件</p><p>Polygon：面文件</p><p>MultiPatch：</p><h4 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h4><p>创建一个面要素</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261135273.png" alt="image-20241126113503228"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261135407.png" alt="image-20241126113548379"></p><h4 id="初始坐标系的选择"><a href="#初始坐标系的选择" class="headerlink" title="初始坐标系的选择"></a>初始坐标系的选择</h4><p>点击编辑</p><p>如果是地理坐标系，就是常用的WGS84和郭嘉2000</p><p>如果是投影坐标系，看一下要素的所在位置大概在哪里，比如要创建武汉的要素，武汉在地球上的经度在113、114、115范围</p><p>离中央经线越近，它的投影变形就越小。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261141466.png" alt="image-20241126114110434"></p><p>选择 114E 的投影</p><h3 id="6-2-属性表"><a href="#6-2-属性表" class="headerlink" title="6.2 属性表"></a>6.2 属性表</h3><p><strong>属性表记录着一个要素里面所有的子元素</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261144370.png" alt="image-20241126114455329"></p><p>比如省级行政区划是个面要素，那么每个省都是一个面</p><p>上一环节，我们新建的area面，里面的属性表是空的</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261152558.png" alt="image-20241126115225518"></p><p>绘制一个面，点击编辑器，开始编辑，结束后停止编辑</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261203273.png" alt="image-20241126120314221"></p><p>再打开属性表，它就给我们创建出来了一个面</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261426498.png" alt="image-20241126142602414"></p><p><strong>属性表的每一个表头都是一个字段</strong></p><p>添加字段：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261427559.png" alt="image-20241126142755518"></p><p>注意：编辑属性表时，一定要在要素处于编辑状态下。</p><p><strong>计算几何：</strong></p><p>在属性表中右键</p><p>如果使用数据源的坐标系，可以计算当前坐标系下：面积、周长、质心x和y的坐标等</p><p>而使用数据框的坐标系，不可以计算</p><p><strong>按属性选择</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261433973.png" alt="image-20241126143350915"></p><p>可以按字段进行筛选，并且按筛选的条件导出，点击应用筛选，右键要素-【数据】-【导出数据】</p><p>属性表下方可以点击选中所选记录。</p><p><strong>字段计算器</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261436605.png" alt="image-20241126143646566"></p><p>右键字段表头，可以进行计算</p><h3 id="6-3-编辑要素"><a href="#6-3-编辑要素" class="headerlink" title="6.3 编辑要素"></a>6.3 编辑要素</h3><p>点击要素-【编辑器】-【编辑窗口】-【创建要素】</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261440223.png" alt="image-20241126144010186"></p><p><strong>面要素：</strong></p><p>在上方显示直线、弧线、追踪等</p><p>追踪：点击追踪可以移动鼠标，让程序自动描不规则的边。</p><p>编辑折点：点击折点，鼠标拖动可以对折点进行移动，同时可以添加折点和删除折点</p><p>裁剪面：可以在面的内部进行绘制，把这个面拆分多个部分，同时属性表也会变成两条。</p><p>分割工具：分割线要素</p><p>同时还可以绘制矩形、圆形、椭圆</p><p><strong>线要素：</strong></p><p>新建一个shapefile，折线要素，同样选中开始编辑，右侧创建要素面板选中折线，用构造工具画折现出来，然后双击结束。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411261446740.png" alt="image-20241126144654681"></p><p>同上，依然可以在编辑器里通过两点确定一个弧线段， 也可以使用追踪。</p><hr><p>可以在点击【编辑器】使用移动</p><p>合并：按住shift多选！！！然后点击【编辑器】使用合并，属性表中两个子要素也会合并成一个子要素。</p><p>PS：平常很少用ArcGIS绘图，图一般都是CAD来出。</p><h2 id="七、要素基本分析工具"><a href="#七、要素基本分析工具" class="headerlink" title="七、要素基本分析工具"></a>七、要素基本分析工具</h2><p>准备：</p><p>导出湖北省的数据</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270124188.png" alt="image-20241127012408114"></p><p>按属性选择，应用，导出数据</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270124909.png" alt="image-20241127012456867"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270126762.png" alt="image-20241127012626716"></p><p>再导入全国公路和铁路的干线</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270127403.png" alt="image-20241127012729364"></p><h3 id="7-1-裁剪"><a href="#7-1-裁剪" class="headerlink" title="7.1 裁剪"></a>7.1 裁剪</h3><p>点击上方【地理处理】或右侧直接搜索，搜索【裁剪】，比如我们想要湖北省和铁路干线相交的部分。</p><p>输入要素：被裁减的要素（线图层 transport）</p><p>裁剪要素：想要的范围（湖北省）</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270130953.png" alt="image-20241127013012919"></p><p>裁剪结果：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270131085.png" alt="image-20241127013113043"></p><h3 id="7-2-缓冲区"><a href="#7-2-缓冲区" class="headerlink" title="7.2 缓冲区"></a>7.2 缓冲区</h3><p>想做一个主干线1公里的影响范围</p><p>【缓冲区】</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270138287.png" alt="image-20241127013852248"></p><p>如果生成的不对，可能是图层坐标系不对，可以使用【定义投影】功能更改坐标系</p><p>这个就是生成出的1千米的缓冲区</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270139549.png" alt="image-20241127013944509"></p><p>这里可以用测量去量一下</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270140086.png" alt="image-20241127014030058"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270140766.png" alt="image-20241127014058731"></p><h3 id="7-3-多环缓冲区"><a href="#7-3-多环缓冲区" class="headerlink" title="7.3 多环缓冲区"></a>7.3 多环缓冲区</h3><p>有时想对道路的影响进行分层，要怎么做</p><p>比如距离道路200米可能影响最大，距离道路1千米或者2千米影响变小</p><p>在右侧搜索【多环缓冲区】，和生成单个缓冲区基本类似，可以根据不同距离生成不同缓冲区。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270148300.png" alt="image-20241127014815263"></p><p>生成结果就不是一个单个缓冲区，就是不同距离的缓冲区。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270148930.png" alt="image-20241127014837892"></p><h3 id="7-4-融合"><a href="#7-4-融合" class="headerlink" title="7.4 融合"></a>7.4 融合</h3><p>新建一张空白地图，导入一张面要素。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270152725.png" alt="image-20241127015203669"></p><p>这张面要素，有47个子要素，但是只有10种土地类型，所以有一些面可能不是在一起的。</p><p>现在要把它变成每个类别只有一个要素，就可以用到【融合】工具</p><p>融合：可以对某个要素，根据某个字段进行融合</p><p>根据融合字段，把要素合并为同一个子要素。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270154321.png" alt="image-20241127015449281"></p><p>创建多部件要素：不勾选，如果两个子要素不相连，就不会合并成同一个子要素。</p><p>融合结果：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270158152.png" alt="image-20241127015828092"></p><h3 id="7-5-合并"><a href="#7-5-合并" class="headerlink" title="7.5 合并"></a>7.5 合并</h3><p>现在左侧有7个要素，现在要把它们合并在一起</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270200717.png" alt="image-20241127020031676"></p><h4 id="7-5-1-合并"><a href="#7-5-1-合并" class="headerlink" title="7.5.1 合并"></a>7.5.1 合并</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270203859.png" alt="image-20241127020338814"></p><p>属性表中，相同的字段放在了一起，独有的字段也会展示，相当于并集。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270204273.png" alt="image-20241127020410215"></p><h4 id="7-5-2-联合"><a href="#7-5-2-联合" class="headerlink" title="7.5.2 联合"></a>7.5.2 联合</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270206154.png" alt="image-20241127020634116"></p><p>属性表中，共有的字段也会区分开来，如果不是本要素的，就取-1</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270207157.png" alt="image-20241127020712106"></p><hr><h3 id="7-6-相交"><a href="#7-6-相交" class="headerlink" title="7.6 相交"></a>7.6 相交</h3><p>新建一个空白图层</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270210615.png" alt="image-20241127021047581"></p><p>像这种有一部分漏在外面的，这种两个要素，其实可以用裁剪。</p><p>这时候演示一下相交。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270212157.png" alt="image-20241127021258112"></p><p>生成结果</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270213656.png" alt="image-20241127021320618"></p><h3 id="7-7-点线面互转"><a href="#7-7-点线面互转" class="headerlink" title="7.7 点线面互转"></a>7.7 点线面互转</h3><p>想把一个面要素转换成线要素，搜索【要素转线】</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270216081.png" alt="image-20241127021640041"></p><p>生成结果</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270216818.png" alt="image-20241127021658765"></p><hr><p>如果使用【要素转面】线必须是闭合的</p><hr><p>要素转点</p><h3 id="7-8-密度分析"><a href="#7-8-密度分析" class="headerlink" title="7.8 密度分析"></a>7.8 密度分析</h3><p>新建一个空白地图</p><p>搜索【密度】，会出现点密度分析、线密度分析、核密度分析</p><h4 id="7-8-1-点密度分析"><a href="#7-8-1-点密度分析" class="headerlink" title="7.8.1 点密度分析"></a>7.8.1 点密度分析</h4><p>这时候生成的是一个栅格，就不再是要素了。</p><p>第一次使用可能会报错，改一下投影，point也要改下投影，输出到文件夹中</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270227081.png" alt="image-20241127022759042"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270231279.png" alt="image-20241127023124234"></p><p>结果</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270232233.png" alt="image-20241127023150578"></p><p>这个长条不是我们想要的范围，</p><p>因为在分析的时候没有设置栅格分析的区域是多大。</p><p>点击【地理处理】-【环境】-【栅格分析】</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270234545.png" alt="image-20241127023454509"></p><p>重新生成点密度分析</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270236198.png"></p><p>再次查看结果</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270237485.png" alt="image-20241127023759447"></p><h4 id="7-8-2-线密度分析"><a href="#7-8-2-线密度分析" class="headerlink" title="7.8.2 线密度分析"></a>7.8.2 线密度分析</h4><p>把road拖进来</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270241382.png" alt="image-20241127024113341"></p><p>比如一个圆型的邻域，里面线有多长，单位是米\每平方千米</p><h4 id="7-8-3-核密度分析"><a href="#7-8-3-核密度分析" class="headerlink" title="7.8.3 核密度分析"></a>7.8.3 核密度分析</h4><h3 id="7-9-属性连接"><a href="#7-9-属性连接" class="headerlink" title="7.9 属性连接"></a>7.9 属性连接</h3><p>可以将要素的属性表和外部xls表格根据相同的列进行连接</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270248132.png" alt="image-20241127024823078"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270250344.png" alt="image-20241127025004306"></p><p>现在进行核密度分析，对每一个地级市的点进行人口密度分析</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270252620.png" alt="image-20241127025237577"></p><p>生成结果</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411270253229.png" alt="image-20241127025303190"></p><p>可以看到右侧人口密度比较大，人口数比较多。</p><h2 id="八、矢量数据可视化"><a href="#八、矢量数据可视化" class="headerlink" title="八、矢量数据可视化"></a>八、矢量数据可视化</h2><p>拖入这两个文件</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011726951.png" alt="image-20241201172640868"></p><p>链接人口数据，打开city属性表，选【连接和关联】-【连接】</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011728318.png" alt="image-20241201172824280"></p><p>人口数量就已经被链接进来了</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011729241.png" alt="image-20241201172922194"></p><p>添加一个字段，计算人口密度，选择【添加字段】</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011730781.png" alt="image-20241201173024752"></p><p>以同样的方式添加【面积】字段area</p><p>面积字段在列上右键，点击【计算几何】计算面积，单位选择平方千米</p><p>在人口字段，使用字段计算器，计算人口密度</p><p>使用人口数量&#x2F;面积</p><h3 id="8-1-标注"><a href="#8-1-标注" class="headerlink" title="8.1 标注"></a>8.1 标注</h3><p>在HB_city上右键，属性，标注，打勾【标注此图层的要素】，标注的字段修改为【市】</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011735634.png" alt="image-20241201173533591"></p><p>标注可以用表达式，表达式中可以用VB，python，JavaScript脚本</p><h3 id="8-2-符号系统"><a href="#8-2-符号系统" class="headerlink" title="8.2 符号系统"></a>8.2 符号系统</h3><p>对图层右键，属性，选择符号系统</p><h4 id="8-2-1-单一符号"><a href="#8-2-1-单一符号" class="headerlink" title="8.2.1 单一符号"></a>8.2.1 单一符号</h4><p>把每一个要素用统一的符号进行表达，会把这个文件内所有的要素设置为统一的要素。</p><h4 id="8-2-2-类别"><a href="#8-2-2-类别" class="headerlink" title="8.2.2 类别"></a>8.2.2 类别</h4><p>值字段选择【市】，点击【添加所有值】，添加所有的市，选择色带。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011747493.png" alt="image-20241201174710438"></p><p>值字段还可以用人口密度</p><p>多个字段：可以按多个字段来进行显示</p><h4 id="8-2-3-数量"><a href="#8-2-3-数量" class="headerlink" title="8.2.3 数量"></a>8.2.3 数量</h4><p>这时候选的字段必须是数值类型的字段，选择【密度】字段，分类可以选择分4类</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011750436.png" alt="image-20241201175001384"></p><p>可以看到每个类别的范围，【归一化】可以选择百分比</p><ul><li>分级符号：用符号的大小来表示，形状越大，表示这个值也越大</li><li>比例符号：有一个最大值和最小值的符号，其他数据按照比例来进行缩放和放大</li><li>点密度：根据值大小计算出的值密度，密度越高，说明这个字段值越大。</li></ul><h4 id="8-2-4-图表"><a href="#8-2-4-图表" class="headerlink" title="8.2.4 图表"></a>8.2.4 图表</h4><p>为每个要素绘制【饼图】，制作的是选中的字段，在这个要素中的一个饼图</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011755785.png" alt="image-20241201175537737"></p><p>其余的图形是一样的。</p><h2 id="九、栅格文件"><a href="#九、栅格文件" class="headerlink" title="九、栅格文件"></a>九、栅格文件</h2><h3 id="什么是栅格？"><a href="#什么是栅格？" class="headerlink" title="什么是栅格？"></a>什么是栅格？</h3><p>最简形式的栅格由按行和列（或格网）组织的像元（或像素）矩阵组成，其中的每个像元都包含一个信息值（例如温度）。栅格可以是数字航空像片、卫星影像、数字图片或甚至扫描的地图。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011802970.png" alt="image-20241201180231941"></p><ul><li>专题数据（也称为离散数据）表示土地利用或土壤数据等要素。</li><li>连续数据表示温度、高程或光谱数据（例如，卫星影像或航空像片）等现象。</li><li>图片则包括扫描的地图或绘图，以及建筑物照片。</li></ul><h3 id="栅格的分类"><a href="#栅格的分类" class="headerlink" title="栅格的分类"></a>栅格的分类</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011803894.png" alt="image-20241201180334834"></p><hr><h3 id="什么是像元？"><a href="#什么是像元？" class="headerlink" title="什么是像元？"></a>什么是像元？</h3><ul><li>像元，亦称像素点或像元点。即影像单元（picture element）。是组成数字化影像的最小单元。像元的大小决定着栅格中图案或要素呈现的粗细程度。</li><li>像元的尺寸可大可小，具体可根据栅格数据集所描述的表面，以及表面中要素的表达需要来确定。它可以是平方千米、平方英尺，甚至是平方厘米。</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202412011807525.png" alt="image-20241201180735485"></p><ul><li>像元大小越小，则栅格将越平滑或越详细。但是像元数量越多，所需的处理时间会越长，占据的存储空间也越大。</li><li>如果像元大小过大，则可能会出现信息丢失或精细的图样变得模糊的情况。</li></ul><h3 id="栅格的优缺点"><a href="#栅格的优缺点" class="headerlink" title="栅格的优缺点"></a>栅格的优缺点</h3><p>优点：</p><ul><li>数据结构更加简单，即由像元组成矩阵结构，其中的像元值表示坐标，有时与属性表相关联</li><li>格式更加强大，可进行高级的空间和统计分析</li><li>可以表示连续表面以及执行表面分析</li><li>点、线、面和表面都可同样存储</li><li>对复杂数据集也可执行快速叠置</li></ul><p>缺点：</p><ul><li>由于栅格数据集的像元尺寸具有局限性，所以可能会带来空间误差。</li><li>栅格数据集可能会非常大。虽然分辨率会随着栅格像元大小的减小而提高，但这会占用更多的磁盘空间，而且会拖慢处理速度。对于给定区域，将栅格像元大小更改为现有大小的一半时，所需的存储空间会增大为原来的四倍，具体情况取决于所使用的数据类型和存储技术。</li><li>将数据重建到固定间距的栅格像元边界时也会损失一定的精度。</li></ul><h2 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h2><p><a href="https://www.bilibili.com/video/BV1Ge4y127UA/">ArcGIS基础教程</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
      <category>GIS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IntelliJ IDEA 快捷键大全</title>
    <link href="/2023/09/18/IntelliJ%20IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <url>/2023/09/18/IntelliJ%20IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA-快捷键大全"><a href="#IntelliJ-IDEA-快捷键大全" class="headerlink" title="IntelliJ IDEA 快捷键大全"></a>IntelliJ IDEA 快捷键大全</h1><h3 id="一、构建-x2F-编译"><a href="#一、构建-x2F-编译" class="headerlink" title="一、构建&#x2F;编译"></a>一、构建&#x2F;编译</h3><table><thead><tr><th>快捷键</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><strong>Ctrl+F9</strong></td><td>构建项目</td><td>执行该命令后，IntelliJ IDEA 会编译项目中所有类，并将编译结果输出到out目录中。IntelliJ IDEA 支持增量构建，会在上次构建的基础上，仅编译修改的类。</td></tr><tr><td><strong>Ctrl+Shift+F9</strong></td><td>重新编译当前类</td><td>该快捷键，等同于菜单【Build】—&gt;【Recompile ‘class name’】<br />在IntelliJ IDEA 中打开要编译的类，执行该命令会编译当前类。</td></tr></tbody></table><h3 id="二、文本编辑"><a href="#二、文本编辑" class="headerlink" title="二、文本编辑"></a>二、文本编辑</h3><table><thead><tr><th>快捷键</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><strong>Ctrl+X</strong></td><td>剪切</td><td>剪切选中文本，若未选中则剪切当前行。</td></tr><tr><td><strong>Ctrl+C</strong></td><td>复制</td><td>复制选中文本，若未选中则复制当前行。</td></tr><tr><td><strong>Ctrl+V</strong></td><td>粘贴</td><td></td></tr><tr><td><strong>Ctrl+Alt+Shift+V</strong></td><td>粘贴为纯文本</td><td></td></tr><tr><td><strong>Ctrl+Shift+V</strong></td><td>从历史选择粘贴</td><td>从历史剪粘版中选择要粘贴的内容。</td></tr><tr><td><strong>Ctrl+D</strong></td><td>复制行</td><td></td></tr><tr><td><strong>Ctrl+Shift+C</strong></td><td>复制文件路径</td><td>复制选中文件所在路径。</td></tr><tr><td><strong>Ctrl+Alt+Shift+C</strong></td><td>复制引用</td><td>复制包的路径，或者类的名称。</td></tr><tr><td><strong>Ctrl+S</strong></td><td>保存全部</td><td></td></tr><tr><td><strong>Ctrl+Z</strong></td><td>撤销</td><td>撤销上一步操作内容。</td></tr><tr><td><strong>Ctrl+Shift+Z</strong></td><td>重做</td><td>恢复上一步撤销内容。</td></tr><tr><td><strong>Tab</strong></td><td>缩进</td><td></td></tr><tr><td><strong>Shift+Tabl</strong></td><td>取消缩进</td><td></td></tr><tr><td><strong>Ctrl+Alt+I</strong></td><td>自动缩进行</td><td>自动缩进至规范位置。</td></tr><tr><td><strong>Shift+Enter</strong></td><td>开始新行</td><td>无论光标是否在行尾，都开始新的行。</td></tr><tr><td><strong>Ctrl+Alt+Enter</strong></td><td>在当前行之前开始新行</td><td></td></tr><tr><td><strong>Ctrl+Y</strong></td><td>删除行</td><td>删除当前行。</td></tr><tr><td><strong>Ctrl+Shift+U</strong></td><td>大小写转换</td><td></td></tr><tr><td><strong>Ctrl+Alt+Shift+Insert</strong></td><td>创建临时文件</td><td></td></tr><tr><td><strong>Shift+F4</strong></td><td>在新窗口中打开</td><td>在新窗口打开当前文件。</td></tr></tbody></table><h3 id="三、光标操作"><a href="#三、光标操作" class="headerlink" title="三、光标操作"></a>三、光标操作</h3><table><thead><tr><th>快捷键</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><strong>Ctrl+Left</strong></td><td>左移一个单词</td><td></td></tr><tr><td><strong>Ctrl+Right</strong></td><td>右移一个单词</td><td></td></tr><tr><td><strong>Home</strong></td><td>移动至行首</td><td></td></tr><tr><td><strong>End</strong></td><td>移动至行尾</td><td></td></tr><tr><td><strong>Ctrl+Shift+M</strong></td><td>移动至大括号</td><td>多次按下快捷键，可以在左右两个大括号间切换。</td></tr><tr><td><strong>Ctrl+[</strong></td><td>移动至代码块开始</td><td></td></tr><tr><td><strong>Ctrl+]</strong></td><td>移动至代码块末尾</td><td></td></tr><tr><td><strong>Alt+Down</strong></td><td>下一个方法</td><td></td></tr><tr><td><strong>Alt+Up</strong></td><td>上一个方法</td><td></td></tr><tr><td><strong>Ctrl+PageUp</strong></td><td>移动至页面顶部</td><td></td></tr><tr><td><strong>Ctrl+PageDown</strong></td><td>移动至页面底部</td><td></td></tr><tr><td><strong>PageUp</strong></td><td>向上翻页</td><td></td></tr><tr><td><strong>PageDown</strong></td><td>向下翻页</td><td></td></tr><tr><td><strong>Ctrl+Home</strong></td><td>移动至文件开头</td><td></td></tr><tr><td><strong>Ctrl+End</strong></td><td>移动至文件末尾</td><td></td></tr></tbody></table><h3 id="四、文本选择"><a href="#四、文本选择" class="headerlink" title="四、文本选择"></a>四、文本选择</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><strong>Ctrl+A</strong></td><td>全选</td></tr><tr><td><strong>Shift+Left</strong></td><td>向左选择</td></tr><tr><td><strong>Shift+Right</strong></td><td>向右选择</td></tr><tr><td><strong>Ctrl+Shift+Left</strong></td><td>向左选择一个单词</td></tr><tr><td><strong>Ctrl+Shift+Right</strong></td><td>向右选择一个单词</td></tr><tr><td><strong>Shift+Home</strong></td><td>向左选择至行头</td></tr><tr><td><strong>Shift+End</strong></td><td>向右选择至行尾</td></tr><tr><td><strong>Shift+Up</strong></td><td>向上选择</td></tr><tr><td><strong>Shift+Down</strong></td><td>向下选择</td></tr><tr><td><strong>Ctrl+Shift+[</strong></td><td>选择至代码块开头</td></tr><tr><td><strong>Ctrl+Shift+]</strong></td><td>选择至代码块结尾</td></tr><tr><td><strong>Ctrl+Shift+PageUp</strong></td><td>选择至页面顶部</td></tr><tr><td><strong>Ctrl+Shift+PageDown</strong></td><td>选择至页面底部</td></tr><tr><td><strong>Shift+PageUp</strong></td><td>向上翻页选择</td></tr><tr><td><strong>Shift+PageDown</strong></td><td>向下翻页选择</td></tr><tr><td><strong>Ctrl+Shift+Home</strong></td><td>选择至文件开关</td></tr><tr><td><strong>Ctrl+Shift+End</strong></td><td>选择至文件结尾</td></tr><tr><td><strong>Ctrl+W</strong></td><td>扩展选择</td></tr><tr><td><strong>Ctrl+Shift+W</strong></td><td>收缩选择</td></tr></tbody></table><h3 id="五、代码折叠"><a href="#五、代码折叠" class="headerlink" title="五、代码折叠"></a>五、代码折叠</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><strong>Ctrl+NumPad+</strong></td><td>展开代码块</td></tr><tr><td><strong>Ctrl+NumPad-</strong></td><td>折叠代码块</td></tr><tr><td><strong>Ctrl+Alt+NumPad+</strong></td><td>递归展开</td></tr><tr><td><strong>Ctrl+Alt+NumPad-</strong></td><td>递归折叠</td></tr><tr><td><strong>Ctrl+Shift+NumPad+</strong></td><td>全部展开</td></tr><tr><td><strong>Ctrl+Shift+NumPad-</strong></td><td>全部折叠</td></tr><tr><td><strong>Ctrl+.</strong></td><td>折叠选择</td></tr></tbody></table><h3 id="六、多个插入符号和范围选择"><a href="#六、多个插入符号和范围选择" class="headerlink" title="六、多个插入符号和范围选择"></a>六、多个插入符号和范围选择</h3><table><thead><tr><th>快捷键</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><strong>Alt+Shift+Click</strong></td><td>添加&#x2F;删除插入符号</td><td></td></tr><tr><td><strong>Alt+Shift+Insert</strong></td><td>切换列选择模式</td><td></td></tr><tr><td><strong>双击Ctrl+Up</strong></td><td>向上克隆插入符号</td><td>按Ctrl键两次，然后在不松开的情况下按向上箭头键。</td></tr><tr><td><strong>双击Ctrl+Down</strong></td><td>向下克隆插入符号</td><td>按Ctrl键两次，然后在不松开的情况下按向下箭头键。</td></tr><tr><td><strong>Alt+Shift+G</strong></td><td>将插入符号添加到选择中的每一行</td><td></td></tr><tr><td><strong>Alt+J</strong></td><td>选择单位下次出现的位置</td><td></td></tr><tr><td><strong>Alt+Shift+J</strong></td><td>取消最后一次选择</td><td></td></tr><tr><td><strong>Ctrl+Alt+Shift+J</strong></td><td>选择所有出现的位置</td><td></td></tr><tr><td><strong>Alt+Shift+Middle-Click</strong></td><td>创建矩形选择</td><td></td></tr><tr><td><strong>Alt+Click</strong></td><td>拖拽以创建矩形选择区</td><td></td></tr><tr><td><strong>Ctrl+Alt+Shift+Click</strong></td><td>拖拽以创建多个矩形选择区</td><td></td></tr></tbody></table><h3 id="七、辅助编码"><a href="#七、辅助编码" class="headerlink" title="七、辅助编码"></a>七、辅助编码</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><strong>Alt+Enter</strong></td><td>显示建议操作</td></tr><tr><td><strong>Ctrl+Space</strong></td><td>代码补全</td></tr><tr><td><strong>Ctrl+Shift+Space</strong></td><td>类型匹配代码补全</td></tr><tr><td><strong>Ctrl+Alt+Space</strong></td><td>第二次代码补全</td></tr><tr><td><strong>Ctrl+Shift+Enter</strong></td><td>补全当前语句</td></tr><tr><td><strong>Ctrl+Alt+L</strong></td><td>格式化代码</td></tr><tr><td><strong>Ctrl+P</strong></td><td>参数信息提醒</td></tr><tr><td><strong>Ctrl+Q</strong></td><td>快速文档</td></tr><tr><td><strong>Ctrl+Shift+Up</strong></td><td>向上移动语句</td></tr><tr><td><strong>Ctrl+Shift+Down</strong></td><td>向下移动语句</td></tr><tr><td><strong>Ctrl+Alt+Shift+Left</strong></td><td>向左移动元素</td></tr><tr><td><strong>Ctrl+Alt+Shift+Right</strong></td><td>向右移动元素</td></tr><tr><td><strong>Alt+Shift+Up</strong></td><td>向上移动队列</td></tr><tr><td><strong>Alt+Shift+Down</strong></td><td>向下移动队列</td></tr><tr><td><strong>Ctrl+&#x2F;</strong></td><td>添加行注释</td></tr><tr><td><strong>Ctrl+Shift+&#x2F;</strong></td><td>添加块注释</td></tr><tr><td><strong>Alt+Insert</strong></td><td>生产语句</td></tr></tbody></table><h3 id="八、上下文导航"><a href="#八、上下文导航" class="headerlink" title="八、上下文导航"></a>八、上下文导航</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><strong>Alt+Down</strong></td><td>跳转至下一个方法</td></tr><tr><td><strong>Alt+Up</strong></td><td>跳转至上一个方法</td></tr><tr><td><strong>Ctrl+G</strong></td><td>跳转到指定行</td></tr><tr><td><strong>Ctrl+Tab</strong></td><td>切换活动文件</td></tr><tr><td><strong>Alt+F1</strong></td><td>选择文件的定位</td></tr><tr><td><strong>Ctrl+E</strong></td><td>最近的文件</td></tr><tr><td><strong>Ctrl+Shift+Backspace</strong></td><td>返回上次编辑位置</td></tr><tr><td><strong>Ctrl+Alt+Left</strong></td><td>后退</td></tr><tr><td><strong>Ctrl+Alt+Right</strong></td><td>前进</td></tr><tr><td><strong>Ctrl+Alt+Down</strong></td><td>下一事件</td></tr><tr><td><strong>Ctrl+Alt+Up</strong></td><td>上一事件</td></tr><tr><td><strong>Alt+Right</strong></td><td>选择下一个选项卡</td></tr><tr><td><strong>Alt+Left</strong></td><td>选择下一个选项卡</td></tr><tr><td><strong>F11</strong></td><td>切换匿名书签</td></tr><tr><td><strong>Ctrl+Shift+[digit]</strong></td><td>用数字切换书签</td></tr><tr><td><strong>Ctrl+F11</strong></td><td>使用助词符切换书签</td></tr><tr><td><strong>Shift+F11</strong></td><td>显示所有书签</td></tr><tr><td><strong>Ctrl+[digit]</strong></td><td>用数字跳转到书签</td></tr><tr><td><strong>Alt+7</strong></td><td>显示结构窗口</td></tr><tr><td><strong>Alt+3</strong></td><td>显示查找窗口</td></tr></tbody></table><h3 id="九、查找操作"><a href="#九、查找操作" class="headerlink" title="九、查找操作"></a>九、查找操作</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><strong>双击Shift</strong></td><td>查找所有</td></tr><tr><td><strong>Ctrl+F</strong></td><td>查找字符（当前文件）</td></tr><tr><td><strong>F3</strong></td><td>查找下一个</td></tr><tr><td><strong>Shift+F3</strong></td><td>查找上一个</td></tr><tr><td><strong>Ctrl+R</strong></td><td>替换字符（当前文件）</td></tr><tr><td><strong>Ctrl+Shift+F</strong></td><td>查找字符（所有文件）</td></tr><tr><td><strong>Ctrl+Shift+R</strong></td><td>替换字符（所有文件）</td></tr><tr><td><strong>Ctrl+F3</strong></td><td>跳转到光标处单词的下一位置</td></tr><tr><td><strong>Ctrl+Shift+N</strong></td><td>查找文件并跳转</td></tr><tr><td><strong>Ctrl+F12</strong></td><td>打开文件结构</td></tr><tr><td><strong>Ctrl+Alt+Shift+N</strong></td><td>查找符号（变量、方法等）</td></tr><tr><td><strong>Ctrl+Shift+A</strong></td><td>查找动作</td></tr></tbody></table><h3 id="十、符号导航"><a href="#十、符号导航" class="headerlink" title="十、符号导航"></a>十、符号导航</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><strong>Alt+F7</strong></td><td>查找用法</td></tr><tr><td><strong>Ctrl+B</strong></td><td>跳转到声明处</td></tr><tr><td><strong>Ctrl+Shift+B</strong></td><td>跳转到声明类处</td></tr><tr><td><strong>Ctrl+Alt+F7</strong></td><td>显示用法</td></tr><tr><td><strong>Ctrl+U</strong></td><td>跳转到超级方法</td></tr><tr><td><strong>Ctrl+Alt+B</strong></td><td>跳转到实现方法</td></tr><tr><td><strong>Ctrl+Shift+F7</strong></td><td>突出显示文件中的用法</td></tr></tbody></table><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IntelliJ IDEA</tag>
      
      <tag>快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂HTTPS</title>
    <link href="/2023/05/23/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82HTTPS/"/>
    <url>/2023/05/23/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82HTTPS/</url>
    
    <content type="html"><![CDATA[<h1 id="一文搞懂HTTPS"><a href="#一文搞懂HTTPS" class="headerlink" title="一文搞懂HTTPS"></a>一文搞懂HTTPS</h1><p>HTTPS（S：secure）安全</p><blockquote><p>随着互联网的应用越来越广泛，其中所传递数据的价值越来越大时，人们便不得不考虑为http协议提供安全保障。</p></blockquote><h2 id="一、对称加密"><a href="#一、对称加密" class="headerlink" title="一、对称加密"></a>一、对称加密</h2><p>先对数据加密后再传输，对方收到后解密再使用。</p><p>但这不得不涉及一个问题，那就是【密钥】。</p><p>发送者使用密钥将数据加密，接收者使用同样的密钥将其解密，互为逆向过程。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230523011422840.png"></p><p>这也被称之为，【对称加密】，即<strong>加解密使用相同的密钥</strong>。</p><p>所以，浏览器和服务器如何确定出一个相同的密钥呢？</p><p>如果由一方生成，以【明文】的方式传递过去，中间的攻击者自然也能轻松的拦截下来。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230523012044625.png"></p><p>攻击者一旦有了【密钥】，那后续的加密将会变得毫无意义。</p><h2 id="二、非对称加密"><a href="#二、非对称加密" class="headerlink" title="二、非对称加密"></a>二、非对称加密</h2><p>【对称加密】的加解密过程使用的是同一个密钥，具有对称性。</p><p>【非对称加密】中，密钥总是<strong>成对出现</strong>，分别称为【公钥】和【私钥】。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230523013035936.png"></p><p>由【公钥】加密的数据，只能由【私钥】解密，【公钥】自己也无法破解。</p><p>同理，【私钥】加密的数据，只能由【公钥】解密，【私钥】自己也无法破解。</p><p>加解密的过程并不对称。所以，</p><ol><li>服务器先将自己的公钥发送给浏览器。</li><li>浏览器生成一个随机的数据，用服务器的公钥进行加密，再发送给服务器。</li><li>服务器用自己的私钥解密，如此，双方就得到了一个同样的随机数据。</li></ol><p>这个随机数据就可以作为【对称加密】的【密钥】。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230523014043587.png"></p><p>如果攻击者，在服务器发送给浏览器公钥的过程中将其拦截，并替换成自己的公钥再发送给浏览器。</p><p>浏览器收到公钥，它无法辨别这个公钥是否被篡改过，所以用攻击者的公钥将随机数据加密作为对称加密的密钥。</p><p>攻击者收到后，因为是被自己的公钥加密过的数据，所以自然可以用自己的私钥解密，得到【明文】。</p><p>然后再用服务器的公钥对【明文】进行加密，再发送给服务器，服务器用自己的私钥解密。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230523015426689.png"></p><p>这样虽然，通信双方协商出了对称加密的密钥，但攻击者也知道了，所以后续的加密变得毫无意义。</p><p>问题的根本在于：<strong>公钥并不能代表自己属于谁</strong></p><p>所以解决的方式是让其具有<strong>表明自己身份的能力</strong>。</p><h2 id="三、CA（certificate-Authority，证书授权）"><a href="#三、CA（certificate-Authority，证书授权）" class="headerlink" title="三、CA（certificate Authority，证书授权）"></a>三、CA（certificate Authority，证书授权）</h2><p>这时候需要引入一个第三方的角色。</p><p>现在服务器把自己的【公钥】【域名】【组织名】【所申请的第三方机构名】等信息放在一起，形成一个数据集合。</p><p>拿着这份数据去找这个第三方机构，该机构也有一个【公私钥】对。</p><p>用自己的私钥对这些数据进行加密，得到一个密文，这就是【签名】。</p><p>把【签名数据】和【原始明文】放在一起，发送给服务器的管理员，这就是所谓的【TLS证书】，这个第三方机构被称为【CA】</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230523223227212.png"></p><p>现在服务器传递给浏览器的不再是自己的公钥，而是这个能表明自己身份的证书，浏览器拿到证书之后需要先进行【验证】。</p><p>拿【CA】机构的【公钥】对证书中的密文进行解密，如果解密的结果和证书中的明文一致，通过验证。</p><p>然后从证书中提取出【服务器的公钥】，加密随机数据进行发送。双方再协商出【对称加密】的【密钥】</p><ol><li>这时如果攻击者拦截到服务器的【证书后】，将证书中明文的【公钥】改成自己的，那么浏览器收到后，解密签名中的公钥部分和篡改之后的对不上，其中必然有诈。</li><li>如果攻击者也在CA机构申请到了一个证书，并在拦截后替换成了自己的证书，这样解密签名的结果和明文部分确实对的上，但证书中的域名和浏览器正在访问的地址又对不上，其中也必然有诈。</li></ol><h2 id="四、安全性"><a href="#四、安全性" class="headerlink" title="四、安全性"></a>四、安全性</h2><p>以上就可以巧妙的解决攻击者偷天换日的把戏。</p><p>如果CA给攻击者错误地签发了一张域名和机构信息是被攻击的站点，但公钥是攻击者的证书，浏览器便无法识破其中的玄机。所以CA在给申请者颁发证书的时候，需要仔细甄别攻击者的身份。</p><p><strong>浏览器又怎么知道该信任哪些CA机构呢？</strong></p><p>答案是内置，只有这些被系统或浏览器内置的CA机构颁发的证书才能通过浏览器的认证。操作系统和浏览器厂商在内置这些CA机构的时候也是经过谨慎考察的，因为一旦某些CA机构出现了问题，将对自己的品牌观瞻产生巨大的负面影响。</p><p>这样一来，成为一个CA机构是一个门槛比较高的事情，所以一般具有一定行业影响力的权威机构才堪当此任，比如微软、谷歌、中国金融认证中心等等，这些机构一般没有颁发错误的证书的动机。</p><p>CA机构责任重大的同时，权力也有些过于集中，以至于让这种建立在信任之上的安全显得十分脆弱。</p><p>证书的颁发依靠的是人的判断，也就是那些办事员，但只要是人就有失误的可能，另一方面，只要是人，就难保不出现腐败以及收受贿赂，为不法分子开方便之门。</p><h2 id="五、CT（certificate-Transparency，证书透明）"><a href="#五、CT（certificate-Transparency，证书透明）" class="headerlink" title="五、CT（certificate Transparency，证书透明）"></a>五、CT（certificate Transparency，证书透明）</h2><p>2013年，人们提供了【证书透明】的方案。</p><p>证书透明要求CA机构每颁发一个证书的时候，都要向一个叫【日志服务】的角色提交证书的详情，日志服务负责将其记录下来，同时向CA返回一个【SCT】数据，CA将SCT加入证书的扩展中，把这个携带SCT的证书颁发给站点服务器，浏览器拿到这个带有SCT的证书，除了验证证书本身以外，还要向日志服务验证SCT，日志服务含有自己的【公私钥】对，而SCT中则包含被其私钥签名的数据，所以浏览器使用日志服务的公钥，对SCT中的签名进行验签来确定真实性。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230523231802878.png"></p><p>这种看起来无意义的套娃操作，在CA机制上套了一层CT的机制，那CA机构可以篡改和颁发错误的证书，日志服务就不能篡改或颁发错误的SCT吗？这就是CT机制要解决的核心问题：【去中心化】。</p><h2 id="六、去中心化"><a href="#六、去中心化" class="headerlink" title="六、去中心化"></a>六、去中心化</h2><p>区块链技术给人们带来最大的启示就是：任何中心化的节点都是不可信任的，不论它如何权威，只有将信任分配到每个利益相关方的手中，相互监督才能打破困境。</p><p>【日志服务】采用了区块链中常用的【Merkle tree】默克尔树来防止篡改：</p><p>将证书颁发记录按照产生时间依次排序，分别计算出每个记录的哈希值，相邻的两个哈希值组合在一起，形成新数据，再对这个数据进行哈希计算，同样再把相邻的两个哈希值组合在一起，形成新的数据，直到最后只有一个数据，这个哈希值的数据被称为根哈希值（Root Hash），只要大家监督这个根哈希值，就能保证数据无法被私自篡改。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230523233348242.png"></p><p>这样修改叶子的任何一个哈希值，都会导致根哈希值的改变。同样你也无法删除这棵树中任何一个节点，这也会引起根哈希值的改变。</p><p>也就是说日志服务是一个只能添加的账本系统，而且他的数据完全公开，所有人都可以查询并且验证。</p><p>比如域名的拥有者，就可以通过对日志服务的周期性查询，以检查自己的域名下有没有可疑的证书颁发记录。</p><p>CA机构可以作为监视者，监视自己的同行中是否出现失误或者腐败的现象。</p><p>现在各家浏览器都开始强制对SCT信息的检查，一个不携带SCT的证书会被浏览器标注为【不安全】。</p><p><strong>文献来源：</strong></p><p><a href="https://www.bilibili.com/video/BV1uY4y1D7Ng/">Ele实验室：https技术鉴赏</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23种设计模式</title>
    <link href="/2023/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>文章摘自《设计模式之禅 第2版》- 秦小波</p><h2 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Ensure a class has only one instance, and provide a global point of access to it.</p><p>（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p><h3 id="通用类图"><a href="#通用类图" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221216004046292.png" alt="单例模式通用类图"></p><h3 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h3><p>Singleton类称为单例类，通过使用private的构造函数确保了在一个应用中只产生一个实例，并且是自行实例化的（在Singleton中自己使用<code>new Singleton()</code>）。</p><p><strong>单例模式通用代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-comment">//限制产生多个对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-comment">//通过该方法获得实例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>    <span class="hljs-comment">//类中其他方法，尽量是static</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</li><li>由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）。</li><li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。单例模式为什么不能增加接口呢？因为接口对单例模式是没有任何意义的，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。当然，在特殊情况下，单例模式可以实现接口、被继承等，需要在系统开发中根据环境判断。</li><li>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</li><li>单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>要求生成唯一序列号的环境；</li><li>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；</li><li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</li><li>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>首先，在高并发情况下，请注意单例模式的线程同步问题。</p><p><strong>线程不安全的单例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//限制产生多个对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-comment">//通过该方法获得实例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(singleton == <span class="hljs-literal">null</span>)&#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该单例模式在低并发的情况下尚不会出现问题，若系统压力增大，并发量增加时则可能在内存中出现多个实例，破坏了最初的预期。为什么会出现这种情况呢？如一个线程A执行到singleton &#x3D; new Singleton()，但还没有获得对象（对象初始化是需要时间的），第二个线程B也在执行，执行到（singleton &#x3D;&#x3D; null）判断，那么线程B获得判断条件也是为真，于是继续运行下去，线程A获得了一个对象，线程B也获得了一个对象，在内存中就出现两个对象！</p><p>解决线程不安全的方法很有多，可以在getSingleton方法前加synchronized关键字，也可以在getSingleton方法内增加synchronized来实现。</p><p>其次，需要考虑对象的复制情况。在Java中，对象默认是不可以被复制的，若实现了Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象复制是不用调用类的构造函数，因此即使是私有的构造函数，对象仍然可以被复制。在一般情况下，类复制的情况不需要考虑，很少会出现一个单例类会主动要求被复制的情况，解决该问题的最好方法就是单例类不要实现Cloneable接口。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>单例模式是23个模式中比较简单的模式，应用也非常广泛，如在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理这些Bean的生命期，决定什么时候创建出来，什么时候销毁，销毁的时候要如何处理，等等。如果采用非单例模式（Prototype类型），则Bean初始化后的管理交由J2EE容器，Spring容器不再跟踪管理Bean的生命周期。</p><h2 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Define an interface for creating an object,but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses.</p><p>（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）</p><h3 id="通用类图-1"><a href="#通用类图-1" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221216010642484.png" alt="工厂方法模式通用类图"></p><p>在工厂方法模式中，抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义；</p><p>Creator为抽象创建类，也就是抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。</p><h3 id="通用代码-1"><a href="#通用代码-1" class="headerlink" title="通用代码"></a>通用代码</h3><p><strong>抽象产品类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-comment">//产品类的公共方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体产品类：</strong>具体的产品类可以有多个，都继承于抽象产品类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抽象工厂类：</strong>抽象工厂类负责定义产品对象的产生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 创建一个产品对象，其输入参数类型可以自行设置</span><br><span class="hljs-comment">    * 通常为String、Enum、Class等，当然也可以为空</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span>&gt; T <span class="hljs-title function_">createProduct</span><span class="hljs-params">(Class&lt;T&gt; c)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体工厂类：</strong>具体如何产生一个产品的对象，是由具体的工厂类实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Creator</span> &#123;<br>    <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span>&gt; T <span class="hljs-title function_">createProduct</span><span class="hljs-params">(Class&lt;T&gt; c)</span>&#123;<br>        Product product=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            product = (Product)Class.forName(c.getName()).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//异常处理</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> (T)product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Creator</span> <span class="hljs-variable">creator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCreator</span>();<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> creator.createProduct(ConcreteProduct1.class);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 继续业务处理</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li><p>首先，良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。</p></li><li><p>其次，工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成“拥抱变化”。</p></li><li><p>再次，屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。因为产品类的实例化工作是由工厂类负责的，一个产品对象具体由哪一个产品生成是由工厂类决定的。在数据库开发中，大家应该能够深刻体会到工厂方法模式的好处：如果使用JDBC连接数据库，数据库从MySQL切换到Oracle，需要改动的地方就是切换一下驱动名称（前提条件是SQL语句是标准语句），其他的都不需要修改，这是工厂方法模式灵活性的一个直接案例。</p></li><li><p>最后，工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！</p></li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>首先，工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码的复杂度。</p><p>其次，需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。万物皆对象，那万物也就皆产品类，例如需要设计一个连接邮件服务器的框架，有三种网络协议可供选择：POP3、IMAP、HTTP，我们就可以把这三种连接方法作为产品类，定义一个接口如IConnectMail，然后定义对邮件的操作方法，用不同的方法实现三个具体的产品类（也就是连接方式）再定义一个工厂方法，按照不同的传入条件，选择不同的连接方式。如此设计，可以做到完美的扩展，如某些邮件服务器提供了WebService接口，很好，我们只要增加一个产品类就可以了。</p><p>再次，工厂方法模式可以用在异构项目中，例如通过WebService与一个非Java的项目交互，虽然WebService号称是可以做到异构系统的同构化，但是在实际的开发中，还是会碰到很多问题，如类型问题、WSDL文件的支持问题，等等。从WSDL中产生的对象都认为是一个产品，然后由一个具体的工厂类进行管理，减少与外围系统的耦合。</p><p>最后，可以使用在测试驱动开发的框架下。例如，测试一个类A，就需要把与类A有关联关系的类B也同时产生出来，我们可以使用工厂方法模式把类B虚拟出来，避免类A与类B的耦合。目前由于JMock和EasyMock的诞生，该使用场景已经弱化了，读者可以在遇到此种情况时直接考虑使用JMock或EasyMock。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="缩小为简单工厂模式"><a href="#缩小为简单工厂模式" class="headerlink" title="缩小为简单工厂模式"></a>缩小为简单工厂模式</h4><p>我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。</p><p>女娲造人的示例：</p><p><strong>原类图：</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221216011736097.png" alt="女娲造人类图"></p><p><strong>简单工厂模式类图：</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221216011648864.png" alt="简单工厂模式类图"></p><p>我们在类图中去掉了AbstractHumanFactory抽象类，同时把createHuman方法设置为静态类型，简化了类的创建过程，变更的源码仅仅是HumanFactory和NvWa类。</p><p><strong>简单工厂模式中的工厂类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HumanFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&gt; T <span class="hljs-title function_">createHuman</span><span class="hljs-params">(Class&lt;T&gt; c)</span>&#123;<br>        <span class="hljs-comment">//定义一个生产出的人种</span><br>        Human human=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//产生一个人种</span><br>            human = (Human)Class.forName(c.getName()).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;人种生成错误！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T)human;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>HumanFactory类仅有两个地方发生变化：</p><p>去掉继承抽象类，并在createHuman前增加static关键字；工厂类发生变化，也同时引起了调用者NvWa的变化。</p><p><strong>简单工厂模式中的场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NvWa</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//女娲第一次造人，火候不足，于是白色人种产生了</span><br>        System.out.println(<span class="hljs-string">&quot;--造出的第一批人是白色人种--&quot;</span>);<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">whiteHuman</span> <span class="hljs-operator">=</span> HumanFactory.createHuman(WhiteHuman.class);<br>        whiteHuman.getColor();<br>        whiteHuman.talk();<br>        <span class="hljs-comment">//女娲第二次造人，火候过足，于是黑色人种产生了</span><br>        System.out.println(<span class="hljs-string">&quot;\n--造出的第二批人是黑色人种--&quot;</span>);<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">blackHuman</span> <span class="hljs-operator">=</span> HumanFactory.createHuman(BlackHuman.class);<br>        blackHuman.getColor();<br>        blackHuman.talk();<br>        <span class="hljs-comment">//第三次造人，火候刚刚好，于是黄色人种产生了</span><br>        System.out.println(<span class="hljs-string">&quot;\n--造出的第三批人是黄色人种--&quot;</span>);<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">yellowHuman</span> <span class="hljs-operator">=</span> HumanFactory.createHuman(YellowHuman.class);<br>        yellowHuman.getColor();<br>        yellowHuman.talk();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>运行结果没有发生变化，但是我们的类图变简单了，而且调用者也比较简单，该模式是工厂方法模式的弱化，因为简单，所以称为简单工厂模式（Simple Factory Pattern），也叫做静态工厂模式。在实际项目中，采用该方法的案例还是比较多的，其缺点是工厂类的扩展比较困难，不符合开闭原则，但它仍然是一个非常实用的设计模式。</p></blockquote><h4 id="升级为多个工厂类"><a href="#升级为多个工厂类" class="headerlink" title="升级为多个工厂类"></a>升级为多个工厂类</h4><p>当我们在做一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。例如，一个产品类有5个具体实现，每个实现类的初始化（不仅仅是new，初始化包括new一个对象，并对对象设置一定的初始值）方法都不相同，如果写在一个工厂方法中，势必会导致该方法巨大无比，那该怎么办？</p><p>考虑到需要结构清晰，我们就为每个产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。我们还是以女娲造人为例，每个人种都有一个固定的八卦炉，分别造出黑色人种、白色人种、黄色人种。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221216012159441.png" alt="多个工厂类的类图"></p><p>每个人种（具体的产品类）都对应了一个创建者，每个创建者都独立负责创建对应的产品对象，非常符合单一职责原则，按照这种模式我们来看看代码变化。</p><p><strong>多工厂模式的抽象工厂类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHumanFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Human <span class="hljs-title function_">createHuman</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>PS：抽象方法中已经不再需要传递相关参数了，因为每一个具体的工厂都已经非常明确自己的职责：创建自己负责的产品类对象。</em></p><p><strong>黑色人种的创建工厂实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackHumanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHumanFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Human <span class="hljs-title function_">createHuman</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackHuman</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>黄色人种的创建工厂实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YellowHumanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHumanFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Human <span class="hljs-title function_">createHuman</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YellowHuman</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>白色人种的创建工厂实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WhiteHumanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHumanFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Human <span class="hljs-title function_">createHuman</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WhiteHuman</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>三个具体的创建工厂都非常简单，但是，如果一个系统比较复杂时工厂类也会相应地变复杂。</p><p><strong>场景类NvWa：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NvWa</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//女娲第一次造人，火候不足，于是白色人种产生了</span><br>        System.out.println(<span class="hljs-string">&quot;--造出的第一批人是白色人种--&quot;</span>);<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">whiteHuman</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">WhiteHumanFactory</span>()).createHuman();<br>        whiteHuman.getColor();<br>        whiteHuman.talk();<br>        <span class="hljs-comment">//女娲第二次造人，火候过足，于是黑色人种产生了</span><br>        System.out.println(<span class="hljs-string">&quot;\n--造出的第二批人是黑色人种--&quot;</span>);<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">blackHuman</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackHumanFactory</span>()).createHuman();<br>        blackHuman.getColor();<br>        blackHuman.talk();<br>        <span class="hljs-comment">//第三次造人，火候刚刚好，于是黄色人种产生了</span><br>        System.out.println(<span class="hljs-string">&quot;\n--造出的第三批人是黄色人种--&quot;</span>);<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">yellowHuman</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">YellowHumanFactory</span>()).createHuman();<br>        yellowHuman.getColor();<br>        yellowHuman.talk();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果还是相同。我们回顾一下，每一个产品类都对应了一个创建类，好处就是创建类的职责清晰，而且结构简单，但是给可扩展性和可维护性带来了一定的影响。为什么这么说呢？如果要扩展一个产品类，就需要建立一个相应的工厂类，这样就增加了扩展的难度。因为工厂类和产品类的数量相同，维护时需要考虑两个对象之间的关系。</p><p>当然，在复杂的应用中一般采用多工厂的方法，然后再增加一个协调类，避免调用者与各个子工厂交流，协调类的作用是封装子工厂类，对高层模块提供统一的访问接口。</p><h4 id="替代单例模式"><a href="#替代单例模式" class="headerlink" title="替代单例模式"></a>替代单例模式</h4><p>我们是不是可以采用工厂方法模式实现单例模式的功能呢？单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生产一个对象。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221216012622141.png" alt="工厂方法模式替代单例模式类图"></p><p>非常简单的类图，Singleton定义了一个private的无参构造函数，目的是不允许通过new的方式创建一个对象。</p><p><strong>单例类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//不允许通过new产生一个对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Singleton保证不能通过正常的渠道建立一个对象，那SingletonFactory如何建立一个单例对象呢？答案是通过反射方式创建。</p><p><strong>负责生成单例的工厂类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class cl= Class.forName(Singleton.class.getName());<br>            <span class="hljs-comment">//获得无参构造</span><br>            Constructor constructor=cl.getDeclaredConstructor();<br>            <span class="hljs-comment">//设置无参构造是可访问的</span><br>            constructor.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">//产生一个实例对象</span><br>            singleton = (Singleton)constructor.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//异常处理</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过获得类构造器，然后设置访问权限，生成一个对象，然后提供外部访问，保证内存中的对象唯一。当然，其他类也可以通过反射的方式建立一个单例对象，确实如此，但是一个项目或团队是有章程和规范的，何况已经提供了一个获得单例对象的方法，为什么还要重新创建一个新对象呢？除非是有人作恶。</p><p>以上通过工厂方法模式创建了一个单例对象，该框架可以继续扩展，在一个项目中可以产生一个单例构造器，所有需要产生单例的类都遵循一定的规则（构造方法是private），然后通过扩展该框架，只要输入一个类型就可以获得唯一的一个实例。</p><h4 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h4><p>何为延迟初始化（Lazy initialization）？一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。延迟初始化是工厂方法模式的一个扩展应用。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221216012915758.png" alt="延迟初始化的通用类图"></p><p>ProductFactory负责产品类对象的创建工作，并且通过prMap变量产生一个缓存，对需要再次被重用的对象保留。</p><p><strong>延迟加载的工厂类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String,Product&gt; prMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Product <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String type)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//如果Map中已经有这个对象</span><br>        <span class="hljs-keyword">if</span>(prMap.containsKey(type))&#123;<br>            product = prMap.get(type);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;Product1&quot;</span>))&#123;<br>            product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct1</span>();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct2</span>();<br>        &#125;<br>        <span class="hljs-comment">//同时把对象放到缓存容器中</span><br>        prMap.put(type,product);<br>        &#125;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码还比较简单，通过定义一个Map容器，容纳所有产生的对象，如果在Map容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到Map容器中，以方便下次调用。</p><p>延迟加载框架是可以扩展的，例如限制某一个产品类的最大实例化数量，可以通过判断Map中已有的对象数量来实现，这样的处理是非常有意义的，例如JDBC连接数据库，都会要求设置一个MaxConnections最大连接数量，该数量就是内存中最大实例化的数量。</p><h2 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</p><p>（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）</p><h3 id="通用类图-2"><a href="#通用类图-2" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221220001204117.png" alt="抽象工厂模式的通用类图"></p><p>抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</p><p>两个抽象的产品类可以有关系，例如共同继承或实现一个抽象类或接口。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221220001355303.png" alt="抽象工厂模式的通用源码类图"></p><h3 id="通用代码-2"><a href="#通用代码-2" class="headerlink" title="通用代码"></a>通用代码</h3><p><strong>抽象产品类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProductA</span> &#123;<br>    <span class="hljs-comment">//每个产品共有的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shareMethod</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-comment">//每个产品相同方法，不同实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个具体的产品实现类</p><p><strong>产品A1的实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProductA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;产品A1的实现方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>产品A2的实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProductA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;产品A2的实现方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>产品B与此类似，不再赘述。抽象工厂类AbstractCreator的职责是定义每个工厂要实现的功能，在通用代码中，抽象工厂类定义了两个产品族的产品创建。</p><p><strong>抽象工厂类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCreator</span> &#123;<br>    <span class="hljs-comment">//创建A产品家族</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//创建B产品家族</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractProductB <span class="hljs-title function_">createProductB</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何创建一个产品，则是由具体的实现类来完成的</p><p><strong>产品等级1的实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCreator</span> &#123;<br>    <span class="hljs-comment">//只生产产品等级为1的A产品</span><br>    <span class="hljs-keyword">public</span> AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA1</span>();<br>    &#125;<br>    <span class="hljs-comment">//只生产产品等级为1的B产品</span><br>    <span class="hljs-keyword">public</span> AbstractProductB <span class="hljs-title function_">createProductB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductB1</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>产品等级2的实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCreator</span> &#123;<br>    <span class="hljs-comment">//只生产产品等级为2的A产品</span><br>    <span class="hljs-keyword">public</span> AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA2</span>();<br>    &#125;<br>    <span class="hljs-comment">//只生产产品等级为1的B产品</span><br>    <span class="hljs-keyword">public</span> AbstractProductB <span class="hljs-title function_">createProductB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductB2</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<em>有M个产品等级就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务。</em></p><p>在具体的业务中如何产生一个与实现无关的对象呢？</p><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义出两个工厂</span><br>        <span class="hljs-type">AbstractCreator</span> <span class="hljs-variable">creator1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Creator1</span>();<br>        <span class="hljs-type">AbstractCreator</span> <span class="hljs-variable">creator2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Creator2</span>();<br>        <span class="hljs-comment">//产生A1对象</span><br>        <span class="hljs-type">AbstractProductA</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> creator1.createProductA();<br>        <span class="hljs-comment">//产生A2对象</span><br>        <span class="hljs-type">AbstractProductA</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> creator2.createProductA();<br>        <span class="hljs-comment">//产生B1对象</span><br>        <span class="hljs-type">AbstractProductB</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> creator1.createProductB();<br>        <span class="hljs-comment">//产生B2对象</span><br>        <span class="hljs-type">AbstractProductB</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> creator2.createProductB();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 然后在这里就可以为所欲为了...</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在场景类中，没有任何一个方法与实现类有关系，对于一个产品来说，我们只要知道它的工厂方法就可以直接产生一个产品对象，无须关心它的实现类。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li><p>封装性，每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。</p></li><li><p>产品族内的约束为非公开状态。例如生产男女比例的问题上，猜想女娲娘娘肯定有自己的打算，不能让女盛男衰，否则女性的优点不就体现不出来了吗？那在抽象工厂模式，就应该有这样的一个约束：每生产1个女性，就同时生产出1.2个男性，这样的生产过程对调用工厂类的高层模块来说是透明的，它不需要知道这个约束，我就是要一个黄色女性产品就可以了，具体的产品族内的约束是在工厂内实现的。</p></li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>抽象工厂模式的最大缺点就是产品族扩展非常困难，为什么这么说呢？我们以通用代码为例，如果要增加一个产品C，也就是说产品家族由原来的2个增加到3个，看看我们的程序有多大改动吧！抽象类<code>AbstractCreator</code>要增加一个方法<code>createProductC()</code>，然后两个实现类都要修改，想想看，这严重违反了开闭原则，而且我们一直说明抽象类和接口是一个契约。改变契约，所有与契约有关系的代码都要修改，那么这段代码叫什么？叫“有毒代码”，——只要与这段代码有关系，就可能产生侵害的危险！</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>抽象工厂模式的使用场景定义非常简单：一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式。什么意思呢？例如一个文本编辑器和一个图片处理器，都是软件实体，但是* nix下的文本编辑器和Windows下的文本编辑器虽然功能和界面都相同，但是代码实现是不同的，图片处理器也有类似情况。也就是具有了共同的约束条件：操作系统类型。于是我们可以使用抽象工厂模式，产生不同操作系统下的编辑器和图片处理器</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>在抽象工厂模式的缺点中，我们提到抽象工厂模式的产品族扩展比较困难，但是一定要清楚，是产品族扩展困难，而不是产品等级。在该模式下，产品等级是非常容易扩展的，增加一个产品等级，只要增加一个工厂类负责新增加出来的产品生产任务即可。也就是说横向扩展容易，纵向扩展困难。以人类为例子，产品等级中只有男、女两个性别，现实世界还有一种性别：双性人，既是男人也是女人（俗语就是阴阳人），那我们要扩展这个产品等级也是非常容易的，增加三个产品类，分别对应不同的肤色，然后再创建一个工厂类，专门负责不同肤色人的双性人的创建任务，完全通过扩展来实现需求的变更，从这一点上看，抽象工厂模式是符合开闭原则的。</p><h2 id="四、模板方法模式"><a href="#四、模板方法模式" class="headerlink" title="四、模板方法模式"></a>四、模板方法模式</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p><p>（定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。）</p><h3 id="通用类图-3"><a href="#通用类图-3" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221220002838297.png" alt="模板方法模式的通用类图"></p><p>模板方法模式确实非常简单，仅仅使用了Java的继承机制，但它是一个应用非常广泛的模式。其中，AbstractClass叫做抽象模板，它的方法分为两类：</p><ul><li>基本方法：基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。</li><li>模板方法：可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。</li></ul><p>注意：<em>为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。</em></p><p>在类图中还有一个角色：具体模板。ConcreteClass1和ConcreteClass2属于具体模板，实现父类所定义的一个或多个抽象方法，也就是父类定义的基本方法在子类中得以实现。</p><h3 id="通用代码-3"><a href="#通用代码-3" class="headerlink" title="通用代码"></a>通用代码</h3><p><strong>抽象模板类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-comment">//基本方法</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//基本方法</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAnything</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//模板方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 调用基本方法，完成相关的逻辑</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-built_in">this</span>.doAnything();<br>        <span class="hljs-built_in">this</span>.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体模板类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-comment">//实现基本方法</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAnything</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-comment">//实现基本方法</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAnything</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AbstractClass</span> <span class="hljs-variable">class1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteClass1</span>();<br>        <span class="hljs-type">AbstractClass</span> <span class="hljs-variable">class2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteClass2</span>();<br>        <span class="hljs-comment">//调用模板方法</span><br>        class1.templateMethod();<br>        class2.templateMethod();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<em>抽象模板中的基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露的属性或方法尽量不要设置为protected类型。实现类若非必要，尽量不要扩大父类中的访问权限。</em></p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li><p>封装不变部分，扩展可变部分：把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。</p></li><li><p>提取公共部分代码，便于维护。</p></li><li><p>行为由父类控制，子类实现：基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。</p></li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。</p><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>多个子类有公有的方法，并且逻辑基本相同时。</p></li><li><p>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</p></li><li><p>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为。</p></li></ul><h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><p>以悍马车模型为例：</p><p>客户提出H1型号的悍马喇叭想让它响就响，H2型号的喇叭不要有声音。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221220003502027.png" alt="扩展悍马车模类图"></p><p>在抽象类HummerModel中增加了一个实现方法isAlarm，确定各个型号的悍马是否需要声音，由各个实现类覆写该方法，同时其他的基本方法由于不需要对外提供访问，因此也设计为protected类型。</p><p><strong>扩展后的抽象模板类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HummerModel</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 首先，这个模型要能够被发动起来，别管是手摇发动，还是电力发动，反正</span><br><span class="hljs-comment">    * 是要能够发动起来，那这个实现要在实现类里了</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//能发动，还要能停下来，那才是真本事</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//喇叭会出声音，是滴滴叫，还是哔哔叫</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//引擎会轰隆隆的响，不响那是假的</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">engineBoom</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//那模型应该会跑吧，别管是人推的，还是电力驱动，总之要会跑</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//先发动汽车</span><br>        <span class="hljs-built_in">this</span>.start();<br>        <span class="hljs-comment">//引擎开始轰鸣</span><br>        <span class="hljs-built_in">this</span>.engineBoom();<br>        <span class="hljs-comment">//要让它叫的就是就叫，喇嘛不想让它响就不响</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.isAlarm())&#123;<br>            <span class="hljs-built_in">this</span>.alarm();<br>        &#125;<br>        <span class="hljs-comment">//到达目的地就停车</span><br>        <span class="hljs-built_in">this</span>.stop();<br>    &#125;<br>    <span class="hljs-comment">//钩子方法，默认喇叭是会响的</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlarm</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在抽象类中，isAlarm是一个实现方法。其作用是模板方法根据其返回值决定是否要响喇叭，子类可以覆写该返回值，由于H1型号的喇叭是想让它响就响，不想让它响就不响，由人控制。</p><p><strong>扩展后的H1悍马：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HummerH1Model</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HummerModel</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">alarmFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//要响喇叭</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;悍马H1鸣笛...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">engineBoom</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;悍马H1引擎声音是这样的...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;悍马H1发动...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;悍马H1停车...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlarm</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.alarmFlag;<br>    &#125;<br>    <span class="hljs-comment">//要不要响喇叭，是由客户来决定的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAlarm</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isAlarm)</span>&#123;<br>        <span class="hljs-built_in">this</span>.alarmFlag = isAlarm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要调用H1型号的悍马，默认是有喇叭响的，当然你可以不让喇叭响，通过isAlarm(false)就可以实现。H2型号的悍马是没有喇叭声响的。</p><p><strong>扩展后的H2悍马：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HummerH2Model</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HummerModel</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;悍马H2鸣笛...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">engineBoom</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;悍马H2引擎声音是这样的...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;悍马H2发动...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;悍马H2停车...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//默认没有喇叭的</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlarm</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>H2型号的悍马设置isAlarm()的返回值为false，也就是关闭了喇叭功能。</p><p><strong>扩展后的场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;-------H1型号悍马--------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;H1型号的悍马是否需要喇叭声响？0-不需要 1-需要&quot;</span>);<br>        String type=(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in))).readLine();<br>        <span class="hljs-type">HummerH1Model</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HummerH1Model</span>();<br>        <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>            h1.setAlarm(<span class="hljs-literal">false</span>);<br>        &#125;<br>        h1.run();<br>        System.out.println(<span class="hljs-string">&quot;\n-------H2型号悍马--------&quot;</span>);<br>        <span class="hljs-type">HummerH2Model</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HummerH2Model</span>();<br>        h2.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到没，H1型号的悍马是由客户自己控制是否要响喇叭，也就是说外界条件改变，影响到模板方法的执行。在我们的抽象类中isAlarm的返回值就是影响了模板方法的执行结</p><p>果，该方法就叫做钩子方法（Hook Method）。</p><h2 id="五、建造者模式"><a href="#五、建造者模式" class="headerlink" title="五、建造者模式"></a>五、建造者模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>Separate the construction of a complex object from its representation so that the same construction process can create different representations.</p><p>（将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。）</p><h3 id="通用类图-4"><a href="#通用类图-4" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221220004404110.png" alt="建造者模式通用类图"></p><p>在建造者模式中，有如下4个角色：</p><ul><li>Product产品类：通常是实现了模板方法模式，也就是有模板方法和基本方法。</li><li>Builder抽象建造者：规范产品的组建，一般是由子类实现。</li><li>ConcreteBuilder具体建造者：实现抽象类定义的所有方法，并且返回一个组建好的对象。</li><li>Director导演类：负责安排已有模块的顺序，然后告诉Builder开始建造。</li></ul><h3 id="通用代码-4"><a href="#通用代码-4" class="headerlink" title="通用代码"></a>通用代码</h3><p><strong>产品类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//独立业务处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抽象建造者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-comment">//设置产品的不同部分，以获得不同的产品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPart</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//建造产品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title function_">buildProduct</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，setPart方法是零件的配置，什么是零件？其他的对象，获得一个不同零件，或者不同的装配顺序就可能产生不同的产品。</p><p><strong>具体建造者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>    <span class="hljs-comment">//设置产品零件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPart</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 产品类内的逻辑处理</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>    <span class="hljs-comment">//组建一个产品</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">buildProduct</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，如果有多个产品类就有几个具体的建造者，而且这多个产品类具有相同接口或抽象类。</p><p><strong>导演类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct</span>();<br>    <span class="hljs-comment">//构建不同的产品</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getAProduct</span><span class="hljs-params">()</span>&#123;<br>        builder.setPart();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 设置不同的零件，产生不同的产品</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">return</span> builder.buildProduct();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。</p><p>当然，在建造者模式比较庞大时，导演类可以有多个。</p><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul><li>封装性：使用建造者模式可以使客户端不必知道产品内部组成的细节。</li><li>建造者独立，容易扩展</li><li>便于控制细节风险：由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</li></ul><h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。</li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。</li><li>在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大不同的地方，虽然同为创建类模式，但是注重点不同。</p><h2 id="六、代理模式"><a href="#六、代理模式" class="headerlink" title="六、代理模式"></a>六、代理模式</h2><p>略</p><h2 id="七、原型模式"><a href="#七、原型模式" class="headerlink" title="七、原型模式"></a>七、原型模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.</p><p>（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。）</p><h3 id="通用类图-5"><a href="#通用类图-5" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221221000351265.png" alt="原型模式的通用类图"></p><p>简单，太简单了！原型模式的核心是一个clone方法，通过该方法进行对象的拷贝，Java提供了一个Cloneable接口来标示这个对象是可拷贝的，为什么说是“标示”呢？翻开JDK的帮助看看Cloneable是一个方法都没有的，这个接口只是一个标记作用，在JVM中具有这个标记的对象才有可能被拷贝。那怎么才能从“有可能被拷贝”转换为“可以被拷贝”呢？方法是覆盖clone()方法，是的，你没有看错是重写clone()方法。</p><h3 id="通用代码-5"><a href="#通用代码-5" class="headerlink" title="通用代码"></a>通用代码</h3><p><strong>原型模式通用源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrototypeClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-comment">//覆写父类Object方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PrototypeClass <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">PrototypeClass</span> <span class="hljs-variable">prototypeClass</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            prototypeClass = (PrototypeClass)<span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-comment">//异常处理</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> prototypeClass;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现一个接口，然后重写clone方法，就完成了原型模式！</p><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ul><li>性能优良：原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</li><li>逃避构造函数的约束：这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的（参见13.4节）。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。</li></ul><h3 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>资源优化场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li><li>性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li><li>一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li></ul><p>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。</p><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>构造函数不会被执行</strong></li></ol><p>Object类的clone方法的原理是从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块，那构造函数没有被执行也是非常正常的了。</p><ol start="2"><li><strong>浅拷贝和深拷贝</strong></li></ol><p>Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。确实是非常浅，两个对象共享了一个私有变量，你改我改大家都能改，是一种非常不安全的方式。</p><p>注意：<em>使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变对象。</em></p><ol start="3"><li><strong>clone与final两个冤家</strong></li></ol><p>对象的clone与对象内的final关键字是有冲突的。</p><p>要使用clone方法，类的成员变量上不要增加final关键字。</p><h2 id="八、中介者模式"><a href="#八、中介者模式" class="headerlink" title="八、中介者模式"></a>八、中介者模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.</p><p>（用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。）</p><h3 id="通用类图-6"><a href="#通用类图-6" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221221002422842.png" alt="中介者模式通用类图"></p><p>从类图中看，中介者模式由以下几部分组成：</p><ul><li>Mediator 抽象中介者角色：抽象中介者角色定义统一的接口，用于各同事角色之间的通信。</li><li>Concrete Mediator 具体中介者角色：具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。</li><li>Colleague 同事角色：每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为（Self-Method），与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method）。</li></ul><h3 id="通用代码-6"><a href="#通用代码-6" class="headerlink" title="通用代码"></a>通用代码</h3><p>中介者模式比较简单，其通用源码也比较简单</p><p><strong>通用抽象中介者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-comment">//定义同事类</span><br>    <span class="hljs-keyword">protected</span> ConcreteColleague1 c1;<br>    <span class="hljs-keyword">protected</span> ConcreteColleague2 c2;<br>    <span class="hljs-comment">//通过getter/setter方法把同事类注入进来</span><br>    <span class="hljs-keyword">public</span> ConcreteColleague1 <span class="hljs-title function_">getC1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> c1;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setC1</span><span class="hljs-params">(ConcreteColleague1 c1)</span> &#123;<br>        <span class="hljs-built_in">this</span>.c1 = c1;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ConcreteColleague2 <span class="hljs-title function_">getC2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> c2;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setC2</span><span class="hljs-params">(ConcreteColleague2 c2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.c2 = c2;<br>    &#125;<br>    <span class="hljs-comment">//中介者模式的业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Mediator抽象类中我们只定义了同事类的注入，为什么使用同事实现类注入而不使用抽象类注入呢？那是因为同事类虽然有抽象，但是没有每个同事类必须要完成的业务方法，当然如果每个同事类都有相同的方法，比如execute、handler等，那当然注入抽象类，做到依赖倒置。</p><p>具体的中介者一般只有一个，即通用中介者：</p><p><strong>通用中介者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//调用同事类的方法，只要是public方法都可以调用</span><br>        <span class="hljs-built_in">super</span>.c1.selfMethod1();<br>        <span class="hljs-built_in">super</span>.c2.selfMethod2();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.c1.selfMethod1();<br>        <span class="hljs-built_in">super</span>.c2.selfMethod2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中介者所具有的方法doSomething1和doSomething2都是比较复杂的业务逻辑，为同事类服务，其实现是依赖各个同事类来完成的。</p><p><strong>抽象同事类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span> &#123;<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Colleague</span><span class="hljs-params">(Mediator _mediator)</span>&#123;<br>        <span class="hljs-built_in">this</span>.mediator = _mediator;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个基类也非常简单。一般来说，中介者模式中的抽象都比较简单，是为了建立这个中介而服务的。</p><p><strong>具体同事类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;<br>    <span class="hljs-comment">//通过构造函数传递中介者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague1</span><span class="hljs-params">(Mediator _mediator)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_mediator);<br>    &#125;<br>    <span class="hljs-comment">//自有方法 self-method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selfMethod1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//处理自己的业务逻辑</span><br>    &#125;<br>    <span class="hljs-comment">//依赖方法 dep-method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">depMethod1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//处理自己的业务逻辑</span><br>        <span class="hljs-comment">//自己不能处理的业务逻辑，委托给中介者处理</span><br>        <span class="hljs-built_in">super</span>.mediator.doSomething1();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;<br>    <span class="hljs-comment">//通过构造函数传递中介者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague2</span><span class="hljs-params">(Mediator _mediator)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_mediator);<br>    &#125;<br>    <span class="hljs-comment">//自有方法 self-method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selfMethod2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//处理自己的业务逻辑</span><br>    &#125;<br>    <span class="hljs-comment">//依赖方法 dep-method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">depMethod2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//处理自己的业务逻辑</span><br>        <span class="hljs-comment">//自己不能处理的业务逻辑，委托给中介者处理</span><br>        <span class="hljs-built_in">super</span>.mediator.doSomething2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么同事类要使用构造函数注入中介者，而中介者使用getter&#x2F;setter方式注入同事类呢？这是因为同事类必须有中介者，而中介者却可以只有部分同事类。</p><h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><p>中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p><h3 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h3><p>中介者模式简单，但是简单不代表容易使用，很容易被误用。在面向对象的编程中，对象和对象之间必然会有依赖关系，如果某个类和其他类没有任何相互依赖的关系，那这个类就是一个“孤岛”，在项目中就没有存在的必要了！就像是某个人如果永远独立生活，与任何人都没有关系，那这个人基本上就算是野人了——排除在人类这个定义之外。</p><p>类之间的依赖关系是必然存在的，一个类依赖多个类的情况也是存在的，存在即合理，那是否可以说只要有多个依赖关系就考虑使用中介者模式呢？答案是否定的。中介者模式未必能帮你把原本凌乱的逻辑整理得清清楚楚，而且中介者模式也是有缺点的，这个缺点在使用不当时会被放大，比如原本就简单的几个对象依赖关系，如果为了使用模式而加入了中介者，必然导致中介者的逻辑复杂化，因此中介者模式的使用需要“量力而行”！中介者模式适用于多个对象之间紧密耦合的情况，紧密耦合的标准是：在类图中出现了蜘蛛网状结构。在这种情况下一定要考虑使用中介者模式，这有利于把蜘蛛网梳理为星型结构，使原本复杂混乱的关系变得清晰简单。</p><p>大家可以在如下的情况下尝试使用中介者模式：</p><ul><li>N个对象之间产生了相互的依赖关系（N＞2）。</li><li>多个对象有依赖关系，但是依赖的行为尚不确定或者有发生改变的可能，在这种情况下一般建议采用中介者模式，降低变更引起的风险扩散。</li><li>产品开发。一个明显的例子就是MVC框架，把中介者模式应用到产品中，可以提升产品的性能和扩展性，但是对于项目开发就未必，因为项目是以交付投产为目标，而产品则是以稳定、高效、扩展为宗旨。</li></ul><h2 id="九、命令模式"><a href="#九、命令模式" class="headerlink" title="九、命令模式"></a>九、命令模式</h2><p>命令模式是一个高内聚的模式</p><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests,and support undoable operations.</p><p>（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。）</p><h3 id="通用类图-7"><a href="#通用类图-7" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221221004118713.png" alt="命令模式的通用类图"></p><p>在该类图中，我们看到三个角色：</p><ul><li>Receive接收者角色：该角色就是干活的角色，命令传递到这里是应该被执行的。</li><li>Command命令角色：需要执行的所有命令都在这里声明。</li><li>Invoker调用者角色：接收到命令，并执行命令。</li></ul><h3 id="通用代码-7"><a href="#通用代码-7" class="headerlink" title="通用代码"></a>通用代码</h3><p>命令模式比较简单，但是在项目中非常频繁地使用，因为它的封装性非常好，把请求方（Invoker）和执行方（Receiver）分开了，扩展性也有很好的保障，通用代码比较简单。</p><p><strong>通用Receiver类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>    <span class="hljs-comment">//抽象接收者，定义每个接收者都必须完成的业务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>很奇怪，为什么Receiver是一个抽象类？那是因为接收者可以有多个，有多个就需要定义一个所有特性的抽象集合——抽象的接收者。</p><p><strong>具体的Receiver类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteReciver1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Receiver</span>&#123;<br>    <span class="hljs-comment">//每个接收者都必须处理一定的业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteReciver2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Receiver</span>&#123;<br>    <span class="hljs-comment">//每个接收者都必须处理一定的业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接收者可以是N个，这要依赖业务的具体定义。命令角色是命令模式的核心。</p><p><strong>抽象的Command类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-comment">//每个命令类都必须有一个执行命令的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据环境的需求，具体的命令类也可以有N个。</p><p><strong>具体的Command类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommand1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-comment">//对哪个Receiver类进行命令处理</span><br>    <span class="hljs-keyword">private</span> Receiver receiver;<br>    <span class="hljs-comment">//构造函数传递接收者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteCommand1</span><span class="hljs-params">(Receiver _receiver)</span>&#123;<br>        <span class="hljs-built_in">this</span>.receiver = _receiver;<br>    &#125;<br>    <span class="hljs-comment">//必须实现一个命令</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//业务处理</span><br>        <span class="hljs-built_in">this</span>.receiver.doSomething();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommand2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-comment">//哪个Receiver类进行命令处理</span><br>    <span class="hljs-keyword">private</span> Receiver receiver;<br>    <span class="hljs-comment">//构造函数传递接收者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteCommand2</span><span class="hljs-params">(Receiver _receiver)</span>&#123;<br>        <span class="hljs-built_in">this</span>.receiver = _receiver;<br>    &#125;<br>    <span class="hljs-comment">//必须实现一个命令</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//业务处理</span><br>        <span class="hljs-built_in">this</span>.receiver.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了两个具体的命令类，读者可以在实际应用中扩展该命令类。在每个命令类中，通过构造函数定义了该命令是针对哪一个接收者发出的，定义一个命令接收的主体。</p><p><strong>调用者Invoker类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;<br>    <span class="hljs-keyword">private</span> Command command;<br>    <span class="hljs-comment">//受气包，接受命令</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command _command)</span>&#123;<br>        <span class="hljs-built_in">this</span>.command = _command;<br>    &#125;<br>    <span class="hljs-comment">//执行命令</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.command.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用者就像是一个受气包，不管什么命令，都要接收、执行！</p><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//首先声明调用者Invoker</span><br>        <span class="hljs-type">Invoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();<br>        <span class="hljs-comment">//定义接收者</span><br>        <span class="hljs-type">Receiver</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteReciver1</span>();<br>        <span class="hljs-comment">//定义一个发送给接收者的命令</span><br>        <span class="hljs-type">Command</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommand1</span>(receiver);<br>        <span class="hljs-comment">//把命令交给调用者去执行</span><br>        invoker.setCommand(command);<br>        invoker.action();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个完整的命令模式就此完成，读者可以在此基础上进行扩展。</p><h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><ul><li>类间解耦</li></ul><p>调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。</p><ul><li>可扩展性</li></ul><p>Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。</p><ul><li>命令模式结合其他模式会更优秀</li></ul><p>命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。</p><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项目中慎重考虑使用。</p><h3 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h3><p>只要你认为是命令的地方就可以采用命令模式，例如，在GUI开发中，一个按钮的点击是一个命令，可以采用命令模式；模拟DOS命令的时候，当然也要采用命令模式；触发－反馈机制的处理等。</p><h2 id="十、责任链模式"><a href="#十、责任链模式" class="headerlink" title="十、责任链模式"></a>十、责任链模式</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it.</p><p>（使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。）</p><h3 id="通用类图-8"><a href="#通用类图-8" class="headerlink" title="通用类图"></a>通用类图</h3><p>责任链模式的重点是在“链”上，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221229231223157.png" alt="责任链模式通用类图"></p><h3 id="通用代码-8"><a href="#通用代码-8" class="headerlink" title="通用代码"></a>通用代码</h3><p>责任链模式的核心在“链”上，“链”是由多个处理者ConcreteHandler组成的，我们先来看抽象Handler类。</p><p><strong>抽象处理者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">private</span> Handler nextHandler;<br>    <span class="hljs-comment">//每个处理者都必须对请求做出处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Response <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Request request)</span>&#123;<br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//判断是否是自己的处理级别</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.getHandlerLevel().equals(request.getRequestLevel()))&#123;<br>            response = <span class="hljs-built_in">this</span>.echo(request);<br>        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//不属于自己的处理级别</span><br>            <span class="hljs-comment">//判断是否有下一个处理者</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.nextHandler != <span class="hljs-literal">null</span>)&#123;<br>            response = <span class="hljs-built_in">this</span>.nextHandler.handleMessage(request);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//没有适当的处理者，业务自行处理</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>    <span class="hljs-comment">//设置下一个处理者是谁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(Handler _handler)</span>&#123;<br>        <span class="hljs-built_in">this</span>.nextHandler = _handler;<br>    &#125;<br>    <span class="hljs-comment">//每个处理者都有一个处理级别</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Level <span class="hljs-title function_">getHandlerLevel</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//每个处理者都必须实现处理任务</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Response <span class="hljs-title function_">echo</span><span class="hljs-params">(Request request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象的处理者实现三个职责：</p><p>一是定义一个请求的处理方法<code>handleMessage</code>，唯一对外开放的方法；</p><p>二是定义一个链的编排方法<code>setNext</code>，设置下一个处理者；</p><p>三是定义了具体的请求者必须实现的两个方法：定义自己能够处理的级别<code>getHandlerLevel</code>和具体的处理任务<code>echo</code>。</p><p>我们定义三个具体的处理者，以便可以组成一个链。</p><p><strong>具体处理者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-comment">//定义自己的处理逻辑</span><br>    <span class="hljs-keyword">protected</span> Response <span class="hljs-title function_">echo</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">//完成处理逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//设置自己的处理级别</span><br>    <span class="hljs-keyword">protected</span> Level <span class="hljs-title function_">getHandlerLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置自己的处理级别</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-comment">//定义自己的处理逻辑</span><br>    <span class="hljs-keyword">protected</span> Response <span class="hljs-title function_">echo</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">//完成处理逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//设置自己的处理级别</span><br>    <span class="hljs-keyword">protected</span> Level <span class="hljs-title function_">getHandlerLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置自己的处理级别</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-comment">//定义自己的处理逻辑</span><br>    <span class="hljs-keyword">protected</span> Response <span class="hljs-title function_">echo</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">//完成处理逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//设置自己的处理级别</span><br>    <span class="hljs-keyword">protected</span> Level <span class="hljs-title function_">getHandlerLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置自己的处理级别</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在处理者中涉及三个类：</p><p>Level类负责定义请求和处理级别，Request类负责封装请求，Response负责封装链中返回的结果。</p><p><strong>模式中有关框架代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Level</span> &#123;<br>    <span class="hljs-comment">//定义一个请求和处理等级</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Request</span> &#123;<br>    <span class="hljs-comment">//请求的等级</span><br>    <span class="hljs-keyword">public</span> Level <span class="hljs-title function_">getRequestLevel</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Response</span> &#123;<br>    <span class="hljs-comment">//处理者返回的数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在场景类或高层模块中对链进行组装，并传递请求，返回结果。</p><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//声明所有的处理节点</span><br>        <span class="hljs-type">Handler</span> <span class="hljs-variable">handler1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler1</span>();<br>        <span class="hljs-type">Handler</span> <span class="hljs-variable">handler2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler2</span>();<br>        <span class="hljs-type">Handler</span> <span class="hljs-variable">handler3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler3</span>();<br>        <span class="hljs-comment">//设置链中的阶段顺序1--&gt;2--&gt;3</span><br>        handler1.setNext(handler2);<br>        handler2.setNext(handler3);<br>        <span class="hljs-comment">//提交请求，返回结果</span><br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> handler1.handlerMessage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h3><p>责任链模式非常显著的优点是将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌（例如在J2EE项目开发中，可以剥离出无状态Bean由责任链处理），两者解耦，提高系统的灵活性。</p><h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p>责任链有两个非常显著的缺点：一是性能问题，每个请求都是从链头遍历到链尾，特别是在链比较长的时候，性能是一个非常大的问题。二是调试不很方便，特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。</p><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><p>链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免无意识地破坏系统性能。</p><h2 id="十一、装饰模式"><a href="#十一、装饰模式" class="headerlink" title="十一、装饰模式"></a>十一、装饰模式</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>装饰模式（Decorator Pattern）是一种比较常见的模式，其定义如下：</p><p>Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.</p><p>（动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。）</p><h3 id="通用类图-9"><a href="#通用类图-9" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221229231253498.png" alt="装饰模式的通用类图"></p><h3 id="通用代码-9"><a href="#通用代码-9" class="headerlink" title="通用代码"></a>通用代码</h3><p>在类图中，有四个角色需要说明：</p><ul><li><strong>Component抽象构件</strong></li></ul><p>Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。</p><p>注意：<em>在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当Component抽象构件。</em></p><ul><li><strong>ConcreteComponent 具体构件</strong></li></ul><p>ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。</p><ul><li><strong>Decorator装饰角色</strong></li></ul><p>一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。</p><ul><li><strong>具体装饰角色</strong></li></ul><p>ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西</p><p><strong>抽象构件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-comment">//抽象的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体构件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-comment">//具体实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;do Something&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>装饰角色通常是一个抽象类</p><p><strong>抽象装饰者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Component</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//通过构造函数传递被修饰者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Component _component)</span>&#123;<br>        <span class="hljs-built_in">this</span>.component = _component;<br>    &#125;<br>    <span class="hljs-comment">//委托给被修饰者执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.component.operate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然了，若只有一个装饰类，则可以没有抽象装饰角色，直接实现具体的装饰角色即可。</p><p><strong>具体的装饰类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <span class="hljs-comment">//定义被修饰者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator1</span><span class="hljs-params">(Component _component)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_component);<br>    &#125;<br>    <span class="hljs-comment">//定义自己的修饰方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;method1 修饰&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//重写父类的Operation方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.method1();<br>        <span class="hljs-built_in">super</span>.operate();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <span class="hljs-comment">//定义被修饰者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator2</span><span class="hljs-params">(Component _component)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_component);<br>    &#125;<br>    <span class="hljs-comment">//定义自己的修饰方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;method2修饰&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//重写父类的Operation方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">super</span>.operate();<br>        <span class="hljs-built_in">this</span>.method2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteComponent</span>();<br>        <span class="hljs-comment">//第一次修饰</span><br>        component = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecorator1</span>(component);<br>        <span class="hljs-comment">//第二次修饰</span><br>        component = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecorator2</span>(component);<br>        <span class="hljs-comment">//修饰后运行</span><br>        component.operate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h3><ul><li><p>装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。</p></li><li><p>装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。</p></li><li><p>装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如此。</p></li></ul><h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><p>对于装饰模式记住一点就足够了：多层的装饰是比较复杂的。为什么会复杂呢？你想想看，就像剥洋葱一样，你剥到了最后才发现是最里层的装饰出现了问题，想象一下工作量吧，因此，尽量减少装饰类的数量，以便降低系统的复杂度。</p><h3 id="使用场景-8"><a href="#使用场景-8" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>需要扩展一个类的功能，或给一个类增加附加功能。</li><li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</li><li>需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</li></ul><h2 id="十二、策略模式"><a href="#十二、策略模式" class="headerlink" title="十二、策略模式"></a>十二、策略模式</h2><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>Define a family of algorithms,encapsulate each one,and make them interchangeable.</p><p>（定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。）</p><h3 id="通用类图-10"><a href="#通用类图-10" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221229231320982.png" alt="策略模式通用类图"></p><h3 id="通用代码-10"><a href="#通用代码-10" class="headerlink" title="通用代码"></a>通用代码</h3><p>策略模式使用的就是面向对象的继承和多态机制，非常容易理解和掌握，我们再来看看策略模式的三个角色：</p><ul><li><strong>Context封装角色</strong></li></ul><p>它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</p><ul><li><strong>Strategy抽象策略角色</strong></li></ul><p>策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。</p><ul><li><strong>ConcreteStrategy具体策略角色</strong></li></ul><p>实现抽象策略中的操作，该类含有具体的算法。</p><p><strong>抽象的策略角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-comment">//策略模式的运算法则</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体策略也是非常普通的一个实现类，只要实现接口中的方法就可以。</p><p><strong>具体策略角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategy1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体策略1的运算法则&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategy2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体策略2的运算法则&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>策略模式的重点就是封装角色，它是借用了代理模式的思路，大家可以想想，它和代理模式有什么差别，差别就是策略模式的封装角色和被封装的策略类不用是同一个接口，如果是同一个接口那就成为了代理模式。</p><p><strong>封装角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-comment">//抽象策略</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Strategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//构造函数设置具体策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(Strategy _strategy)</span>&#123;<br>        <span class="hljs-built_in">this</span>.strategy = _strategy;<br>    &#125;<br>    <span class="hljs-comment">//封装后的策略方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAnythinig</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.strategy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>高层模块的调用非常简单，知道要用哪个策略，产生出它的对象，然后放到封装角色中就完成任务了。</p><p><strong>高层模块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//声明一个具体的策略</span><br>        <span class="hljs-type">Strategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategy1</span>();<br>        <span class="hljs-comment">//声明上下文对象</span><br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(strategy);<br>        <span class="hljs-comment">//执行封装后的方法</span><br>        context.doAnythinig();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h3><ul><li>算法可以自由切换</li></ul><p>这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略。</p><ul><li>避免使用多重条件判断</li></ul><p>如果没有策略模式，我们想想看会是什么样子？一个策略家族有5个策略算法，一会要使用A策略，一会要使用B策略，怎么设计呢？使用多重的条件语句？多重条件语句不易维护，而且出错的概率大大增强。使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。</p><ul><li>扩展性良好</li></ul><p>这甚至都不用说是它的优点，因为它太明显了。在现有的系统中增加一个策略太容易了，只要实现接口就可以了，其他都不用修改，类似于一个可反复拆卸的插件，这大大地符合了OCP原则。</p><h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><ul><li>策略类数量增多</li></ul><p>每一个策略都是一个类，复用的可能性很小，类数量增多。</p><ul><li>所有的策略类都需要对外暴露</li></ul><p>上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢？那要你的封装类还有什么意义？这是原装策略模式的一个缺点，幸运的是，我们可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式。</p><h3 id="使用场景-9"><a href="#使用场景-9" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多个类只有在算法或行为上稍有不同的场景</li><li>算法需要自由切换的场景。</li><li>需要屏蔽算法规则的场景。</li></ul><h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统维护就会成为一个烫手山芋，谁都不想接。</p><h2 id="十三、适配器模式"><a href="#十三、适配器模式" class="headerlink" title="十三、适配器模式"></a>十三、适配器模式</h2><h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>Convert the interface of a class into another interface clients expect.Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.</p><p>（将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。）</p><h3 id="通用类图-11"><a href="#通用类图-11" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221229231345209.png" alt="适配器模式通用类图"></p><h3 id="通用代码-11"><a href="#通用代码-11" class="headerlink" title="通用代码"></a>通用代码</h3><ul><li><p><strong>Target目标角色</strong></p><p>该角色定义把其他类转换为何种接口，也就是我们的期望接口</p></li><li><p><strong>Adaptee源角色</strong></p><p>你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。</p></li><li><p><strong>Adapter适配器角色</strong></p><p>适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建</p><p>立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方</p><p>式。</p></li></ul><p><strong>目标角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">//目标角色有自己的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>目标角色是一个已经在正式运行的角色，你不可能去修改角色中的方法，你能做的就是如何去实现接口中的方法，而且通常情况下，目标角色是一个接口或者是抽象类，一般不会是实现类。</p><p><strong>目标角色的实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteTarget</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;if you need any help,pls call me!&quot;</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源角色也是已经在服役状态（当然，非要新建立一个源角色，然后套用适配器模式，那也没有任何问题），它是一个正常的类</p><p><strong>源角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>    <span class="hljs-comment">//原有的业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m kind of busy,leave me alone,pls!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>适配器角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//原有的业务逻辑</span><br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteTarget</span>();<br>        target.request();<br>        <span class="hljs-comment">//现在增加了适配器角色后的业务逻辑</span><br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>();<br>        target2.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h3><ul><li><p>适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。</p></li><li><p>增加了类的透明性</p><p>想想看，我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块是透明的，也是它不需要关心的。</p></li><li><p>提高了类的复用度</p><p>当然了，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演员。</p></li><li><p>灵活性非常好</p><p>某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。</p></li></ul><h3 id="使用场景-10"><a href="#使用场景-10" class="headerlink" title="使用场景"></a>使用场景</h3><p>适配器应用的场景只要记住一点就足够了：你有动机修改一个已经投产中的接口时，适配器模式可能是最适合你的模式。比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口，怎么办？使用适配器模式，这也是我们例子中提到的。</p><h3 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h3><p>适配器模式最好在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题，而是解决正在服役的项目问题，没有一个系统分析师会在做详细设计的时候考虑使用适配器模式，这个模式使用的主要场景是扩展应用中。</p><h2 id="十四、迭代器模式"><a href="#十四、迭代器模式" class="headerlink" title="十四、迭代器模式"></a>十四、迭代器模式</h2><h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>迭代器模式（Iterator Pattern）目前已经是一个没落的模式，基本上没人会单独写一个迭代器，除非是产品性质的开发，其定义如下：</p><p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p><p>（它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。）</p><h3 id="通用类图-12"><a href="#通用类图-12" class="headerlink" title="通用类图"></a>通用类图</h3><p>迭代器是为容器服务的，那什么是容器呢？ 能容纳对象的所有类型都可以称之为容器，例如Collection集合类型、Set类型等，迭代器模式就是为解决遍历这些容器中的元素而诞生的。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230103234005229.png" alt="迭代器模式的通用类图"></p><h3 id="通用代码-12"><a href="#通用代码-12" class="headerlink" title="通用代码"></a>通用代码</h3><p>迭代器模式提供了遍历容器的方便性，容器只要管理增减元素就可以了，需要遍历时交由迭代器进行。迭代器模式正是由于使用得太频繁，所以大家才会忽略，我们来看看迭代器模式中的各个角色：</p><ul><li><p><strong>Iterator抽象迭代器</strong></p><p>抽象迭代器负责定义访问和遍历元素的接口，而且基本上是有固定的3个方法：first()获得第一个元素，next()访问下一个元素，isDone()是否已经访问到底部（Java叫做hasNext()方法）。</p></li><li><p><strong>ConcreteIterator具体迭代器</strong></p><p>具体迭代器角色要实现迭代器接口，完成容器元素的遍历。</p></li><li><p><strong>Aggregate抽象容器</strong></p><p>容器角色负责提供创建具体迭代器角色的接口，必然提供一个类似createIterator()这样的方法，在Java中一般是iterator()方法。</p></li><li><p><strong>Concrete Aggregate具体容器</strong></p><p>具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。</p></li></ul><p><strong>抽象迭代器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-comment">//遍历到下一个元素</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//是否已经遍历到尾部</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//删除当前指向的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体迭代器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Vector</span> <span class="hljs-variable">vector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>();<br>    <span class="hljs-comment">//定义当前游标</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteIterator</span><span class="hljs-params">(Vector _vector)</span>&#123;<br>        <span class="hljs-built_in">this</span>.vector = _vector;<br>    &#125;<br>    <span class="hljs-comment">//判断是否到达尾部</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.cursor == <span class="hljs-built_in">this</span>.vector.size())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//返回下一个元素</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.hasNext())&#123;<br>            result = <span class="hljs-built_in">this</span>.vector.get(<span class="hljs-built_in">this</span>.cursor++);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            result = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//删除当前元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.vector.remove(<span class="hljs-built_in">this</span>.cursor);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<em>开发系统时，迭代器的删除方法应该完成两个逻辑：一是删除当前元素，二是当前游标指向下一个元素。</em></p><p><strong>抽象容器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    <span class="hljs-comment">//是容器必然有元素的增加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object object)</span>;<br>    <span class="hljs-comment">//减少元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object object)</span>;<br>    <span class="hljs-comment">//由迭代器来遍历所有的元素</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体容器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    <span class="hljs-comment">//容纳对象的容器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Vector</span> <span class="hljs-variable">vector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>();<br>    <span class="hljs-comment">//增加一个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vector.add(object);<br>    &#125;<br>    <span class="hljs-comment">//返回迭代器对象</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(<span class="hljs-built_in">this</span>.vector);<br>    &#125;<br>    <span class="hljs-comment">//删除一个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-built_in">this</span>.remove(object);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//声明出容器</span><br>        <span class="hljs-type">Aggregate</span> <span class="hljs-variable">agg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteAggregate</span>();<br>        <span class="hljs-comment">//产生对象数据放进去</span><br>        agg.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        agg.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        agg.add(<span class="hljs-string">&quot;1234&quot;</span>);<br>        <span class="hljs-comment">//遍历一下</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> agg.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>            System.out.println(iterator.next());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单地说，迭代器就类似于一个数据库中的游标，可以在一个容器内上下翻滚，遍历所有它需要查看的元素。</p><h2 id="十五、组合模式"><a href="#十五、组合模式" class="headerlink" title="十五、组合模式"></a>十五、组合模式</h2><h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><p>组合模式(Composite Pattern)也叫合成模式，有时又叫做部分-整体模式（Part-Whole），主要是用来描述部分与整体的关系，其定义如下：</p><p>Compose objects into tree structures to represent part-whole hierarchies.Composite lets clients treat individual objects and compositions of objects uniformly.</p><p>（将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。）</p><h3 id="通用类图-13"><a href="#通用类图-13" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104223915648.png" alt="组合模式通用类图"></p><h3 id="通用代码-13"><a href="#通用代码-13" class="headerlink" title="通用代码"></a>通用代码</h3><ul><li><p>Component抽象构件角色</p><p>定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性</p></li><li><p>Leaf叶子构件</p><p>叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。</p></li><li><p>Composite树枝构件</p><p>树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</p></li></ul><p><strong>抽象构件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-comment">//个体和整体都具有的共享</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//编写业务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合模式的重点就在树枝构件</p><p><strong>树枝构件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-comment">//构件容器</span><br>    <span class="hljs-keyword">private</span> ArrayList&lt;Component&gt; componentArrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Component&gt;();<br>    <span class="hljs-comment">//增加一个叶子构件或树枝构件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span>&#123;<br>        <span class="hljs-built_in">this</span>.componentArrayList.add(component);<br>    &#125;<br>    <span class="hljs-comment">//删除一个叶子构件或树枝构件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span>&#123;<br>        <span class="hljs-built_in">this</span>.componentArrayList.remove(component);<br>    &#125;<br>    <span class="hljs-comment">//获得分支下的所有叶子构件和树枝构件</span><br>    <span class="hljs-keyword">public</span> ArrayList&lt;Component&gt; <span class="hljs-title function_">getChildren</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.componentArrayList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>树叶节点是没有子下级对象的对象，定义参加组合的原始对象行为</p><p><strong>树叶构件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 可以覆写父类方法</span><br><span class="hljs-comment">    * public void doSomething()&#123;</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &#125;</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>场景类负责树状结构的建立，并可以通过递归方式遍历整个树</p><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个根节点</span><br>        <span class="hljs-type">Composite</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>();<br>        root.doSomething();<br>        <span class="hljs-comment">//创建一个树枝构件</span><br>        <span class="hljs-type">Composite</span> <span class="hljs-variable">branch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>();<br>        <span class="hljs-comment">//创建一个叶子节点</span><br>        <span class="hljs-type">Leaf</span> <span class="hljs-variable">leaf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>        <span class="hljs-comment">//建立整体</span><br>        root.add(branch);<br>        branch.add(leaf);<br>    &#125;<br>    <br>    <span class="hljs-comment">//通过递归遍历树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Composite root)</span>&#123;<br>        <span class="hljs-keyword">for</span>(Component c:root.getChildren())&#123;<br>            <span class="hljs-keyword">if</span>(c <span class="hljs-keyword">instanceof</span> Leaf)&#123; <span class="hljs-comment">//叶子节点</span><br>                c.doSomething();<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//树枝节点</span><br>                display((Composite)c);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h3><ul><li><p><strong>高层模块调用简单</strong></p><p>一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。</p></li><li><p><strong>节点自由增加</strong></p><p>使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。</p></li></ul><h3 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h3><p>组合模式有一个非常明显的缺点，看到我们在场景类中的定义，提到树叶和树枝使用时的定义了吗？直接使用了实现类！这在面向接口编程上是很不恰当的，与依赖倒置原则冲突，读者在使用的时候要考虑清楚，它限制了你接口的影响范围。</p><h3 id="使用场景-11"><a href="#使用场景-11" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。</li><li>从一个整体中能够独立出部分模块或功能的场景。</li></ul><h2 id="十六、观察者模式"><a href="#十六、观察者模式" class="headerlink" title="十六、观察者模式"></a>十六、观察者模式</h2><h3 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h3><p>观察者模式（Observer Pattern）也叫做发布订阅模式（Publish&#x2F;subscribe）,它是一个在项目中经常使用的模式，其定义如下：</p><p>Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.</p><p>（定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。）</p><h3 id="通用类图-14"><a href="#通用类图-14" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104223930048.png" alt="观察者模式通用类图"></p><h3 id="通用代码-14"><a href="#通用代码-14" class="headerlink" title="通用代码"></a>通用代码</h3><ul><li><p><strong>Subject被观察者</strong></p><p>定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。</p></li><li><p><strong>Observer观察者</strong></p><p>观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。</p></li><li><p><strong>ConcreteSubject具体的被观察者</strong></p><p>定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。</p></li><li><p><strong>ConcreteObserver具体的观察者</strong></p><p>每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。</p></li></ul><p><strong>被观察者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">//定义一个观察者数组</span><br>    <span class="hljs-keyword">private</span> Vector&lt;Observer&gt; obsVector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;Observer&gt;();<br>    <span class="hljs-comment">//增加一个观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(Observer o)</span>&#123;<br>        <span class="hljs-built_in">this</span>.obsVector.add(o);<br>    &#125;<br>    <span class="hljs-comment">//删除一个观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delObserver</span><span class="hljs-params">(Observer o)</span>&#123;<br>        <span class="hljs-built_in">this</span>.obsVector.remove(o);<br>    &#125;<br>    <span class="hljs-comment">//通知所有观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span>(Observer o:<span class="hljs-built_in">this</span>.obsVector)&#123;<br>            o.update();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体被观察者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">//具体的业务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * do something</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-built_in">super</span>.notifyObservers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>观察者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">//更新方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察者一般是一个接口，每一个实现该接口的实现类都是具体观察者</p><p><strong>具体观察者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">//实现更新方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;接收到信息，并进行处理！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个被观察者</span><br>        <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>        <span class="hljs-comment">//定义一个观察者</span><br>        Observer obs= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>();<br>        <span class="hljs-comment">//观察者观察被观察者</span><br>        subject.addObserver(obs);<br>        <span class="hljs-comment">//观察者开始活动了</span><br>        subject.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h3><ul><li><p>观察者和被观察者之间是抽象耦合</p><p>如此设计，则不管是增加观察者还是被观察者都非常容易扩展，而且在Java中都已经实</p><p>现的抽象层级的定义，在系统扩展方面更是得心应手。</p></li><li><p>建立一套触发机制</p><p>根据单一职责原则，每个类的职责是单一的，那么怎么把各个单一的职责串联成真实世界的复杂的逻辑关系呢？比如，我们去打猎，打死了一只母鹿，母鹿有三个幼崽，因失去了母鹿而饿死，尸体又被两只秃鹰争抢，因分配不均，秃鹰开始斗殴，然后羸弱的秃鹰死掉，生存下来的秃鹰，则因此扩大了地盘……这就是一个触发机制，形成了一个触发链。观察者模式可以完美地实现这里的链条形式。</p></li></ul><h3 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h3><p>观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。</p><p>多级触发时的效率更是让人担忧，大家在设计时注意考虑。</p><h3 id="使用场景-12"><a href="#使用场景-12" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li><li>事件多级触发场景。</li><li>跨系统的消息交换场景，如消息队列的处理机制。</li></ul><h3 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h3><p>使用观察者模式也有以下两个重点问题要解决。</p><ul><li><p>广播链的问题</p><p>如果你做过数据库的触发器，你就应该知道有一个触发器链的问题，比如表A上写了一个触发器，内容是一个字段更新后更新表B的一条数据，而表B上也有个触发器，要更新表C，表C也有触发器……完蛋了，这个数据库基本上就毁掉了！我们的观察者模式也是一样的问题，一个观察者可以有双重身份，既是观察者，也是被观察者，这没什么问题呀，但是链一旦建立，这个逻辑就比较复杂，可维护性非常差，根据经验建议，在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次（传递两次），这还是比较好控制的。</p></li></ul><p>注意：<em>它和责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改的，它是由相邻的两个节点协商的消息结构；而责任链模式在消息传递过程中基本上保持消息不可变，如果要改变，也只是在原有的消息上进行修正。</em></p><ul><li><p>异步处理问题</p><p>这个EJB是一个非常好的例子，被观察者发生动作了，观察者要做出回应，如果观察者比较多，而且处理时间比较长怎么办？那就用异步呗，异步处理就要考虑线程安全和队列的问题，这个大家有时间看看Message Queue，就会有更深的了解。</p></li></ul><h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><p>Java从一开始诞生就提供了一个可扩展的父类，即java.util.Observable。</p><p>JDK中提供了:java.util.Observable实现类和java.util.Observer接口。</p><h2 id="十七、门面模式"><a href="#十七、门面模式" class="headerlink" title="十七、门面模式"></a>十七、门面模式</h2><h3 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h3><p>门面模式（Facade Pattern）也叫做外观模式，是一种比较常用的封装模式，其定义如下：</p><p>Provide a unified interface to a set of interfaces in a subsystem.Facade defines a higher-level interface that makes the subsystem easier to use.</p><p>（要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。）</p><h3 id="通用类图-15"><a href="#通用类图-15" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104223942696.png" alt="扩展后的系统类图"></p><p>是的，类图就这么简单，但是它代表的意义可是异常复杂，Subsystem Classes是子系统所有类的简称，它可能代表一个类，也可能代表几十个对象的集合。甭管多少对象，我们把这些对象全部圈入子系统的范畴。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104223953076.png" alt="门面模式示意图"></p><h3 id="通用代码-15"><a href="#通用代码-15" class="headerlink" title="通用代码"></a>通用代码</h3><p>再简单地说，门面对象是外界访问子系统内部的唯一通道，不管子系统内部是多么杂乱无章，只要有门面对象在，就可以做到“金玉其外，败絮其中”。</p><ul><li><p><strong>Facade门面角色</strong></p><p>客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去，也就说该角色没有实际的业务逻辑，只是一个委托类。</p></li><li><p><strong>subsystem子系统角色</strong></p><p>可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。</p></li></ul><p>我们来看一下门面模式的通用源码，先来看子系统源代码。由于子系统是类的集合，因此要描述该集合很花费精力，每一个子系统都不相同，我们使用3个相互无关的类来代表。</p><p><strong>子系统：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingA</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingB</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingC</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们认为这3个类属于近邻，处理相关的业务，因此应该被认为是一个子系统的不同逻辑处理模块，对于此子系统的访问需要通过门面进行</p><p><strong>门面对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br>    <span class="hljs-comment">//被委托的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ClassA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ClassB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ClassC</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassC</span>();<br>    <span class="hljs-comment">//提供给外部访问的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.a.doSomethingA();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.b.doSomethingB();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodC</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.c.doSomethingC();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h3><ul><li><p>减少系统的相互依赖</p><p>想想看，如果我们不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，你死我就死，你活我才能活，这样的强依赖是系统设计所不能接受的，门面模式的出现就很好地解决了该问题，所有的依赖都是对门面对象的依赖，与子系统无关。</p></li><li><p>提高了灵活性</p><p>依赖减少了，灵活性自然提高了。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。</p></li><li><p>提高安全性</p><p>想让你访问子系统的哪些业务就开通哪些逻辑，不在门面上开通的方法，你休想访问到。</p></li></ul><h3 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h3><p>门面模式最大的缺点就是不符合开闭原则，对修改关闭，对扩展开放，看看我们那个门面对象吧，它可是重中之重，一旦在系统投产后发现有一个小错误，你怎么解决？完全遵从开闭原则，根本没办法解决。继承？覆写？都顶不上用，唯一能做的一件事就是修改门面角色的代码，这个风险相当大，这就需要大家在设计的时候慎之又慎，多思考几遍才会有好收获。</p><h3 id="使用场景-13"><a href="#使用场景-13" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>为一个复杂的模块或子系统提供一个供外界访问的接口</li><li>子系统相对独立——外界对子系统的访问只要黑箱操作即可</li><li>预防低水平人员带来的风险扩散</li></ul><h2 id="十八、备忘录模式"><a href="#十八、备忘录模式" class="headerlink" title="十八、备忘录模式"></a>十八、备忘录模式</h2><h3 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h3><p>Without violating encapsulation,capture and externalize an object’s internal state so that the object can be restored to this state later.</p><p>（在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。）</p><h3 id="通用类图-16"><a href="#通用类图-16" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104224005668.png" alt="备忘录模式的通用类图"></p><h3 id="通用代码-16"><a href="#通用代码-16" class="headerlink" title="通用代码"></a>通用代码</h3><ul><li><p>Originator发起人角色</p><p>记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。</p></li><li><p>Memento备忘录角色</p><p>负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</p></li><li><p>Caretaker备忘录管理员角色</p><p>对备忘录进行管理、保存和提供备忘录。</p></li></ul><p><strong>发起人角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;<br>    <span class="hljs-comment">//内部状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-comment">//创建一个备忘录</span><br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">createMemento</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(<span class="hljs-built_in">this</span>.state);<br>    &#125;<br>    <span class="hljs-comment">//恢复一个备忘录</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreMemento</span><span class="hljs-params">(Memento _memento)</span>&#123;<br>        <span class="hljs-built_in">this</span>.setState(_memento.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备忘录角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;<br>    <span class="hljs-comment">//发起人的内部状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//构造函数传递参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Memento</span><span class="hljs-params">(String _state)</span>&#123;<br>        <span class="hljs-built_in">this</span>.state = _state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备忘录管理员角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> &#123;<br>    <span class="hljs-comment">//备忘录对象</span><br>    <span class="hljs-keyword">private</span> Memento memento;<br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">getMemento</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemento</span><span class="hljs-params">(Memento memento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memento = memento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这3个主要角色都很简单，我们来看场景类如何调用。</p><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义出发起人</span><br>        <span class="hljs-type">Originator</span> <span class="hljs-variable">originator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>();<br>        <span class="hljs-comment">//定义出备忘录管理员</span><br>        <span class="hljs-type">Caretaker</span> <span class="hljs-variable">caretaker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Caretaker</span>();<br>        <span class="hljs-comment">//创建一个备忘录</span><br>        caretaker.setMemento(originator.createMemento());<br>        <span class="hljs-comment">//恢复一个备忘录</span><br>        originator.restoreMemento(caretaker.getMemento());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备忘录模式就是这么简单，真正使用备忘录模式的时候可比这复杂得多。</p><h3 id="使用场景-14"><a href="#使用场景-14" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>需要保存和恢复数据的相关状态场景。</p></li><li><p>提供一个可回滚（rollback）的操作；比如Word中的CTRL+Z组合键，IE浏览器中的后退按钮，文件管理器上的backspace键等。</p></li><li><p>需要监控的副本场景中。例如要监控一个对象的属性，但是监控又不应该作为系统的主业务来调用，它只是边缘应用，即使出现监控不准、错误报警也影响不大，因此一般的做法是备份一个主线程中的对象，然后由分析程序来分析。</p></li><li><p>数据库连接的事务管理就是用的备忘录模式，想想看，如果你要实现一个JDBC驱动，你怎么来实现事务？还不是用备忘录模式嘛！</p></li></ul><h3 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>备忘录的生命期</p><p>备忘录创建出来就要在“最近”的代码中使用，要主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理。</p></li><li><p>备忘录的性能</p><p>不要在频繁建立备份的场景中使用备忘录模式（比如一个for循环中），原因有二：一是控制不了备忘录建立的对象数量；二是大对象的建立是要消耗资源的，系统的性能需要考虑。因此，如果出现这样的代码，设计师就应该好好想想怎么修改架构了。</p></li></ul><h2 id="十九、访问者模式"><a href="#十九、访问者模式" class="headerlink" title="十九、访问者模式"></a>十九、访问者模式</h2><h3 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h3><p>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates. </p><p>（封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。）</p><h3 id="通用类图-17"><a href="#通用类图-17" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104224030770.png" alt="访问者模式的通用类图"></p><h3 id="通用代码-17"><a href="#通用代码-17" class="headerlink" title="通用代码"></a>通用代码</h3><ul><li><p><strong>Visitor——抽象访问者</strong></p><p>抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的。</p></li><li><p><strong>ConcreteVisitor——具体访问者</strong></p><p>它影响访问者访问到一个类后该怎么干，要做什么事情。</p></li><li><p><strong>Element——抽象元素</strong></p><p>接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。</p></li><li><p><strong>ConcreteElement——具体元素</strong></p><p>实现accept方法，通常是visitor.visit(this)，基本上都形成了一种模式了。</p></li><li><p><strong>ObjectStruture——结构对象</strong></p><p>元素产生者，一般容纳在多个不同类、不同接口的容器，如List、Set、Map等，在项目中，一般很少抽象出这个角色。</p></li></ul><p><strong>抽象元素：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-comment">//定义业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//允许谁来访问</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(IVisitor visitor)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象元素有两类方法：一是本身的业务逻辑，也就是元素作为一个业务处理单元必须完成的职责；另外一个是允许哪一个访问者来访问。</p><p><strong>具体元素：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElement1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&#123;<br>    <span class="hljs-comment">//完善业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务处理</span><br>    &#125;<br>    <span class="hljs-comment">//允许那个访问者访问</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(IVisitor visitor)</span>&#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElement2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&#123;<br>    <span class="hljs-comment">//完善业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务处理</span><br>    &#125;<br>    <span class="hljs-comment">//允许那个访问者访问</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(IVisitor visitor)</span>&#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它定义了两个具体元素，我们再来看抽象访问者，一般是有几个具体元素就有几个访问方法。</p><p><strong>抽象访问者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IVisitor</span> &#123;<br>    <span class="hljs-comment">//可以访问哪些对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElement1 el1)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElement2 el2)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体访问者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVisitor</span> &#123;<br>    <span class="hljs-comment">//访问el1元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElement1 el1)</span> &#123;<br>        el1.doSomething();<br>    &#125;<br>    <span class="hljs-comment">//访问el2元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElement2 el2)</span> &#123;<br>        el2.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构对象是产生出不同的元素对象，我们使用工厂方法模式来模拟。</p><p><strong>结构对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectStruture</span> &#123;<br>    <span class="hljs-comment">//对象生成器，这里通过一个工厂方法模式模拟</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Element <span class="hljs-title function_">createElement</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">if</span>(rand.nextInt(<span class="hljs-number">100</span>) &gt; <span class="hljs-number">50</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElement1</span>();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElement2</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入了访问者角色后，我们对所有的具体元素的访问就非常简单了，我们通过一个场景类模拟这种情况</p><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            <span class="hljs-comment">//获得元素对象</span><br>            <span class="hljs-type">Element</span> <span class="hljs-variable">el</span> <span class="hljs-operator">=</span> ObjectStruture.createElement();<br>            <span class="hljs-comment">//接受访问者访问</span><br>            el.accept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Visitor</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过增加访问者，只要是具体元素就非常容易访问，对元素的遍历就更加容易了，甭管它是什么对象，只要它在一个容器中，都可以通过访问者来访问，任务集中化。这就是访问者模式。</p><h3 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h3><ul><li><p>符合单一职责原则</p><p>具体元素角色也就是Employee抽象类的两个子类负责数据的加载，而Visitor类则负责报表的展现，两个不同的职责非常明确地分离开来，各自演绎变化。</p></li><li><p>优秀的扩展性</p><p>由于职责分开，继续增加对数据的操作是非常快捷的，例如，现在要增加一份给大老板的报表，这份报表格式又有所不同，直接在Visitor中增加一个方法，传递数据后进行整理打印。</p></li><li><p>灵活性非常高</p><p>例如，数据汇总，就以刚刚我们说的Employee的例子，如果我现在要统计所有员工的工资之和，怎么计算？把所有人的工资for循环加一遍？是个办法，那我再提个问题，员工工资×1.2，部门经理×1.4，总经理×1.8，然后把这些工资加起来，你怎么处理？1.2，1.4，1.8是什么？不是吧？！你没看到领导不论什么时候都比你拿得多，工资奖金就不说了，就是过节发个慰问券也比你多，就是这个系数在作祟。我们继续说你想怎么统计？使用for循环，然后使用instanceof来判断是员工还是经理？这可以解决，但不是个好办法，好办法是通过访问者模式来实现，把数据扔给访问者，由访问者来进行统计计算。</p></li></ul><h3 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>具体元素对访问者公布细节</p><p>访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的。</p></li><li><p>具体元素变更比较困难</p><p>具体元素角色的增加、删除、修改都是比较困难的，就上面那个例子，你想想，你要是想增加一个成员变量，如年龄age，Visitor就需要修改，如果Visitor是一个还好办，多个呢？业务逻辑再复杂点呢？</p></li><li><p>违背了依赖倒置转原则</p><p>访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对象的编程中，抛弃了对接口的依赖，而直接依赖实现类，扩展比较难。</p></li></ul><h3 id="使用场景-15"><a href="#使用场景-15" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景。</li><li>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。</li></ul><p>总结一下，在这种地方你一定要考虑使用访问者模式：业务规则要求遍历多个不同的对象。这本身也是访问者模式出发点，迭代器模式只能访问同类或同接口的数据（当然了，如果你使用instanceof，那么能访问所有的数据，这没有争论），而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作，也就是针对访问的对象不同，执行不同的操作。</p><h2 id="二十、状态模式"><a href="#二十、状态模式" class="headerlink" title="二十、状态模式"></a>二十、状态模式</h2><h3 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h3><p>Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.</p><p>（当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。）</p><h3 id="通用类图-18"><a href="#通用类图-18" class="headerlink" title="通用类图"></a>通用类图</h3><p>状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104224048504.png" alt="状态模式通用类图"></p><h3 id="通用代码-18"><a href="#通用代码-18" class="headerlink" title="通用代码"></a>通用代码</h3><ul><li><p>State——抽象状态角色</p><p>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。</p></li><li><p>ConcreteState——具体状态角色</p><p>每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理，通俗地说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。</p></li><li><p>Context——环境角色</p><p>定义客户端需要的接口，并且负责具体状态的切换。</p><p>状态模式相对来说比较复杂，它提供了一种对物质运动的另一个观察视角，通过状态变更促使行为的变化，就类似水的状态变更一样，一碗水的初始状态是液态，通过加热转变为气态，状态的改变同时也引起体积的扩大，然后就产生了一个新的行为：鸣笛或顶起壶盖，瓦特就是这么发明蒸汽机的。</p></li></ul><p><strong>抽象环境角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">//定义一个环境角色，提供子类访问</span><br>    <span class="hljs-keyword">protected</span> Context context;<br>    <span class="hljs-comment">//设置环境角色</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(Context _context)</span>&#123;<br>        <span class="hljs-built_in">this</span>.context = _context;<br>    &#125;<br>    <span class="hljs-comment">//行为1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//行为2</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象环境中声明一个环境角色，提供各个状态类自行访问，并且提供所有状态的抽象行为，由各个实现类实现。</p><p><strong>环境角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteState1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//本状态下必须处理的逻辑</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置当前状态为stat2</span><br>        <span class="hljs-built_in">super</span>.context.setCurrentState(Context.STATE2);<br>        <span class="hljs-comment">//过渡到state2状态，由Context实现</span><br>        <span class="hljs-built_in">super</span>.context.handle2();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteState2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置当前状态为state1</span><br>        <span class="hljs-built_in">super</span>.context.setCurrentState(Context.STATE1);<br>        <span class="hljs-comment">//过渡到state1状态，由Context实现</span><br>        <span class="hljs-built_in">super</span>.context.handle1();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//本状态下必须处理的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体环境角色有两个职责：处理本状态必须完成的任务，决定是否可以过渡到其他状态。</p><p><strong>具体环境角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-comment">//定义状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">State</span> <span class="hljs-variable">STATE1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteState1</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">State</span> <span class="hljs-variable">STATE2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteState2</span>();<br>    <span class="hljs-comment">//当前状态</span><br>    <span class="hljs-keyword">private</span> State CurrentState;<br>    <span class="hljs-comment">//获得当前状态</span><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> CurrentState;<br>    &#125;<br>    <span class="hljs-comment">//设置当前状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentState</span><span class="hljs-params">(State currentState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.CurrentState = currentState;<br>        <span class="hljs-comment">//切换状态</span><br>        <span class="hljs-built_in">this</span>.CurrentState.setContext(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//行为委托</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.CurrentState.handle1();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.CurrentState.handle2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>环境角色有两个不成文的约束：</p><ul><li>把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。</li><li>环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。</li></ul><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义环境角色</span><br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>        <span class="hljs-comment">//初始化状态</span><br>        context.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteState1</span>());<br>        <span class="hljs-comment">//行为执行</span><br>        context.handle1();<br>        context.handle2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到没？我们已经隐藏了状态的变化过程，它的切换引起了行为的变化。对外来说，我们只看到行为的发生改变，而不用知道是状态变化引起的。</p><h3 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h3><ul><li><p>结构清晰</p><p>避免了过多的switch…case或者if…else语句的使用，避免了程序的复杂性,提高系统的可维护性。</p></li><li><p>遵循设计原则</p><p>很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。</p></li><li><p>封装性非常好</p><p>这也是状态模式的基本要求，状态变换放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。</p></li></ul><h3 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h3><p>状态模式既然有优点，那当然有缺点了。但只有一个缺点，子类会太多，也就是类膨胀。如果一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目中自己衡量。其实有很多方式可以解决这个状态问题，如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。</p><h3 id="使用场景-16"><a href="#使用场景-16" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>行为随状态改变而改变的场景</p><p>这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式。</p></li><li><p>条件、分支判断语句的替代者</p><p>在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，使用状态模式可以很好地避免这一问题，它通过扩展子类实现了条件的判断处理。</p></li></ul><h3 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h3><p>状态模式适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个。</p><h2 id="二十一、解释器模式"><a href="#二十一、解释器模式" class="headerlink" title="二十一、解释器模式"></a>二十一、解释器模式</h2><h3 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h3><p>解释器模式（Interpreter Pattern）是一种按照规定语法进行解析的方案，在现在项目中使用较少，其定义如下：</p><p>Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.</p><p>（给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。）</p><h3 id="通用类图-19"><a href="#通用类图-19" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104000335235.png" alt="解释器模式通用类图"></p><h3 id="通用代码-19"><a href="#通用代码-19" class="headerlink" title="通用代码"></a>通用代码</h3><ul><li><p>AbstractExpression——抽象解释器</p><p>具体的解释任务由各个实现类完成，具体的解释器分别由TerminalExpression和NonterminalExpression完成。</p></li><li><p>TerminalExpression——终结符表达式</p><p>实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。具体到我们例子就是VarExpression类，表达式中的每个终结符都在栈中产生了一个VarExpression对象。</p></li><li><p>NonterminalExpression——非终结符表达式</p><p>文法中的每条规则对应于一个非终结表达式，具体到我们的例子就是加减法规则分别对应到AddExpression和SubExpression两个类。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</p></li><li><p>Context——环境角色</p><p>具体到我们的例子中是采用HashMap代替。</p></li></ul><p><strong>抽象表达式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-comment">//每个表达式必须有一个解析任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context ctx)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象表达式是生成语法集合（也叫做语法树）的关键，每个语法集合完成指定语法解析任务，它是通过递归调用的方式，最终由最小的语法单元进行解析完成。 </p><p><strong>终结符表达式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-comment">//通常终结符表达式只有一个，但是有多个对象</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context ctx)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常，终结符表达式比较简单，主要是处理场景元素和数据的转换。</p><p><strong>非终结符表达式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonterminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-comment">//每个非终结符表达式都会对其他表达式产生依赖</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NonterminalExpression</span><span class="hljs-params">(Expression... expression)</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context ctx)</span> &#123;<br>        <span class="hljs-comment">//进行文法处理</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个非终结符表达式都代表了一个文法规则，并且每个文法规则都只关心自己周边的文法规则的结果（注意是结果），因此这就产生了每个非终结符表达式调用自己周边的非终结符表达式，然后最终、最小的文法规则就是终结符表达式，终结符表达式的概念就是如此，不能够再参与比自己更小的文法运算了。</p><p><strong>客户类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>        <span class="hljs-comment">//通常定一个语法容器，容纳一个具体的表达式，通常为ListArray、LinkedList、Stack等类型</span><br>        Stack&amp;Expression&gt; stack = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(;;)&#123;<br>            <span class="hljs-comment">//进行语法判断，并产生递归调用</span><br>        &#125;<br>        <span class="hljs-comment">//产生一个完整的语法树，由各个具体的语法分析进行解析</span><br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-comment">//具体元素进入场景</span><br>        exp.interpreter(ctx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常Client是一个封装类，封装的结果就是传递进来一个规范语法文件，解析器分析后产生结果并返回，避免了调用者与语法解析器的耦合关系。</p><h3 id="优点-17"><a href="#优点-17" class="headerlink" title="优点"></a>优点</h3><p>解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。</p><h3 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>解释器模式会引起类膨胀</p><p>每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦。</p></li><li><p>解释器模式采用递归调用方法</p><p>每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层一层地剥茧，无论是面向过程的语言还是面向对象的语言，递归都是在必要条件下使用的，它导致调试非常复杂。想想看，如果排查一个语法错误，我们是不是要一个断点一个断点地调试下去，直到最小的语法单元。</p></li><li><p>效率问题</p><p>解释器模式由于使用了大量的循环和递归，效率是一个不容忽视的问题，特别是一用于解析复杂、冗长的语法时，效率是难以忍受的。</p></li></ul><h3 id="使用场景-17"><a href="#使用场景-17" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>重复发生的问题可以使用解释器模式</p><p>例如，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素是相同的，按照解释器的说法就是终结符表达式都是相同的，但是非终结符表达式就需要制定了。在这种情况下，可以通过程序来一劳永逸地解决该问题。</p></li><li><p>一个简单语法需要解释的场景</p><p>为什么是简单？看看非终结表达式，文法规则越多，复杂度越高，而且类间还要进行递归调用（看看我们例子中的栈）。想想看，多个类之间的调用你需要什么样的耐心和信心去排查问题。因此，解释器模式一般用来解析比较标准的字符集，例如SQL语法分析，不过该部分逐渐被专用工具所取代。</p></li></ul><h3 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h3><p>尽量不要在重要的模块中使用解释器模式，否则维护会是一个很大的问题。在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足。我们在一个银行的分析型项目中就采用JRuby进行运算处理，避免使用解释器模式的四则运算，效率和性能各方面表现良好。</p><h2 id="二十二、享元模式"><a href="#二十二、享元模式" class="headerlink" title="二十二、享元模式"></a>二十二、享元模式</h2><h3 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h3><p>享元模式（Flyweight Pattern）是池技术的重要实现方式，其定义如下：</p><p>Use sharing to support large numbers of fine-grained objects efficiently.（使用共享对象可有效地支持大量的细粒度的对象。）</p><h3 id="通用类图-20"><a href="#通用类图-20" class="headerlink" title="通用类图"></a>通用类图</h3><p>享元模式的定义为我们提出了两个要求：细粒度的对象和共享对象。我们知道分配太多的对象到应用程序中将有损程序的性能，同时还容易造成内存溢出，那怎么避免呢？就是享元模式提到的共享技术。我们先来了解一下对象的内部状态和外部状态。</p><p>要求细粒度对象，那么不可避免地使得对象数量多且性质相近，那我们就将这些对象的信息分为两个部分：内部状态（intrinsic）与外部状态（extrinsic）。</p><ul><li><p>内部状态</p><p>内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变，如我们例子中的id、postAddress等，它们可以作为一个对象的动态附加信息，不必直接储存在具体某个对象中，属于可以共享的部分。</p></li><li><p>外部状态</p><p>外部状态是对象得以依赖的一个标记，是随环境改变而改变的、不可以共享的状态，如我们例子中的考试科目+考试地点复合字符串，它是一批对象的统一标识，是唯一的一个索引值。</p></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104001755286.png" alt="享元模式的通用类图"></p><h3 id="通用代码-20"><a href="#通用代码-20" class="headerlink" title="通用代码"></a>通用代码</h3><ul><li><p><strong>Flyweight——抽象享元角色</strong></p><p>它简单地说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。</p></li><li><p><strong>ConcreteFlyweight——具体享元角色</strong></p><p>具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允许的。</p></li><li><p><strong>unsharedConcreteFlyweight——不可共享的享元角色</strong></p><p>不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。</p></li><li><p><strong>FlyweightFactory——享元工厂</strong></p><p>职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。</p></li></ul><p>享元模式的目的在于运用共享技术，使得一些细粒度的对象可以共享，我们的设计确实也应该这样，多使用细粒度的对象，便于重用或重构。</p><p><strong>抽象享元角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>    <span class="hljs-comment">//内部状态</span><br>    <span class="hljs-keyword">private</span> String intrinsic;<br>    <span class="hljs-comment">//外部状态</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> String Extrinsic;<br>    <span class="hljs-comment">//要求享元角色必须接受外部状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Flyweight</span><span class="hljs-params">(String _Extrinsic)</span>&#123;<br>        <span class="hljs-built_in">this</span>.Extrinsic = _Extrinsic;<br>    &#125;<br>    <span class="hljs-comment">//定义业务操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//内部状态的getter/setter</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIntrinsic</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> intrinsic;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIntrinsic</span><span class="hljs-params">(String intrinsic)</span> &#123;<br>        <span class="hljs-built_in">this</span>.intrinsic = intrinsic;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象享元角色一般为抽象类，在实际项目中，一般是一个实现类，它是描述一类事物的方法。在抽象角色中，一般需要把外部状态和内部状态（当然了，可以没有内部状态，只有行为也是可以的）定义出来，避免子类的随意扩展。</p><p><strong>具体享元角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFlyweight1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Flyweight</span>&#123;<br>    <span class="hljs-comment">//接受外部状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteFlyweight1</span><span class="hljs-params">(String _Extrinsic)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_Extrinsic);<br>    &#125;<br>    <span class="hljs-comment">//根据外部状态进行逻辑处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFlyweight2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Flyweight</span>&#123;<br>    <span class="hljs-comment">//接受外部状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteFlyweight2</span><span class="hljs-params">(String _Extrinsic)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_Extrinsic);<br>    &#125;<br>    <span class="hljs-comment">//根据外部状态进行逻辑处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这很简单，实现自己的业务逻辑，然后接收外部状态，以便内部业务逻辑对外部状态的依赖。注意，我们在抽象享元中对外部状态加上了final关键字，防止意外产生，什么意外？获得了一个外部状态，然后无意修改了一下，池就混乱了！</p><p>注意：<em>在程序开发中，确认只需要一次赋值的属性则设置为final类型，避免无意修改导致逻辑混乱，特别是Session级的常量或变量。</em></p><p><strong>享元工厂：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;<br>    <span class="hljs-comment">//定义一个池容器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;String,Flyweight&gt; pool= <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Flyweight&gt;();<br>    <span class="hljs-comment">//享元工厂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Flyweight <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">(String Extrinsic)</span>&#123;<br>        <span class="hljs-comment">//需要返回的对象</span><br>        <span class="hljs-type">Flyweight</span> <span class="hljs-variable">flyweight</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//在池中没有该对象</span><br>        <span class="hljs-keyword">if</span>(pool.containsKey(Extrinsic))&#123;<br>            flyweight = pool.get(Extrinsic);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//根据外部状态创建享元对象</span><br>            flyweight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight1</span>(Extrinsic);<br>            <span class="hljs-comment">//放置到池中</span><br>            pool.put(Extrinsic, flyweight);<br>        &#125;<br>        <span class="hljs-keyword">return</span> flyweight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p>享元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p><h3 id="使用场景-18"><a href="#使用场景-18" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>系统中存在大量的相似对象。</p></li><li><p>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</p></li><li><p>需要缓冲池的场景。</p></li></ul><h2 id="二十三、桥梁模式"><a href="#二十三、桥梁模式" class="headerlink" title="二十三、桥梁模式"></a>二十三、桥梁模式</h2><h3 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h3><p>桥梁模式（Bridge Pattern）也叫做桥接模式，是一个比较简单的模式，其定义如下：</p><p>Decouple an abstraction from its implementation so that the two can vary independently.</p><p>（将抽象和实现解耦，使得两者可以独立地变化。）</p><h3 id="通用类图-21"><a href="#通用类图-21" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230104224114123.png" alt="桥梁模式通用类图"></p><h3 id="通用代码-21"><a href="#通用代码-21" class="headerlink" title="通用代码"></a>通用代码</h3><ul><li><p><strong>Abstraction——抽象化角色</strong></p><p>它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。</p></li><li><p><strong>Implementor——实现化角色</strong></p><p>它是接口或者抽象类，定义角色必需的行为和属性。</p></li><li><p><strong>RefinedAbstraction——修正抽象化角色</strong></p><p>它引用实现化角色对抽象化角色进行修正。</p></li><li><p><strong>ConcreteImplementor——具体实现化角色</strong></p><p>它实现接口或抽象类定义的方法和属性。</p></li></ul><p>桥梁模式中的几个名词比较拗口，大家只要记住一句话就成：抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的。</p><p><strong>实现化角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Implementor</span> &#123;<br>    <span class="hljs-comment">//基本方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAnything</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它没有任何特殊的地方，就是一个一般的接口，定义要实现的方法。</p><p><strong>具体实现化角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementor1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Implementor</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAnything</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementor2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Implementor</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAnything</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面定义了两个具体实现化角色——代表两个不同的业务逻辑。</p><p><strong>抽象化角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>    <span class="hljs-comment">//定义对实现化角色的引用</span><br>    <span class="hljs-keyword">private</span> Implementor imp;<br>    <span class="hljs-comment">//约束子类必须实现该构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Abstraction</span><span class="hljs-params">(Implementor _imp)</span>&#123;<br>        <span class="hljs-built_in">this</span>.imp = _imp;<br>    &#125;<br>    <span class="hljs-comment">//自身的行为和属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.imp.doSomething();<br>    &#125;<br>    <span class="hljs-comment">//获得实现化角色</span><br>    <span class="hljs-keyword">public</span> Implementor <span class="hljs-title function_">getImp</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> imp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>各位可能要问，为什么要增加一个构造函数？答案是为了提醒子类，你必须做这项工作，指定实现者，特别是已经明确了实现者，则尽量清晰明确地定义出来。</p><p><strong>具体抽象化角色：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>    <span class="hljs-comment">//覆写构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RefinedAbstraction</span><span class="hljs-params">(Implementor _imp)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_imp);<br>    &#125;<br>    <span class="hljs-comment">//修正父类的行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 业务处理...</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-built_in">super</span>.request();<br>        <span class="hljs-built_in">super</span>.getImp().doAnything();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想想看，如果我们的实现化角色有很多的子接口，然后是一堆的子实现。如果在构造函数中不传递一个尽量明确的实现者，代码就很不清晰。</p><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义一个实现化角色</span><br>        <span class="hljs-type">Implementor</span> <span class="hljs-variable">imp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteImplementor1</span>();<br>        <span class="hljs-comment">//定义一个抽象化角色</span><br>        <span class="hljs-type">Abstraction</span> <span class="hljs-variable">abs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefinedAbstraction</span>(imp);<br>        <span class="hljs-comment">//执行行文</span><br>        abs.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>桥梁模式是一个非常简单的模式，它只是使用了类间的聚合关系、继承、覆写等常用功能，但是它却提供了一个非常清晰、稳定的架构。</p><h3 id="优点-18"><a href="#优点-18" class="headerlink" title="优点"></a>优点</h3><ul><li><p>抽象和实现分离</p><p>这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。</p></li><li><p>优秀的扩充能力</p><p>看看我们的例子，想增加实现？没问题！想增加抽象，也没有问题！只要对外暴露的接口层允许这样的变化，我们已经把变化的可能性减到最小。</p></li><li><p>实现细节对客户透明</p><p>客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装。</p></li></ul><h3 id="使用场景-19"><a href="#使用场景-19" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>不希望或不适用使用继承的场景</p><p>例如继承层次过渡、无法更细化设计颗粒等场景，需要考虑使用桥梁模式。</p></li><li><p>接口或抽象类不稳定的场景</p><p>明知道接口不稳定还想通过实现或继承来实现业务需求，那是得不偿失的，也是比较失败的做法。</p></li><li><p>重用性要求较高的场景</p><p>设计的颗粒度越细，则被重用的可能性就越大，而采用继承则受父类的限制，不可能出现太细的颗粒度。</p></li></ul><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>大家对类的继承有什么看法吗？继承的优点有很多，可以把公共的方法或属性抽取，父类封装共性，子类实现特性，这是继承的基本功能。缺点有没有？有！即强侵入，父类有一个方法，子类也必须有这个方法。这是不可选择的，会带来扩展性的问题。我举个简单的例子来说明：Father类有一个方法A，Son继承了这个方法，然后GrandSon也继承了这个方法，问题是突然有一天Son要重写父类的这个方法，他敢做吗？绝对不敢！GrandSon要用从Father继承过来的方法A，如果你修改了，那就要修改Son和GrandSon之间的关系，那这个风险就太大了！</p><p>这里讲的这个桥梁模式就是这一问题的解决方法，桥梁模式描述了类间弱关联关系，还说上面的那个例子，Father类完全可以把可能会变化的方法放出去，Son子类要拥有这个方法很简单，桥梁搭过去，获得这个方法，GrandSon也一样，即使你Son子类不想使用这个方法也没关系，对GrandSon不产生影响，它不是从Son中继承来的方法！</p><p>不能说继承不好，它非常好，但是有缺点，我们可以扬长避短，对于比较明确不发生变化的，则通过继承来完成；若不能确定是否会发生变化的，那就认为是会发生变化，则通过桥梁模式来解决，这才是一个完美的世界。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六大设计原则</title>
    <link href="/2022/12/15/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2022/12/15/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h1><p>文章摘自《设计模式之禅(第二版)》- 秦小波</p><h2 id="一、单一职责原则"><a href="#一、单一职责原则" class="headerlink" title="一、单一职责原则"></a>一、单一职责原则</h2><blockquote><p>英文名称是Single Responsibility Principle，简称是SRP。</p><p>原话解释：<em>There should never be more than one reason for a class to change.</em></p></blockquote><p><strong>定义：应该有且仅有一个原因引起类的变更。</strong></p><p><strong>示例</strong>：电话通话的时候有4个过程发生：拨号、通话、回应、挂机，那我们写一个接口。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221213231244890.png" alt="image-20221213231244890"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPhone</span> &#123;<br>    <span class="hljs-comment">//拨通电话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dial</span><span class="hljs-params">(String phoneNumber)</span>;<br>    <span class="hljs-comment">//通话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chat</span><span class="hljs-params">(Object o)</span>;<br>    <span class="hljs-comment">//通话完毕，挂电话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hangup</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情，看看上面的接口只负责一件事情吗？是只有一个原因引起变化吗？好像不是！</p><p>IPhone这个接口可不是只有一个职责，它包含了两个职责：一个是协议管理，一个是数据传送。</p><ul><li><p><code>dial()</code>和<code>hangup()</code>两个方法实现的是协议管理，分别负责拨号接通和挂机；</p></li><li><p><code>chat()</code>实现的是数据的传送，把我们说的话转换成模拟信号或数字信号传递到对方，然后再把对方传递过来的信号还原成我们听得懂的语言。</p></li></ul><p><strong>思考：</strong></p><p>协议接通的变化会引起这个接口或实现类的变化吗？会的！</p><p>那数据传送（想想看，电话不仅仅可以通话，还可以上网）的变化会引起这个接口或实现类的变化吗？会的！</p><p>通过这样的分析，我们发现类图上的IPhone接口包含了两个职责，而且这两个职责的变化不相互影响，那就考虑拆分成两个接口。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221213232355372.png" alt="image-20221213232355372"></p><p>这样的设计才是完美的，一个类实现了两个接口，把两个职责融合在一个类中。</p><p><em>你会觉得这个Phone有两个原因引起变化了呀，是的，但是别忘记了我们是面向接口编程，我们对外公布的是接口而不是实现类。</em></p><p><strong>单一职责的好处：</strong></p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性提高，复杂性降低，那当然可读性提高了；</li><li>可维护性提高，可读性提高，那当然更容易维护了；</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li></ul><p><strong>注意：</strong>单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因<strong>项目</strong>而异，因<strong>环境</strong>而异。</p><h2 id="二、里氏替换原则"><a href="#二、里氏替换原则" class="headerlink" title="二、里氏替换原则"></a>二、里氏替换原则</h2><blockquote><p>里氏替换原则：Liskov Substitution Principle，LSP</p></blockquote><p>在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下<strong>优点</strong>：</p><ul><li><p>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；</p></li><li><p>提高代码的重用性；</p></li><li><p>子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；</p></li><li><p>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；</p></li><li><p>提高产品或项目的开放性。</p></li></ul><p>自然界的所有事物都是优点和缺点并存的，即使是鸡蛋，有时候也能挑出骨头来，继承的<strong>缺点</strong>如下：</p><ul><li>继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；</li><li>降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；</li><li>增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。</li></ul><p><strong>定义：</strong></p><p><strong>第一种定义：</strong></p><p>也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）</p><p><strong>第二种定义：</strong></p><p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p><p><strong>解释：</strong>第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。</p><hr><p>这里的示例带有违规词语，暂时省略。</p><p><strong>总结：</strong>采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。</p><h2 id="三、依赖倒置原则"><a href="#三、依赖倒置原则" class="headerlink" title="三、依赖倒置原则"></a>三、依赖倒置原则</h2><blockquote><p>依赖倒置原则（Dependence Inversion Principle,DIP）</p><p>High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.</p></blockquote><p>翻译过来，包含三层含义：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节；</li><li>细节应该依赖抽象。</li></ul><p>高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。</p><p>那什么是抽象？什么又是细节呢？在Java语言中，</p><p>抽象就是指接口或抽象类，两者都是不能直接被实例化的；</p><p>细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。</p><p>依赖倒置原则在Java语言中的表现就是：</p><ul><li><p>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</p></li><li><p>接口或抽象类不依赖于实现类；</p></li><li><p>实现类依赖接口或抽象类。</p></li></ul><p>更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。</p><p><strong>示例：</strong></p><p>现在的汽车越来越便宜了，一个卫生间的造价就可以买到一辆不错的汽车，有汽车就必然有人来驾驶，司机驾驶奔驰车的类图。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221214004905796.png" alt="image-20221214004905796"></p><p>奔驰车可以提供一个方法run，代表车辆运行，</p><p><strong>司机源代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123;<br>    <span class="hljs-comment">//司机的主要职责就是驾驶汽车</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(Benz benz)</span>&#123;<br>        benz.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>司机通过调用奔驰车的run方法开动奔驰车</p><p><strong>奔驰车源代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> &#123;<br>    <span class="hljs-comment">//汽车肯定会跑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;奔驰汽车开始运行...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景类源代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Driver</span> <span class="hljs-variable">zhangSan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br>        <span class="hljs-type">Benz</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br>        <span class="hljs-comment">//张三开奔驰车</span><br>        zhangSan.drive(benz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以上的代码，完成了司机开动奔驰车的场景，到目前为止，这个司机开奔驰车的项目没有任何问题。我们常说“危难时刻见真情”，我们把这句话移植到技术上就成了“变更才显真功夫”，业务需求变更永无休止，技术前进就永无止境，在发生变更时才能发觉我们的设计或程序是否是松耦合。我们在一段貌似磐石的程序上加上一块小石头：张三司机不仅要开奔驰车，还要开宝马车，又该怎么实现呢？麻烦出来了，那好，我们走一步是一步，我们先把宝马车产生出来</p><p><strong>宝马车源代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BMW</span> &#123;<br>    <span class="hljs-comment">//宝马车当然也可以开动了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;宝马汽车开始运行...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>宝马车也产生了，但是我们却没有办法让张三开动起来，为什么？张三没有开动宝马车的方法呀！一个拿有C驾照的司机竟然只能开奔驰车而不能开宝马车，这也太不合理了！在现实世界都不允许存在这种情况，何况程序还是对现实世界的抽象，我们的设计出现了问题：司机类和奔驰车类之间是紧耦合的关系，其导致的结果就是系统的可维护性大大降低，可读性降低，两个相似的类需要阅读两个文件，你乐意吗？还有稳定性，什么是稳定性？固化的、健壮的才是稳定的，这里只是增加了一个车类就需要修改司机类，这不是稳定性，这是易变性。被依赖者的变更竟然让依赖者来承担修改的成本，这样的依赖关系谁肯承担！</p><p>根据以上证明，如果不使用依赖倒置原则就会加重类间的耦合性，降低系统的稳定性，增加并行开发引起的风险，降低代码的可读性和可维护性。承接上面的例子，引入依赖倒置原则后的类图。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221214005252180.png" alt="image-20221214005252180"></p><p>建立两个接口：IDriver和ICar，分别定义了司机和汽车的各个职能，司机就是驾驶汽车，必须实现drive()方法。</p><p><strong>司机接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IDriver</span> &#123;<br>    <span class="hljs-comment">//是司机就应该会驾驶汽车</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(ICar car)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>司机类的实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IDriver</span>&#123;<br>    <span class="hljs-comment">//司机的主要职责就是驾驶汽车</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(ICar car)</span>&#123;<br>        car.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在IDriver中，通过传入ICar接口实现了抽象之间的依赖关系，Driver实现类也传入了ICar接口，至于到底是哪个型号的Car，需要在高层模块中声明。</p><p><strong>汽车接口及两个实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICar</span> &#123;<br>    <span class="hljs-comment">//是汽车就应该能跑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span>&#123;<br>    <span class="hljs-comment">//汽车肯定会跑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;奔驰汽车开始运行...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BMW</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span>&#123;<br>    <span class="hljs-comment">//宝马车当然也可以开动了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;宝马汽车开始运行...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在业务场景中，我们贯彻“抽象不应该依赖细节”，也就是我们认为抽象（ICar接口）不依赖BMW和Benz两个实现类（细节），因此在高层次的模块中应用都是抽象。</p><p><strong>业务场景：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IDriver</span> <span class="hljs-variable">zhangSan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br>        <span class="hljs-type">ICar</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br>        <span class="hljs-comment">//张三开奔驰车</span><br>        zhangSan.drive(benz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Client属于高层业务逻辑，它对低层模块的依赖都建立在抽象上，zhangSan的表面类型是IDriver，Benz的表面类型是ICar，也许你要问，在这个高层模块中也调用到了低层模块，比如new Driver()和new Benz()等，如何解释？确实如此，zhangSan的表面类型是IDriver，是一个接口，是抽象的、非实体化的，在其后的所有操作中，zhangSan都是以IDriver类型进行操作，屏蔽了细节对抽象的影响。当然，张三如果要开宝马车，也很容易，我们只要修改业务场景类就可以。</p><p><strong>张三驾驶宝马车的实现过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IDriver</span> <span class="hljs-variable">zhangSan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br>        <span class="hljs-type">ICar</span> <span class="hljs-variable">bmw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>();<br>        <span class="hljs-comment">//张三开奔驰车</span><br>        zhangSan.drive(bmw);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在新增加低层模块时，只修改了业务场景类，也就是高层模块，对其他低层模块如Driver类不需要做任何修改，业务就可以运行，把“变更”引起的风险扩散降到最低。</p><p><strong>总结：</strong></p><p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以：</p><ul><li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</li><li>变量的表面类型尽量是接口或者是抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法</li><li>结合里氏替换原则使用</li></ul><h2 id="四、接口隔离原则"><a href="#四、接口隔离原则" class="headerlink" title="四、接口隔离原则"></a>四、接口隔离原则</h2><p>接口分为两种：</p><ul><li>实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，这是一种接口。比如你定义Person这个类，然后使用Person zhangSan&#x3D;new Person()产生了一个实例，这个实例要遵从的标准就是Person这个类，Person类就是zhangSan的接口。疑惑？看不懂？不要紧，那是因为让Java语言浸染的时间太长了，只要知道从这个角度来看，Java中的类也是一种接口。</li><li>类接口（Class Interface），Java中经常使用的interface关键字定义的接口。</li></ul><p>什么是隔离？</p><ul><li>Clients should not be forced to depend upon interfaces that they don’t use.（客户端不应该依赖它不需要的接口。）</li><li>The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）</li></ul><p>这两个定义概括为一句话：<strong>建立单一接口，不要建立臃肿庞大的接口。</strong></p><p><strong>示例：</strong></p><p>我们举例来说明接口隔离原则到底对我们提出了什么要求。现在男生对小姑娘的称呼，使用频率最高的应该是“美女”了吧，你在大街上叫一声：“嗨，美女！”估计10个有8个回头，其中包括那位著名的如花。美女的标准各不相同，首先就需要定义一下什么是美女：首先要面貌好看，其次是身材要窈窕，然后要有气质，当然了，这三者各人的排列顺序不一样，总之要成为一名美女就必须具备：面貌、身材和气质，我们用类图体现一下星探（当然，你也可以把自己想象成星探）找美女的过程。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215013157868.png" alt="image-20221215013157868"></p><p>定义了一个IPettyGirl接口，声明所有的美女都应该有goodLooking、niceFigure和greatTemperament，然后又定义了一个抽象类AbstractSearcher，其作用就是搜索美女并显示其信息，只要美女都按照这个规范定义，Searcher（星探）就轻松多了。</p><p><strong>美女类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPettyGirl</span> &#123;<br>    <span class="hljs-comment">//要有姣好的面孔</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//要有好身材</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//要有气质</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>美女实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PettyGirl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPettyGirl</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//美女都有名字</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PettyGirl</span><span class="hljs-params">(String _name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=_name;<br>    &#125;<br>    <span class="hljs-comment">//脸蛋漂亮</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---脸蛋很漂亮!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//气质要好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---气质非常好!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//身材要好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---身材非常棒!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过三个方法，把对美女的要求都定义出来了，按照这个标准，如花姑娘被排除在美女标准之外了。有美女，就有搜索美女的星探。</p><p><strong>星探抽象类源代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSearcher</span> &#123;<br>    <span class="hljs-keyword">protected</span> IPettyGirl pettyGirl;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractSearcher</span><span class="hljs-params">(IPettyGirl _pettyGirl)</span>&#123;<br>        <span class="hljs-built_in">this</span>.pettyGirl = _pettyGirl;<br>    &#125;<br>    <span class="hljs-comment">//搜索美女，列出美女信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>星探类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Searcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSearcher</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Searcher</span><span class="hljs-params">(IPettyGirl _pettyGirl)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_pettyGirl);<br>    &#125;<br>    <span class="hljs-comment">//展示美女的信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;--------美女的信息如下：---------------&quot;</span>);<br>        <span class="hljs-comment">//展示面容</span><br>        <span class="hljs-built_in">super</span>.pettyGirl.goodLooking();<br>        <span class="hljs-comment">//展示身材</span><br>        <span class="hljs-built_in">super</span>.pettyGirl.niceFigure();<br>        <span class="hljs-comment">//展示气质</span><br>        <span class="hljs-built_in">super</span>.pettyGirl.greatTemperament();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>场景中的两个角色美女和星探都已经出现了，需要写一个场景类来串联起各个角色。</p><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-comment">//搜索并展示美女信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义一个美女</span><br>        <span class="hljs-type">IPettyGirl</span> <span class="hljs-variable">yanYan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PettyGirl</span>(<span class="hljs-string">&quot;嫣嫣&quot;</span>);<br>        <span class="hljs-type">AbstractSearcher</span> <span class="hljs-variable">searcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Searcher</span>(yanYan);<br>        searcher.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>——–美女的信息如下：—————</p><p>嫣嫣—脸蛋很漂亮!</p><p>嫣嫣—身材非常棒!</p><p>嫣嫣—气质非常好!</p></blockquote><p>思考一下IPettyGirl这个接口，这个接口是否做到了最优化设计？</p><p>我们的审美观点都在改变，美女的定义也在变化。唐朝的杨贵妃如果活在现在这个年代非羞愧而死不可，为什么？胖呀！但是胖并不影响她入选中国四大美女，说明当时的审美观与现在是有差异的。当然，随着时代的发展我们的审美观也在变化，当你发现有一个女孩，脸蛋不怎么样，身材也一般般，但是气质非常好，我相信大部分人都会把这样的女孩叫美女，审美素质提升了，就产生了气质型美女，但是我们的接口却定义了美女必须是三者都具备，按照这个标准，气质型美女就不能算美女，那怎么办？可能你要说了，我重新扩展一个美女类，只实现greatTemperament方法，其他两个方法置空，什么都不写，不就可以了吗？聪明，但是行不通！为什么呢？星探AbstractSearcher依赖的是IPettyGirl接口，它有三个方法，你只实现了两个方法，星探的方法是不是要修改？我们上面的程序打印出来的信息少了两条，还让星探怎么去辨别是不是美女呢？</p><p>分析到这里，我们发现接口IPettyGirl的设计是有缺陷的，过于庞大了，容纳了一些可变的因素，根据接口隔离原则，星探AbstractSearcher应该依赖于具有部分特质的女孩子，而我们却把这些特质都封装了起来，放到了一个接口中，封装过度了！问题找到了，我们重新设计一下类图。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215013744728.png" alt="image-20221215013744728"></p><p>把原IPettyGirl接口拆分为两个接口，一种是外形美的美女IGoodBodyGirl，这类美女的特点就是脸蛋和身材极棒，超一流，但是没有审美素质，比如随地吐痰，文化程度比较低；</p><p>另外一种是气质美的美女IGreatTemperamentGirl，谈吐和修养都非常高。</p><p>我们把一个比较臃肿的接口拆分成了两个专门的接口，灵活性提高了，可维护性也增加了，不管以后是要外形美的美女还是气质美的美女都可以轻松地通过PettyGirl定义。</p><p><strong>两种类型的美女定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGoodBodyGirl</span> &#123;<br>    <span class="hljs-comment">//要有姣好的面孔</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//要有好身材</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGreatTemperamentGirl</span> &#123;<br>    <span class="hljs-comment">//要有气质</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>按照脸蛋、身材、气质都具备才算美女，实现类实现两个接口</p><p><strong>最标准的美女：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PettyGirl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IGoodBodyGirl</span>,IGreatTemperamentGirl &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//美女都有名字</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PettyGirl</span><span class="hljs-params">(String _name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=_name;<br>    &#125;<br>    <span class="hljs-comment">//脸蛋漂亮</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---脸蛋很漂亮!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//气质要好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---气质非常好!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//身材要好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;---身材非常棒!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这样的重构以后，不管以后是要气质美女还是要外形美女，都可以保持接口的稳定。当然，你可能要说了，以后可能审美观点再发生改变，只有脸蛋好看就是美女，那这个IGoodBody接口还是要修改的呀，确实是，但是设计是有限度的，不能无限地考虑未来的变更情况，否则就会陷入设计的泥潭中而不能自拔。</p><p>以上把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，让星探AbstractSearcher依赖两个专用的接口比依赖一个综合的接口要灵活。接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。</p><p><strong>定义：</strong></p><p>接口隔离原则是对接口进行规范约束，其包含以下4层含义：</p><ul><li>接口要尽量小</li><li>接口要高内聚</li><li>定制服务</li><li>接口设计是有限度的</li></ul><h2 id="五、迪米特法则"><a href="#五、迪米特法则" class="headerlink" title="五、迪米特法则"></a>五、迪米特法则</h2><blockquote><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least KnowledgePrinciple，LKP）</p></blockquote><p>虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。</p><p>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。</p><p><strong>定义：</strong></p><ol><li><strong>只和朋友交流</strong></li></ol><p>迪米特法则还有一个英文解释是：Only talk to your immediate friends（只与直接的朋友通信。）</p><p><strong>示例：</strong></p><p>老师想让体育委员确认一下全班女生来齐没有，就对他说：“你去把全班女生清一下。”</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215015101115.png" alt="image-20221215015101115"></p><p>Teacher类的commond方法负责发送命令给体育会员，命令他清点女生。</p><p><strong>老师类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-comment">//老师对学生发布命令，清一下女生</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commond</span><span class="hljs-params">(GroupLeader groupLeader)</span>&#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">listGirls</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">//初始化女生</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>            listGirls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>());<br>        &#125;<br>        <span class="hljs-comment">//告诉体育委员开始执行清查任务</span><br>        groupLeader.countGirls(listGirls);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>老师只有一个方法commond，先定义出所有的女生，然后发布命令给体育委员，去清点一下女生的数量。</p><p><strong>体育委员类实现过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupLeader</span> &#123;<br>    <span class="hljs-comment">//清查女生数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countGirls</span><span class="hljs-params">(List&lt;Girl&gt; listGirls)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;女生数量是：&quot;</span>+listGirls.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>老师类和体育委员类都对女生类产生依赖，而且女生类不需要执行任何动作。</p><p><strong>女生类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>故事中的三个角色都已经有了，再定义一个场景类来描述这个故事：</p><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Teacher teacher= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        <span class="hljs-comment">//老师发布命令</span><br>        teacher.commond(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupLeader</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>女生数量是：20</p></blockquote><p>体育委员按照老师的要求对女生进行了清点，并得出了数量。我们回过头来思考一下这个程序有什么问题，首先确定Teacher类有几个朋友类，它仅有一个朋友类——</p><p>GroupLeader。为什么Girl不是朋友类呢？Teacher也对它产生了依赖关系呀！</p><p>朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类，而Girl这个类就是出现在commond方法体内，因此不属于Teacher类的朋友类。</p><p>迪米特法则告诉我们一个类只和朋友类交流，但是我们刚刚定义的commond方法却与Girl类有了交流，声明了一个<code>List&lt;Girls&gt;</code>动态数组，也就是与一个陌生的类Girl有了交流，这样就破坏了Teacher的健壮性。方法是类的一个行为，类竟然不知道自己的行为与其他类产生依赖关系，这是不允许的，严重违反了迪米特法则。</p><p>问题已经发现，我们修改一下程序，将类图稍作修改。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215015414863.png" alt="image-20221215015414863"></p><p>在类图中去掉Teacher对Girl类的依赖关系</p><p><strong>修改后的老师类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-comment">//老师对学生发布命令，清一下女生</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commond</span><span class="hljs-params">(GroupLeader groupLeader)</span>&#123;<br>        <span class="hljs-comment">//告诉体育委员开始执行清查任务</span><br>        groupLeader.countGirls();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>修改后的体育委员类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupLeader</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Girl&gt; listGirls;<br>    <span class="hljs-comment">//传递全班的女生进来</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GroupLeader</span><span class="hljs-params">(List&lt;Girl&gt; _listGirls)</span>&#123;<br>        <span class="hljs-built_in">this</span>.listGirls = _listGirls;<br>    &#125;<br>    <span class="hljs-comment">//清查女生数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countGirls</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;女生数量是：&quot;</span>+<span class="hljs-built_in">this</span>.listGirls.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在GroupLeader类中定义了一个构造函数，通过构造函数传递了依赖关系</p><p><strong>修改后的场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//产生一个女生群体</span><br>        List&lt;Girl&gt; listGirls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Girl&gt;();<br>        <span class="hljs-comment">//初始化女生</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>            listGirls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>());<br>        &#125;<br>        Teacher teacher= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        <span class="hljs-comment">//老师发布命令</span><br>        teacher.commond(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupLeader</span>(listGirls));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对程序进行了简单的修改，把Teacher中对<code>List&lt;Girl&gt;</code>的初始化移动到了场景类中，同时在GroupLeader中增加了对Girl的注入，避开了Teacher类对陌生类Girl的访问，降低了系统间的耦合，提高了系统的健壮性。</p><p><strong>注意：</strong>一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。</p><ol start="2"><li><strong>朋友间也是有距离的</strong></li></ol><p><strong>示例：</strong></p><p>我们在安装软件的时候，经常会有一个导向动作，第一步是确认是否安装，第二步确认License，再然后选择安装目录……这是一个典型的顺序执行动作，具体到程序中就是：调用一个或多个类，先执行第一个方法，然后是第二个方法，根据返回结果再来看是否可以调用第三个方法，或者第四个方法，等等</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215015851748.png" alt="image-20221215015851748"></p><p>很简单的类图，实现软件安装的过程，其中first方法定义第一步做什么，second方法定义第二步做什么，third方法定义第三步做什么。</p><p><strong>导向类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wizard</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(System.currentTimeMillis());<br>    <span class="hljs-comment">//第一步</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第一个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-comment">//第二步</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第二个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-comment">//第三个方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">third</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第三个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Wizard类中分别定义了三个步骤方法，每个步骤中都有相关的业务逻辑完成指定的任务，我们使用一个随机函数来代替业务执行的返回值。</p><p><strong>InstallSoftware类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstallSoftware</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installWizard</span><span class="hljs-params">(Wizard wizard)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> wizard.first();<br>        <span class="hljs-comment">//根据first返回的结果，看是否需要执行second</span><br>        <span class="hljs-keyword">if</span>(first&gt;<span class="hljs-number">50</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> wizard.second();<br>            <span class="hljs-keyword">if</span>(second&gt;<span class="hljs-number">50</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">third</span> <span class="hljs-operator">=</span> wizard.third();<br>                <span class="hljs-keyword">if</span>(third &gt;<span class="hljs-number">50</span>)&#123;<br>                    wizard.first();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InstallSoftware</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstallSoftware</span>();<br>        invoker.installWizard(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上程序很简单，运行结果和随机数有关，每次的执行结果都不相同，需要读者自己运行并查看结果。程序虽然简单，但是隐藏的问题可不简单，思考一下程序有什么问题。</p><p>Wizard类把太多的方法暴露给InstallSoftware类，两者的朋友关系太亲密了，耦合关系变得异常牢固。如果要将Wizard类中的first方法返回值的类型由int改为boolean，就需要修改InstallSoftware类，从而把修改变更的风险扩散开了。因此，这样的耦合是极度不合适的，我们需要对设计进行重构，</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215020213522.png" alt="image-20221215020213522"></p><p>在Wizard类中增加一个installWizard方法，对安装过程进行封装，同时把原有的三个<strong>public</strong>方法修改为<strong>private</strong>方法，</p><p><strong>修改后的导向类实现过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wizard</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(System.currentTimeMillis());<br>    <span class="hljs-comment">//第一步</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第一个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-comment">//第二步</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第二个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-comment">//第三个方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">third</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行第三个方法...&quot;</span>);<br>        <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//软件安装过程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installWizard</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.first();<br>        <span class="hljs-comment">//根据first返回的结果，看是否需要执行second</span><br>        <span class="hljs-keyword">if</span>(first&gt;<span class="hljs-number">50</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.second();<br>            <span class="hljs-keyword">if</span>(second&gt;<span class="hljs-number">50</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">third</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.third();<br>                <span class="hljs-keyword">if</span>(third &gt;<span class="hljs-number">50</span>)&#123;<br>                    <span class="hljs-built_in">this</span>.first();<br>            &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将三个步骤的访问权限修改为private，同时把InstallSoftware中的方法installWizad移动到Wizard方法中。通过这样的重构后，Wizard类就只对外公布了一个public方法，即使要修改first方法的返回值，影响的也仅仅只是Wizard本身，其他类不受影响，这显示了类的高内聚特性。</p><p>对InstallSoftware类进行少量的修改。</p><p><strong>修改后的InstallSoftware类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstallSoftware</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installWizard</span><span class="hljs-params">(Wizard wizard)</span>&#123;<br>        <span class="hljs-comment">//直接调用</span><br>        wizard.installWizard();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过进行重构，类间的耦合关系变弱了，结构也清晰了，变更引起的风险。</p><p>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。</p><p><strong>注意：</strong></p><p>迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。</p><ol start="3"><li><strong>是自己的就是自己的</strong></li></ol><p>在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？</p><p>你可以坚持这样一个原则：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。</p><ol start="4"><li><strong>谨慎使用Serializable</strong></li></ol><p>在实际应用中，这个问题是很少出现的，即使出现也会立即被发现并得到解决。是怎么回事呢？举个例子来说，在一个项目中使用RMI（Remote Method Invocation，远程方法调用）方式传递一个VO（Value Object，值对象），这个对象就必须实现Serializable接口（仅仅是一个标志性接口，不需要实现具体的方法），也就是把需要网络传输的对象进行序列化，否则就会出现NotSerializableException异常。突然有一天，客户端的VO修改了一个属性的访问权限，从private变更为public，访问权限扩大了，如果服务器上没有做出相应的变更，就会报序列化失败，就这么简单。但是这个问题的产生应该属于项目管理范畴，一个类或接口在客户端已经变更了，而服务器端却没有同步更新，难道不是项目管理的失职吗？</p><h2 id="六、开闭原则"><a href="#六、开闭原则" class="headerlink" title="六、开闭原则"></a>六、开闭原则</h2><p><strong>定义：</strong>Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）</p><p>软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</p><p><strong>示例：</strong></p><p>以书店销售书籍为例</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215021804080.png" alt="image-20221215021804080"></p><p>IBook定义了数据的三个属性：名称、价格和作者。小说类NovelBook是一个具体的实现类，是所有小说书籍的总称，BookStore指的是书店。</p><p>书籍接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBook</span> &#123;<br>    <span class="hljs-comment">//书籍有名称</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//书籍有售价</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//书籍有作者</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAuthor</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>目前书店只出售小说类书籍。</p><p>小说类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NovelBook</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBook</span> &#123;<br>    <span class="hljs-comment">//书籍名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//书籍的价格</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> price;<br>    <span class="hljs-comment">//书籍的作者</span><br>    <span class="hljs-keyword">private</span> String author;<br>    <span class="hljs-comment">//通过构造函数传递书籍数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NovelBook</span><span class="hljs-params">(String _name,<span class="hljs-type">int</span> _price,String _author)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = _name;<br>        <span class="hljs-built_in">this</span>.price = _price;<br>        <span class="hljs-built_in">this</span>.author = _author;<br>    &#125;<br>    <span class="hljs-comment">//获得作者是谁</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAuthor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.author;<br>    &#125;<br>    <span class="hljs-comment">//书籍叫什么名字</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>    <span class="hljs-comment">//获得书籍的价格</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.price;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>书店售书类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> ArrayList&lt;IBook&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;IBook&gt;();<br>    <span class="hljs-comment">//static静态模块初始化数据，实际项目中一般是由持久层完成</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;天龙八部&quot;</span>,<span class="hljs-number">3200</span>,<span class="hljs-string">&quot;金庸&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;巴黎圣母院&quot;</span>,<span class="hljs-number">5600</span>,<span class="hljs-string">&quot;雨果&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;悲惨世界&quot;</span>,<span class="hljs-number">3500</span>,<span class="hljs-string">&quot;雨果&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;JPM&quot;</span>,<span class="hljs-number">4300</span>,<span class="hljs-string">&quot;兰陵笑笑生&quot;</span>));<br>    &#125;<br>    <span class="hljs-comment">//模拟书店买书</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> NumberFormat.getCurrencyInstance();<br>        formatter.setMaximumFractionDigits(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;-----------书店卖出去的书籍记录如下：-----------&quot;</span>);<br>        <span class="hljs-keyword">for</span>(IBook book:bookList)&#123;<br>            System.out.println(<span class="hljs-string">&quot;书籍名称：&quot;</span> + book.getName()+<span class="hljs-string">&quot;\t书籍作者：&quot;</span> +<br>            book.getAuthor()+<span class="hljs-string">&quot;\t书籍价格：&quot;</span>+ formatter.format (book.getPrice()/<br>            <span class="hljs-number">100.0</span>)+<span class="hljs-string">&quot;元&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>—————–书店卖出去的书籍记录如下：————–</p><p>书籍名称：天龙八部 书籍作者：金庸 书籍价格：￥25.60元</p><p>书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：￥50.40元</p><p>书籍名称：悲惨世界 书籍作者：雨果 书籍价格：￥28.00元</p><p>书籍名称：JPM 书籍作者：兰陵笑笑生 书籍价格：￥38.70元</p></blockquote><p>项目投产了，书籍正常销售出去，书店也赢利了。从2008年开始，全球经济开始下滑，对零售业影响比较大，书店为了生存开始打折销售：所有40元以上的书籍9折销售，其他的8折销售。对已经投产的项目来说，这就是一个变化，我们应该如何应对这样一个需求变化？</p><ul><li>修改接口</li></ul><p>在IBook上新增加一个方法getOffPrice()，专门用于进行打折处理，所有的实现类实现该方法。但是这样修改的后果就是，实现类NovelBook要修改，BookStore中的main方法也修改，同时IBook作为接口应该是稳定且可靠的，不应该经常发生变化，否则接口作为契约的作用就失去了效能。因此，该方案否定。</p><ul><li>修改实现类</li></ul><p>修改NovelBook类中的方法，直接在getPrice()中实现打折处理，好办法，我相信大家在项目中经常使用的就是这样的办法，通过class文件替换的方式可以完成部分业务变化（或是缺陷修复）。该方法在项目有明确的章程（团队内约束）或优良的架构设计时，是一个非常优秀的方法，但是该方法还是有缺陷的。例如采购书籍人员也是要看价格的，由于该方法已经实现了打折处理价格，因此采购人员看到的也是打折后的价格，会因信息不对称而出现决策失误的情况。因此，该方案也不是一个最优的方案。</p><ul><li>通过扩展实现变化</li></ul><p>增加一个子类OffNovelBook，覆写getPrice方法，高层次的模块（也就是static静态模块区）通过OffNovelBook类产生新的对象，完成业务变化对系统的最小化开发。好办法，修改也少，风险也小</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221215022202797.png" alt="image-20221215022202797"></p><p>OffNovelBook类继承了NovelBook，并覆写了getPrice方法，不修改原有的代码。</p><p>打折销售的小说类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OffNovelBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NovelBook</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OffNovelBook</span><span class="hljs-params">(String _name,<span class="hljs-type">int</span> _price,String _author)</span>&#123;<br>        <span class="hljs-built_in">super</span>(_name,_price,_author);<br>    &#125;<br>    <span class="hljs-comment">//覆写销售价格</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//原价</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">selfPrice</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.getPrice();<br>        <span class="hljs-type">int</span> offPrice=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(selfPrice&gt;<span class="hljs-number">4000</span>)&#123; <span class="hljs-comment">//原价大于40元，则打9折</span><br>            offPrice = selfPrice * <span class="hljs-number">90</span> /<span class="hljs-number">100</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            offPrice = selfPrice * <span class="hljs-number">80</span> /<span class="hljs-number">100</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> offPrice;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很简单，仅仅覆写了getPrice方法，通过扩展完成了新增加的业务。</p><p>书店打折销售类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> ArrayList&lt;IBook&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;IBook&gt;();<br>    <span class="hljs-comment">//static静态模块初始化数据，实际项目中一般是由持久层完成</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;天龙八部&quot;</span>,<span class="hljs-number">3200</span>,<span class="hljs-string">&quot;金庸&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;巴黎圣母院&quot;</span>,<span class="hljs-number">5600</span>,<span class="hljs-string">&quot;雨果&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;悲惨世界&quot;</span>,<span class="hljs-number">3500</span>,<span class="hljs-string">&quot;雨果&quot;</span>));<br>        bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;JPM&quot;</span>,<span class="hljs-number">4300</span>,<span class="hljs-string">&quot;兰陵笑笑生&quot;</span>));<br>    &#125;<br>    <span class="hljs-comment">//模拟书店买书</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> NumberFormat.getCurrencyInstance();<br>        formatter.setMaximumFractionDigits(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;-----------书店卖出去的书籍记录如下：-----------&quot;</span>);<br>        <span class="hljs-keyword">for</span>(IBook book:bookList)&#123;<br>            System.out.println(<span class="hljs-string">&quot;书籍名称：&quot;</span> + book.getName()+<span class="hljs-string">&quot;\t书籍作者：&quot;</span> + book.getAuthor()+ <span class="hljs-string">&quot;\t书籍价格：&quot;</span> + formatter.format (book.getPrice()/<span class="hljs-number">100.0</span>)+<span class="hljs-string">&quot;元&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只修改了粗体部分，其他的部分没有任何改动，运行结果如下所示。</p><blockquote><p>———————-书店卖出去的书籍记录如下：———————</p><p>书籍名称：天龙八部 书籍作者：金庸 书籍价格：￥25.60元</p><p>书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：￥50.40元</p><p>书籍名称：悲惨世界 书籍作者：雨果 书籍价格：￥28.00元</p><p>书籍名称：JPM 书籍作者：兰陵笑笑生 书籍价格：￥38.70元</p></blockquote><p>OK，打折销售开发完成了。看到这里，各位可能有想法了：增加了一个OffNoveBook类后，你的业务逻辑还是修改了，你修改了static静态模块区域。这部分确实修改了，该部分属于高层次的模块，是由持久层产生的，在业务规则改变的情况下高层模块必须有部分改变以适应新业务，改变要尽量地少，防止变化风险的扩散。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务</title>
    <link href="/2022/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/11/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="微服务基础"><a href="#微服务基础" class="headerlink" title="微服务基础"></a>微服务基础</h2><h3 id="系统架构的演变"><a href="#系统架构的演变" class="headerlink" title="系统架构的演变"></a>系统架构的演变</h3><p>随着互联网的发展，网站应用的规模不断扩大，常规的应用架构已无法应对，分布式服务架构以及微服务架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p><p>例：一个电商系统包含多个模块</p><h4 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h4><p>Web应用程序发展的早期，大部分web工程(包含前端页面,web层代码,service层代码,dao层代码)是将所有的功能模块,打包到一起并放在一个web容器中运行。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022182714476.png" alt="image-20221022182714476"></p><p>比如搭建一个电商系统：客户下订单，商品展示，用户管理。这种将所有功能都部署在一个web容器中运行的系统就叫做单体架构。</p><p>优点：</p><ul><li>项目架构简单，前期开发成本低，周期短，小型项目的首选</li><li>所有功能集成在一个项目中</li></ul><p>缺点：</p><ul><li>全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。</li><li>系统性能扩展只能通过扩展集群结点，成本高、有瓶颈。</li><li>技术栈受限。</li></ul><h4 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h4><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率<img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022182850022.png" alt="image-20221022182850022"></p><p>优点：</p><ul><li>解决高并发问题，流量转向了不同的系统</li><li>针对不同模块的优化</li><li>方便水平扩展，和容错（例：用户出现问题不会影响商品系统和后台系统）。</li></ul><p>缺点：</p><ul><li>系统间相互独立（如果用户想用商品系统，调用是一个问题）</li><li>有很多重复开发工作</li></ul><h4 id="分布式SOA架构"><a href="#分布式SOA架构" class="headerlink" title="分布式SOA架构"></a>分布式SOA架构</h4><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183024749.png" alt="image-20221022183024749"></p><p>优点：</p><ul><li>抽取公共的功能为服务，提高开发效率</li><li>对不同的服务进行集群化部署解决系统压力</li><li>基于ESB&#x2F;DUBBO减少系统耦合</li></ul><p>缺点：</p><ul><li>抽取服务的粒度较大</li><li>服务提供方与调用方接口耦合度较高</li></ul><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183051081.png" alt="image-20221022183051081"></p><p>优点：</p><ul><li>通过服务的原子化拆分，以及微服务的独立打包、部署和升级，小团队的交付周期将缩短，运维成本也将大幅度下降</li><li>微服务遵循单一原则，微服务之间采用Restful等轻量协议传输</li></ul><p>缺点：</p><ul><li>微服务过多，服务治理成本高，不利于系统维护。</li><li>分布式系统开发的技术成本高（容错、分布式事务等）</li></ul><h4 id="SOA和微服务的关系"><a href="#SOA和微服务的关系" class="headerlink" title="SOA和微服务的关系"></a>SOA和微服务的关系</h4><ul><li>**SOA(Service oriented Architecture)“面向服务的架构”**：他是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用。</li><li><strong>微服务架构</strong>：其实和SOA架构类似微服务是在SOA上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。</li></ul><table><thead><tr><th>功能</th><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td>组件大小</td><td>大块业务逻辑</td><td>单独任务或小块业务逻辑</td></tr><tr><td>耦合</td><td>通常松耦合</td><td>总是松耦合</td></tr><tr><td>公司架构</td><td>任何类型</td><td>小型、专注于功能交叉团队</td></tr><tr><td>管理</td><td>着重中央管理</td><td>着重分散管理</td></tr><tr><td>目标</td><td>确保应用能够交互操作</td><td>执行新功能、快速拓展开发团队</td></tr></tbody></table><h3 id="分布式核心知识"><a href="#分布式核心知识" class="headerlink" title="分布式核心知识"></a>分布式核心知识</h3><h4 id="分布式中的远程调用"><a href="#分布式中的远程调用" class="headerlink" title="分布式中的远程调用"></a>分布式中的远程调用</h4><p>远程调用：</p><p>​<img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20220921001823614.png" alt="image-20220921001823614"></p><h5 id="RPC协议"><a href="#RPC协议" class="headerlink" title="RPC协议"></a>RPC协议</h5><p><strong>RPC</strong>（Remote Procedure Call ） 一种进程间通信方式。允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式（TCP或者UDP）、序列化方式（XML&#x2F;JSON&#x2F;二进制）和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183346046.png" alt="image-20221022183346046"></p><h5 id="HTTP-Restful接口"><a href="#HTTP-Restful接口" class="headerlink" title="HTTP-Restful接口"></a>HTTP-Restful接口</h5><p>REST，即Representational State Transfer的缩写，如果一个架构符合REST原则，就称它为RESTful架构。</p><p>RESTful架构：</p><ul><li>每一个URI代表一种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现层；</li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ul><h5 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h5><table><thead><tr><th>比较项</th><th>RESTful</th><th>RPC</th></tr></thead><tbody><tr><td>通讯协议</td><td>HTTP</td><td>一般使用TCP</td></tr><tr><td>性能</td><td>略低</td><td>较高</td></tr><tr><td>灵活度</td><td>高</td><td>低</td></tr><tr><td>应用</td><td>微服务架构</td><td>SOA架构</td></tr></tbody></table><ol><li>HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。</li><li>RPC框架作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。</li></ol><h4 id="分布式中的CAP原理"><a href="#分布式中的CAP原理" class="headerlink" title="分布式中的CAP原理"></a>分布式中的CAP原理</h4><p>现如今，对于多数大型互联网应用，分布式系统（distributed system）正变得越来越重要。分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183526516.png" alt="image-20221022183526516"></p><p><strong>Consistency（一致性）</strong>：数据一致更新，所有数据的变化都是同步的</p><p><strong>Availability（可用性）</strong>：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求</p><p><strong>Partition tolerance（分区容忍性）</strong>：某个节点的故障，并不影响整个系统的运行</p><blockquote><p>通过学习CAP理论，我们得知任何分布式系统只可同时满足二点，没法三者兼顾，既然一个分布式系统无法同时满足一致性、可用性、分区容错性三个特点，所以我们就需要抛弃一样：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183625865.png" alt="image-20221022183625865"></p></blockquote><table><thead><tr><th>选择</th><th>说明</th></tr></thead><tbody><tr><td>CA</td><td>放弃分区容错性，加强一致性和可用性，其实就是传统的关系型数据库的选择</td></tr><tr><td>AP</td><td>放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td></tr><tr><td>CP</td><td>放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td></tr></tbody></table><p>需要明确一点的是，在一个分布式系统当中，分区容忍性和可用性是最基本的需求，所以在分布是系统中，我们的系统最当关注的就是A（可用性）P（容忍性），通过补偿的机制寻求数据的一致性</p><h3 id="常见微服务框架"><a href="#常见微服务框架" class="headerlink" title="常见微服务框架"></a>常见微服务框架</h3><p>SpringCloud、ServiceComb、ZeroC ICE</p><h4 id="微服务中的相关概念"><a href="#微服务中的相关概念" class="headerlink" title="微服务中的相关概念"></a>微服务中的相关概念</h4><h5 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h5><p><strong>服务注册</strong>：服务实例将自身服务信息注册到注册中心。这部分服务信息包括服务所在主机IP和提供服务的Port，以及暴露服务自身状态以及访问协议等信息。</p><p><strong>服务发现</strong>：服务实例请求注册中心获取所依赖服务信息。服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104000810699.png" alt="image-20221104000810699"></p><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104000850657.png" alt="image-20221104000850657"></p><h5 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h5><p><strong>熔断</strong>这一概念来源于电子工程中的断路器（Circuit Breaker）。在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104000927961.png" alt="image-20221104000927961"></p><h5 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h5><p>随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。因此，就需要对一次请求涉及的多个服务链路进行日志记录，性能监控即<strong>链路追踪</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104000959599.png" alt="image-20221104000959599"></p><h5 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h5><p>随着微服务的不断增多，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信可能出现：</p><ul><li><p>客户端需要调用不同的url地址，增加难度</p></li><li><p>在一定的场景下，存在跨域请求的问题</p></li><li><p>每个微服务都需要进行单独的身份认证</p></li></ul><p>针对这些问题，API网关顺势而生。</p><p><strong>API网关</strong>直面意思是将所有API调用统一接入到API网关层，由网关层统一接入和输出。一个网关的基本功能有：统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力。有了网关之后，各个API服务提供团队可以专注于自己的的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104001201911.png" alt="image-20221104001201911"></p><h4 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022184638558.png" alt="image-20221022184638558"></p><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如<strong>服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控</strong>等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><h4 id="SpringCloud核心组件"><a href="#SpringCloud核心组件" class="headerlink" title="SpringCloud核心组件"></a>SpringCloud核心组件</h4><p><strong>Spring Cloud</strong>的本质是在 Spring Boot 的基础上，增加了一堆微服务相关的规范，并对应用上下文（Application Context）进行了功能增强。既然 Spring Cloud 是规范，那么就需要去实现，目前Spring Cloud 规范已有 Spring官方，Spring Cloud Netflflix，Spring Cloud Alibaba等实现。通过组件化的方式，Spring Cloud将这些实现整合到一起构成全家桶式的微服务技术栈。</p><h6 id="SpringCloud-Netflix"><a href="#SpringCloud-Netflix" class="headerlink" title="SpringCloud Netflix"></a>SpringCloud Netflix</h6><table><thead><tr><th>组件名称</th><th>作用</th></tr></thead><tbody><tr><td>Eureka</td><td>服务注册中心</td></tr><tr><td>Ribbon</td><td>客户端负载均衡</td></tr><tr><td>Feign</td><td>声明式服务调用</td></tr><tr><td>Hystrix</td><td>客户端容错保护</td></tr><tr><td>Zuul</td><td>API服务网关</td></tr></tbody></table><h6 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h6><table><thead><tr><th>组件名称</th><th>作用</th></tr></thead><tbody><tr><td>Nacos</td><td>服务注册中心</td></tr><tr><td>Sentinel</td><td>客户端容错保护</td></tr></tbody></table><h6 id="SpringCloud原生及其他组件："><a href="#SpringCloud原生及其他组件：" class="headerlink" title="SpringCloud原生及其他组件："></a>SpringCloud原生及其他组件：</h6><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>Consul</td><td>服务注册中心</td></tr><tr><td>Config</td><td>分布式配置中心</td></tr><tr><td>Gateway</td><td>API服务网关</td></tr><tr><td>Sleuth&#x2F;Zipkin</td><td>分布式链路追踪</td></tr></tbody></table><h4 id="SpringCloud体系结构"><a href="#SpringCloud体系结构" class="headerlink" title="SpringCloud体系结构"></a>SpringCloud体系结构</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022184937835.png" alt="image-20221022184937835"></p><p>从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。</p><ul><li><p><strong>注册中心</strong>负责服务的注册与发现，很好将各服务连接起来</p></li><li><p><strong>断路器</strong>负责监控服务之间的调用情况，连续多次失败进行熔断保护。</p></li><li><p><strong>API网关</strong>负责转发所有对外的请求和服务</p></li><li><p><strong>配置中心</strong>提供了统一的配置信息管理服务,可以实时的通知各个服务获取最新的配置信息<strong>链路追踪技术</strong>可以将所有的请求数据记录下来，方便我们进行后续分析</p></li><li><p>各个组件又提供了功能完善的<strong>dashboard监控平台</strong>,可以方便的监控各组件的运行状况</p></li></ul><h4 id="模拟微服务存在的问题"><a href="#模拟微服务存在的问题" class="headerlink" title="模拟微服务存在的问题"></a>模拟微服务存在的问题</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022185050581.png" alt="image-20221022185050581"></p><ol><li>将微服务的请求路径硬编码到Java代码中</li><li>对微服务调用的负载均衡</li><li>加入API网关</li><li>配置的统一管理</li><li>链路追踪：方便定位可能出现的问题</li></ol><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，到这里找到服务的地址，进行调用。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022185117179.png" alt="image-20221022185117179"></p><h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h3><ol><li><p>服务发现：</p><ul><li><p>服务注册&#x2F;反注册：保存服务提供者和服务调用者的信息</p></li><li><p>服务订阅&#x2F;取消订阅：服务调用者订阅服务提供者的信息，最好有实时推送的功能</p></li><li><p>服务路由（可选）：具有筛选整合服务提供者的能力。</p></li></ul></li><li><p>服务配置：</p><ul><li><p>配置订阅：服务提供者和服务调用者订阅微服务相关的配置</p></li><li><p>配置下发：主动将配置推送给服务提供者和服务调用者</p></li></ul></li><li><p>服务健康检测</p><ul><li>检测服务提供者的健康情况</li></ul></li></ol><h3 id="常见的注册中心"><a href="#常见的注册中心" class="headerlink" title="常见的注册中心"></a>常见的注册中心</h3><ul><li>zookeeper</li><li>eureka</li><li>consul</li><li>Nacos</li></ul><table><thead><tr><th>组件名</th><th>语言</th><th>CAP</th><th>一致性算法</th><th>服务健康检查</th><th>对外暴露接口</th></tr></thead><tbody><tr><td>Eureka</td><td>Java</td><td>AP</td><td>无</td><td>可配支持</td><td>HTTP</td></tr><tr><td>Consul</td><td></td><td>CP</td><td>Raft</td><td>支持</td><td>HTTP&#x2F;DNS</td></tr><tr><td>Zookeeper</td><td>Java</td><td>CP</td><td>Paxos</td><td>支持</td><td>客户端</td></tr><tr><td>Nacos</td><td>Java</td><td>AP</td><td>Raft</td><td>支持</td><td>HTTP</td></tr></tbody></table><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Eureka是Netflflix开发的服务发现框架，SpringCloud将它集成在自己的子项目spring-cloud-netflix中，实现SpringCloud的服务发现功能。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022185246611.png" alt="image-20221022185246611"></p><p>上图简要描述了Eureka的基本架构，由3个角色组成：</p><ol><li>Eureka Server</li></ol><p>​提供服务注册和发现</p><ol start="2"><li>Service Provider</li></ol><p>​服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到</p><ol start="3"><li>Service Consumer</li></ol><p>​服务消费方从Eureka获取注册服务列表，从而能够消费服务</p><h3 id="Eureka的交互与原理"><a href="#Eureka的交互与原理" class="headerlink" title="Eureka的交互与原理"></a>Eureka的交互与原理</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104001904331.png" alt="image-20221104001904331"></p><p>图是来自Eureka官方的架构图，大致描述了Eureka集群的工作过程。图中包含的组件非常多，可能比较难以理解，我们用通俗易懂的语言解释一下：</p><ul><li>Application Service 相当于本书中的服务提供者，Application Client相当于服务消费者；</li><li>Make Remote Call，可以简单理解为调用RESTful API；</li><li>us-east-1c、us-east-1d等都是zone，它们都属于us-east-1这个region；</li></ul><p><strong>由图可知，Eureka包含两个组件：Eureka Server和Eureka Client，它们的作用如下：</strong></p><ul><li><p>Eureka Client是一个Java客户端，用于简化与Eureka Server的交互；</p></li><li><p>Eureka Server提供服务发现的能力，各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如网络信息），Eureka Server会存储该服务的信息；</p></li><li><p>微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为30秒）以续约自己的信息。如果Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（默认90秒）；</p></li><li><p>每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过复制的方式完成服务注册表的同步；</p></li><li><p>Eureka Client会缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。</p></li></ul><p>综上，Eureka通过心跳检测、健康检查和客户端缓存等机制，提高了系统的灵活性、可伸缩性和可用性。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li><p><strong>搭建eureka server</strong></p><p>1.1 创建工程并导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.2 配置application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>     <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br>   <span class="hljs-attr">server:</span><br>     <span class="hljs-attr">port:</span> <span class="hljs-number">8761</span> <span class="hljs-comment">#端口</span><br>   <span class="hljs-comment">#配置eureka server</span><br>   <span class="hljs-attr">eureka:</span><br>     <span class="hljs-attr">client:</span><br>       <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否将自己注册到注册中心</span><br>       <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否从eureka中获取注册信息</span><br>       <span class="hljs-attr">service-url:</span> <span class="hljs-comment">#配置暴露给Eureka Client的请求地址</span><br>         <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><p>1.3 配置启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br>   <span class="hljs-meta">@EnableEurekaServer</span> <span class="hljs-comment">//激活eurekaserver</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaServerApplication</span> &#123;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>           SpringApplication.run(EurekaServerApplication.class,args);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>1.4 <strong>服务注册中心管理后台</strong></p><p>打开浏览器访问<a href="http://localhost:8761即可进入EurekaServer内置的管理控制台，显示效果如下">http://localhost:8761即可进入EurekaServer内置的管理控制台，显示效果如下</a></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104002357554.png" alt="image-20221104002357554"></p></li><li><p><strong>将服务提供者注册到eureka server上</strong></p><p>2.1 引入Eureka Client相应坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artxmlifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.2 修改application.yml添加eureka server相关信息</p><p>在工程的<code>application.yml</code>中添加Eureka Server的主机地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#配置Eureka</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#使用ip地址注册</span><br></code></pre></td></tr></table></figure><p>2.3 修改启动类，添加服务发现的支持（可选）</p><blockquote><p>从Spring Cloud Edgware版本开始， <code>@EnableDiscoveryClient</code> 或 <code>@EnableEurekaClient</code> <strong>可省略</strong>。只需加上相关依赖，并进行相应配置，即可将微服务注册到服务发现组件上</p></blockquote></li><li><p><strong>服务消费者通过注册中心获取服务列表并调用</strong></p><p>Eureka中的原数据：服务的主机名，ip，等信息，可以通过eureka server进行获取，用于服务之间的调用注入DiscoveryClient，通过discoveryClient.getInstances(“服务名”)，可以拿到client的元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注入DiscoveryClient :</span><br><span class="hljs-comment"> *  springcloud提供的获取原数组的工具类</span><br><span class="hljs-comment"> *      调用方法获取服务的元数据信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/buy/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br><span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>   <span class="hljs-comment">// 调用discoveryClient方法</span><br>   <span class="hljs-comment">//已调用服务名称获取所有的元数据</span><br>   List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;service-product&quot;</span>);<br>   <span class="hljs-comment">//获取唯一的一个元数据</span><br>   <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> instances.get(<span class="hljs-number">0</span>);<br>   <span class="hljs-comment">//根据元数据中的主机地址和端口号拼接请求微服务的URL</span><br>   <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-comment">//如何调用商品服务?</span><br>   product = restTemplate.getForObject(<span class="hljs-string">&quot;http://&quot;</span>+instance.getHost()+<span class="hljs-string">&quot;:&quot;</span>+instance.getPort()+<span class="hljs-string">&quot;/product/1&quot;</span>,Product.class);<br>   <span class="hljs-keyword">return</span> product;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="Eureka-Server的高可用"><a href="#Eureka-Server的高可用" class="headerlink" title="Eureka Server的高可用"></a>Eureka Server的高可用</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022185611489.png" alt="image-20221022185611489"></p><ol><li><p><strong>准备两个Eureka Server，需要互相注册</strong></p><p>1号server：9000</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#模拟两个EurekaServer</span><br><span class="hljs-comment">#端口9000 , 8000</span><br><span class="hljs-comment">#两个server需要相互注册</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9000</span> <span class="hljs-comment">#端口</span><br><span class="hljs-comment">#配置eureka server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment">#配置暴露给Eureka Client的请求地址</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:8000/eureka/</span><br></code></pre></td></tr></table></figure><p>2号server：8000</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#模拟两个EurekaServer</span><br><span class="hljs-comment">#端口9000 , 8000</span><br><span class="hljs-comment">#两个server需要相互注册</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span> <span class="hljs-comment">#端口</span><br><span class="hljs-comment">#配置eureka server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment">#配置暴露给Eureka Client的请求地址</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:9000/eureka/</span><br></code></pre></td></tr></table></figure></li><li><p>需要将微服务注册到两个EurekaServer上</p></li></ol><p>​如果需要将微服务注册到Eureka Server集群只需要修改yml配置文件即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span><br> <span class="hljs-attr">client:</span><br>   <span class="hljs-attr">serviceUrl:</span><br>     <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka-server:8000/eureka/,http://eureka-server:9000/eureka/</span><br></code></pre></td></tr></table></figure><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><ol><li><p>在控制台显示服务IP</p><p>在服务提供者，通过<code>eureka.instance.instance-id</code>配置</p></li><li><p>服务的剔除问题</p><p>默认情况下，由于Eureka Server剔除失效服务间隔时间为90s且存在自我保护的机制。所以不能有效而迅速的剔除失效节点，这对开发或测试会造成困扰。解决方案如下：</p><p><strong>Eureka Client</strong>：</p><p>配置开启健康检查，并设置续约时间</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 客户端配置Eureka</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>  <span class="hljs-attr">healthcheck:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment">#开启健康检查(依赖spring-boot-actuator)</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:9000/eureka/</span> <span class="hljs-comment">#,http://localhost:8000/eureka/ 多个注册</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#使用ip地址注册</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;eureka.instance.prefer-ip-address&#125;:$&#123;server.port&#125;</span> <span class="hljs-comment">#向注册中心中注册服务id</span><br>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment">#发送心跳的间隔</span><br>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#续约到期时间</span><br></code></pre></td></tr></table></figure><p><strong>Eureka Server</strong>：</p><p>配置关闭自我保护，设置剔除无效节点的时间间隔</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭自我保护机制</span><br>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">4000</span> <span class="hljs-comment">#剔除服务间隔</span><br></code></pre></td></tr></table></figure></li><li><p>Eureka的自我保护机制</p><p>在测试阶段，为了效率更高，通过<code>enable-self-preservation</code>和<code>eviction-interval-timer-in-ms</code>，关闭自我保护机制。</p><blockquote><p>在eureka中，如果统计发现在15分钟之内，没有收到85%以上的客户端的心跳，就不会再对服务进行剔除了。</p><p>暂时把这些失效的服务保护起来，不让其过期，但这些服务也并不是永远不会过期。</p><p>Eureka在启动完成后，每隔60秒会检查一次服务健康状态，如果这些被保护起来失效的服务过一段时间后（默认90秒）还是没有恢复，就会把这些服务剔除。如果在此期间服务恢复了并且实例心跳占比高于85%时，就会自动关闭自我保护机制。</p></blockquote></li></ol><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ol><li><p>启动项目，通过<code>@SpringBootApplication</code>注解找到<code>@EnableAutoConfiguration</code>注解</p><p>↓</p></li><li><p>再找到<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>注解</p><p>↓</p></li><li><p>找到<code>AutoConfigurationImportSelector</code>类中的<code>selectImports()</code>方法，该方法不但读取了所有外部配置类，也可以读取自定义注解上自定义的配置类。</p><p>↓</p></li><li><p>方法中调用了<code>this.getAutoConfigurationEntry(annotationMetadata)</code>方法</p><p>↓</p></li><li><p>再进入<code>this.getCandidateConfigurations(annotationMetadata, attributes)</code>中</p><p>↓</p></li><li><p>通过<code>SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())</code>加载所有的外部配置类</p><p>↓</p></li><li><p>在<code>loadSpringFactories()</code>方法中<code>classLoader.getResources(&quot;META-INF/spring.factories&quot;)</code>加载所有的SpringBoot外部配置类</p><p>↓</p></li><li><p>spring.factories文件中，前面是map的key，后面是value，当使用注解@key，就会自动加载value类。</p></li></ol><h4 id="spring-factory-gt-EurekaServerAutoConfiguration-class"><a href="#spring-factory-gt-EurekaServerAutoConfiguration-class" class="headerlink" title="spring.factory -&gt; EurekaServerAutoConfiguration.class"></a>spring.factory -&gt; EurekaServerAutoConfiguration.class</h4><ol><li>配合页面完成控制台相关功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 程序启动，创建Controller对象</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">    prefix = &quot;eureka.dashboard&quot;,</span><br><span class="hljs-meta">    name = &#123;&quot;enabled&quot;&#125;,</span><br><span class="hljs-meta">    matchIfMissing = true</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> EurekaController <span class="hljs-title function_">eurekaController</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EurekaController</span>(<span class="hljs-built_in">this</span>.applicationInfoManager);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>发布web接口，让EurekaClient调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Application <span class="hljs-title function_">jerseyApplication</span><span class="hljs-params">(Environment environment, ResourceLoader resourceLoader)</span> &#123;<br>        String[] var5 = EUREKA_PACKAGES;<br>    &#125;<br></code></pre></td></tr></table></figure><p>↓ 扫描@Path @Provider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] EUREKA_PACKAGES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.netflix.discovery&quot;</span>, <span class="hljs-string">&quot;com.netflix.eureka&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><h4 id="spring-factory-gt-EurekaClientAutoConfiguration-class"><a href="#spring-factory-gt-EurekaClientAutoConfiguration-class" class="headerlink" title="spring.factory -&gt; EurekaClientAutoConfiguration.class"></a>spring.factory -&gt; EurekaClientAutoConfiguration.class</h4><ol><li>向server准备好的接口发送请求，完成发现，注册等操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DiscoveryClient <span class="hljs-title function_">discoveryClient</span><span class="hljs-params">(EurekaInstanceConfig config, EurekaClient client)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EurekaDiscoveryClient</span>(config, client);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><blockquote><p>多个微服务的提供者该如何选择，如何负载均衡。</p></blockquote><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Ribbon是Netfilx发布的一个负载均衡器，有助于控制HTTP和TCP客户端行为。在SpringCloud中，Eureka一般配合Ribbon进行使用，Ribbon提供了客户端负载均衡的功能，Ribbon利用从Eureka中读取到的服务信息，在调用服务节点提供的服务时，会合理的进行负载。</p><p>在SpringCloud中可以将注册中心和Ribbon配合使用，Ribbon自动的从注册中心中获取服务提供者的列表信息，并基于内置的负载均衡算法，请求服务。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022190258923.png" alt="image-20221022190258923"></p><h3 id="客户端负载均衡与服务端负载均衡"><a href="#客户端负载均衡与服务端负载均衡" class="headerlink" title="客户端负载均衡与服务端负载均衡"></a>客户端负载均衡与服务端负载均衡</h3><p><strong>服务端负载均衡</strong></p><p>先发送请求到负载均衡服务器或者软件，然后通过负载均衡算法，在多个服务器之间选择一个进行访</p><p>问；即在服务器端再进行负载均衡算法分配</p><p><strong>客户端负载均衡</strong></p><p>客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择一个服务器，然后进行访问，这</p><p>是客户端负载均衡；即在客户端就进行负载均衡算法分配</p><h3 id="主要作用-1"><a href="#主要作用-1" class="headerlink" title="主要作用"></a>主要作用</h3><p><strong>（1）服务调用</strong></p><p>eureka内部集成了ribbon</p><ul><li><p>在创建RestTemplate时，声明@LoadBalanced</p></li><li><p>使用RestTemplate调用远程微服务：不需要去拼接微服务的URL，以待请求的服务名替换IP地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/buy/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br><span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>   <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   product = restTemplate.getForObject(<span class="hljs-string">&quot;http://service-product/product/1&quot;</span>,Product.class);<br>   <span class="hljs-keyword">return</span> product;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>（2）负载均衡</strong></p><p>Ribbon是一个典型的客户端负载均衡器（在发送请求之前就知道要发送到哪个地址），Ribbon会获取服务的所有地址，根据内部的负载均衡算法，获取本次请求的有效地址。</p><p><strong>（3）重试机制</strong></p><p>引入Spring的重试组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.retry<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-retry<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 修改ribbon负载均衡策略 服务名 - ribbon - NFLoadBalancerRuleClassName ：策略</span><br><span class="hljs-attr">service-product:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># Ribbon的连接超时时间（如果消费对服务A创建HTTP连接的时间达到250ms没有响应，就会访问服务B）</span><br>    <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># Ribbon的数据读取超时时间（连接好了以后获取数据的时间超过1s，重试）</span><br>    <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作都进行重试</span><br>    <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 切换实例的重试次数</span><br>    <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 对当前实例的重试次数</span><br></code></pre></td></tr></table></figure><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><blockquote><p>准备两个商品微服务（9001，9011），在订单系统中，远程以负载均衡的形式调用商品服务。</p></blockquote><p><strong>默认：轮询策略</strong></p><p>策略选择：</p><ol><li>如果每个机器配置一样，则建议不修改策略（推荐）</li><li>如果部分机器配置强，则可以改为WeightedResponseTimeRule</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 修改ribbon负载均衡策略 服务名 - ribbon - NFLoadBalancerRuleClassName ：策略</span><br><span class="hljs-attr">service-product:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBanlancerRuleClassName:</span> <span class="hljs-string">com.netfilx.loadbalancer.RandomRule</span><span class="hljs-comment"># 轮询</span><br></code></pre></td></tr></table></figure><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><h4 id="spring-factory-gt-RibbonAutoConfiguration-class"><a href="#spring-factory-gt-RibbonAutoConfiguration-class" class="headerlink" title="spring.factory -&gt; RibbonAutoConfiguration.class"></a>spring.factory -&gt; RibbonAutoConfiguration.class</h4><ol><li><p>程序启动，在加载该类之前加载<code>LoadBalancerAutoConfiguration</code>这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigureBefore(&#123;LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RibbonAutoConfiguration</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>向RestTemplate中添加请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title function_">restTemplateCustomizer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> RetryLoadBalancerInterceptor loadBalancerInterceptor)</span> &#123;<br>    <span class="hljs-keyword">return</span> (restTemplate) -&gt; &#123;<br>        List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(restTemplate.getInterceptors());<br>        list.add(loadBalancerInterceptor);<br>        restTemplate.setInterceptors(list);<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>发送请求时，会执行<code>LoadBalancerInterceptor</code>中的<code>intercept</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当发送一个请求时，会进入下面的方法中</span><br>restTemplate.getForObject(<span class="hljs-string">&quot;http://service-product/product/1&quot;</span>,Product.class);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title function_">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] body, <span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">URI</span> <span class="hljs-variable">originalUri</span> <span class="hljs-operator">=</span> request.getURI();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> originalUri.getHost();<br>        Assert.state(serviceName != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Request URI does not contain a valid hostname: &quot;</span> + originalUri);<br>    <span class="hljs-comment">// 执行该行方法</span><br>        <span class="hljs-keyword">return</span> (ClientHttpResponse)<span class="hljs-built_in">this</span>.loadBalancer.execute(serviceName, <span class="hljs-built_in">this</span>.requestFactory.createRequest(request, body, execution));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行<code>loadBalancer.execute</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// ILoadBalancer是一个负载均衡器（这里挂载了很多负载均衡算法）</span><br>        <span class="hljs-type">ILoadBalancer</span> <span class="hljs-variable">loadBalancer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getLoadBalancer(serviceId);<br>    <span class="hljs-comment">// 通过getServer获取到要请求的地址</span><br>        <span class="hljs-type">Server</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServer(loadBalancer);<br>        <span class="hljs-keyword">if</span> (server == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No instances available for &quot;</span> + serviceId);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            RibbonLoadBalancerClient.<span class="hljs-type">RibbonServer</span> <span class="hljs-variable">ribbonServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RibbonLoadBalancerClient</span>.RibbonServer(serviceId, server, <span class="hljs-built_in">this</span>.isSecure(server, serviceId), <span class="hljs-built_in">this</span>.serverIntrospector(serviceId).getMetadata(server));<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.execute(serviceId, ribbonServer, request);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服 务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key&#x2F;Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。 使用起来也较为简单。Consul 使用 Go 语言编写，因此具有天然可移植性（支持Linux、windows和 Mac OS X）；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。</p><h3 id="Consul的优势"><a href="#Consul的优势" class="headerlink" title="Consul的优势"></a>Consul的优势</h3><ul><li><p>使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是Paxos, 而 etcd 使用的则是 Raft。</p><blockquote><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a> RAFT算法动态演示</p></blockquote></li><li><p>支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持。</p></li><li><p>支持健康检查。 etcd 不提供此功能。</p></li><li><p>支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持 http 协议。</p></li><li><p>官方提供 web 管理界面, etcd 无此功能。</p></li></ul><p>综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>服务发现</p></li><li><p>健康检查</p></li><li><p>Key&#x2F;Value 存储</p></li><li><p>多数据中心</p></li></ul><h3 id="consul与Eureka的区别"><a href="#consul与Eureka的区别" class="headerlink" title="consul与Eureka的区别"></a>consul与Eureka的区别</h3><p><strong>（1）一致性</strong></p><p>Consul强一致性（CP）</p><ul><li>服务注册相比Eureka会稍慢一些。因为Consul的raft协议要求必须过半数的节点都写入成功才认为注册成功</li><li>Leader挂掉时，重新选举期间整个consul不可用。保证了强一致性但牺牲了可用性。</li></ul><p>Eureka保证高可用和最终一致性（AP）</p><ul><li>服务注册相对要快，因为不需要等注册信息replicate到其他节点，也不保证注册信息是否 replicate成功</li><li>当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性。</li></ul><p><strong>（2）开发语言和使用</strong></p><ul><li>eureka就是个servlet程序，跑在servlet容器中</li><li>Consul则是go编写而成，安装启动即可</li></ul><h3 id="consul的下载与安装"><a href="#consul的下载与安装" class="headerlink" title="consul的下载与安装"></a>consul的下载与安装</h3><blockquote><p><a href="https://www.consul.io/">consul官方网站</a></p></blockquote><p>进入安装目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#以开发者模式启动</span></span><br>consul agent -dev -client=0.0.0.0<br></code></pre></td></tr></table></figure><p>web平台：127.0.0.1:8500</p><h3 id="consul的基本使用"><a href="#consul的基本使用" class="headerlink" title="consul的基本使用"></a>consul的基本使用</h3><p>（1）服务注册</p><p>（2）服务查询</p><p>（3）服务删除</p><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><ul><li>提供一个商品微服务</li><li>一共一个订单系统</li></ul><h4 id="将微服务注册到注册中心consul"><a href="#将微服务注册到注册中心consul" class="headerlink" title="将微服务注册到注册中心consul"></a>将微服务注册到注册中心consul</h4><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--springcloud 提供的对基于consul的服务发现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--actuator的健康检查--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">###开始配置consul的服务注册</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">consul:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment">#consul服务器的主机地址</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span> <span class="hljs-comment">#consul服务器的端口</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment">#是否需要注册</span><br>        <span class="hljs-attr">register:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-comment">#注册的实例ID (唯一标志)</span><br>        <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;-1</span><br>        <span class="hljs-comment">#服务的名称</span><br>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span><br>        <span class="hljs-comment">#服务的请求端口</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;server.port&#125;</span><br>        <span class="hljs-comment">#指定开启ip地址注册</span><br>        <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-comment">#当前服务的请求ip</span><br>        <span class="hljs-attr">ip-address:</span> <span class="hljs-string">$&#123;spring.cloud.client.ip-address&#125;</span><br></code></pre></td></tr></table></figure><h4 id="服务的消费者从consul中拉取所有的服务列表"><a href="#服务的消费者从consul中拉取所有的服务列表" class="headerlink" title="服务的消费者从consul中拉取所有的服务列表"></a>服务的消费者从consul中拉取所有的服务列表</h4><p>消费者配置同上</p><h3 id="consul高可用集群"><a href="#consul高可用集群" class="headerlink" title="consul高可用集群"></a>consul高可用集群</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221021001215507.png" alt="image-20221021001215507"></p><h3 id="consul集群搭建"><a href="#consul集群搭建" class="headerlink" title="consul集群搭建"></a>consul集群搭建</h3><p><strong>（1）准备环境</strong></p><table><thead><tr><th>服务器ip</th><th>consul类型</th><th>Node（节点名称）</th><th>序号</th></tr></thead><tbody><tr><td>192.168.74.101</td><td>server</td><td>server-1</td><td>s1</td></tr><tr><td>192.168.74.102</td><td>server</td><td>server-2</td><td>s2</td></tr><tr><td>192.168.74.103</td><td>server</td><td>server-3</td><td>s3</td></tr><tr><td>192.168.71.1</td><td>client</td><td>clent-1</td><td>s4</td></tr></tbody></table><ul><li>Agent 以 client 模式启动的节点。在该模式下，该节点会采集相关信息，通过 RPC 的方式向 server 发送。Client模式节点有无数个，官方建议搭配微服务配置</li><li>Agent 以 server 模式启动的节点。一个数据中心中至少包含 1 个 server 节点。不过官方建议使用 3 或 5 个 server 节点组建成集群，以保证高可用且不失效率。server 节点参与 Raft、维护会员信 息、注册服务、健康检查等功能。</li></ul><p><strong>（2）安装consul并启动</strong></p><p>在每个consul节点上安装consul服务，下载安装过程和单节点一致。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#从官网下载最新版本的Consul服务</span></span><br>wget https://releases.hashicorp.com/consul/1.5.3/consul_1.5.3_linux_amd64.zip<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#使用unzip命令解压</span></span><br>unzip consul_1.5.3_linux_amd64.zip<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#将解压好的consul可执行命令拷贝到/usr/local/bin目录下</span></span><br>cp consul /usr/local/bin<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#测试一下</span></span><br>consul<br></code></pre></td></tr></table></figure><p>启动每个consul server节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#登录s1虚拟机，以server形式运行</span></span><br>consul agent -server -bootstrap-expect 3 -data-dir /etc/consul.d -node=server-1 <br>-bind=192.168.74.101 -ui -client 0.0.0.0 &amp;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#登录s2 虚拟机，以server形式运行</span></span><br>consul agent -server -bootstrap-expect 2 -data-dir /etc/consul.d -node=server-2 <br>-bind=192.168.74.102 -ui -client 0.0.0.0 &amp; <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#登录s3 虚拟机，以server形式运行</span></span><br>consul agent -server -bootstrap-expect 2 -data-dir /etc/consul.d -node=server-3 <br>-bind=192.168.74.103 -ui -client 0.0.0.0 &amp; <br></code></pre></td></tr></table></figure><blockquote><p>-server：以server身份启动</p><p>-bootstrap-expect：集群要求的最少server数量，当低于这个数量，集群即失效。</p><p>-data-dir：data存放的目录，更多信息请参阅consul数据同步机制。</p><p>-node：节点id，在同一集群不能重复</p><p>-bind：监听的ip地址</p><p>-client：客户端的ip地址（0.0.0.0表示不限制）</p><p>&amp;：在后台运行，此为linux脚本语法</p></blockquote><p>至此三个Consul Server模式服务全部启动成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#在本地电脑中使用client形式启动consul</span></span><br>consul agent -client=0.0.0.0 -bind=192.xx.xx.xx -data-dir /etc/consul.d -node=client-1<br></code></pre></td></tr></table></figure><p><strong>（3）每个节点加入集群</strong></p><p>在s2，s3，s4 服务其上通过consul join 命令加入 s1中的consul集群中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#加入consul集群</span></span><br>consul join 192.168.74.101<br></code></pre></td></tr></table></figure><p><strong>（4） 测试</strong></p><p>在任意一台服务器中输入 consul members查看集群中的所有节点信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#查看consul集群节点信息</span></span><br>consul members<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221021002433112.png" alt="登录任意一台服务器的UI界面"></p><h3 id="consul常见问题"><a href="#consul常见问题" class="headerlink" title="consul常见问题"></a>consul常见问题</h3><p><strong>（1）节点和服务注销</strong></p><p>当服务或者节点失效． Consul 不会对注册的信息进行剔除处理，仅仅标记已状态进行标记（并且不可使用 ） 。如果担心失效节点和失效服务过多影晌监控。可以通过调用 HTTP API 的形式进行</p><p>处理节点和服务的注销可以使用HTTP API：</p><ul><li>注销任意节点和服务： &#x2F;catalog&#x2F;deregister</li><li>注梢当前节点的服务： &#x2F;agent&#x2F;service&#x2F;deregister&#x2F;service _ id</li></ul><p>如果某个节点不继续使用了，也可以在本机使用 consul leave命令，或者在其它节点使用 consul force -leave 节点id。</p><p><strong>（2）健康检查与故障转移</strong></p><p>在集群环境下，键康检查是由服务注册到的Agent 来处理的，那么如果这个Agent挂掉了，那么此节点的健康检查就处于无人管理的状态。</p><p>从实际应用，节点上的服务可能既要被发现，又要发现别的服务．如果节点挂掉了，仅提供被发现的功能实际上服务还是不可用的。当然发现别的服务也可以不使用本机节点，可以通过访问一个 Nginx 实现的若干 Consul 节点的负载均衡来实现．</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Feign是Netflix开发的声明式，模板化的HTTP客户端，其灵感来自RetrofitJAXRS20以及WebSocket.</p><ul><li><p>Feign可帮助我们更加便捷，优雅的调用HTTP API。</p></li><li><p>在SpringCloud中，使用Feign非常简单一一创建一个接口，并在接口上添加一些注解，代码就完</p></li></ul><p>成了。</p><ul><li><p>Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等。</p></li><li><p>SpringCloud对Feign进行了增强，使Feign支持了SpringMVC注解，并整合了Ribbon和Eureka ,</p></li></ul><p>从而让Feign的使用更加方便。</p><h3 id="Feign和Ribbon的联系"><a href="#Feign和Ribbon的联系" class="headerlink" title="Feign和Ribbon的联系"></a>Feign和Ribbon的联系</h3><p><strong>Ribbon</strong>是一个基于 HTTP 和 TCP <strong>客户端</strong> 的负载均衡的工具。它可以 <strong>在客户端</strong> 配置RibbonServerList（服务端列表），使用 HttpClient 或 RestTemplate 模拟http请求，步骤相当繁琐。</p><p><strong>Feign</strong> 是在 Ribbon的基础上进行了一次改进，是一个使用起来更加方便的 HTTP 客户端。采用接口的方式， 只需要创建一个接口，然后在上面添加注解即可 ，将需要调用的其他服务的方法定义成抽象方法即可， 不需要自己构建http请求。然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写客户端变得非常容易</p><h3 id="组件入门"><a href="#组件入门" class="headerlink" title="组件入门"></a>组件入门</h3><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--springcloud整合的openFeign--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置调用接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 声明需要调用的微服务名称</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@FeignClient</span></span><br><span class="hljs-comment"> *      * name : 服务提供者的名称</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FeignClient(name=&quot;service-product&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductFeignClient</span> &#123;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置需要调用的微服务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value=&quot;/product/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>在启动类上激活feign</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EntityScan(&quot;cn.itcast.order.entity&quot;)</span><br><span class="hljs-comment">//激活Feign</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderApplication</span> &#123;&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>通过自动的接口调用远程微服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductFeignClient productFeignClient;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/buy/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        product = productFeignClient.findById(id);<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Feign的配置"><a href="#Feign的配置" class="headerlink" title="Feign的配置"></a>Feign的配置</h3><p>从Spring Cloud Edgware开始，Feign支持使用属性自定义Feign。对于一个指定名称的Feign Client（例如该Feign Client的名称为 feignName ），Feign支持如下配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>    <span class="hljs-attr">client:</span><br>        <span class="hljs-attr">config:</span><br>            <span class="hljs-attr">feignName:</span> <span class="hljs-comment">##定义FeginClient的名称</span><br>                <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">5000</span> <span class="hljs-comment"># 相当于Request.Options</span><br>                <span class="hljs-attr">readTimeout:</span> <span class="hljs-number">5000</span> <span class="hljs-comment"># 相当于Request.Options</span><br>                <span class="hljs-comment"># 配置Feign的日志级别，相当于代码配置方式中的Logger</span><br>                <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br>                <span class="hljs-comment"># Feign的错误解码器，相当于代码配置方式中的ErrorDecoder</span><br>                <span class="hljs-attr">errorDecoder:</span> <span class="hljs-string">com.example.SimpleErrorDecoder</span><br>                <span class="hljs-comment"># 配置重试，相当于代码配置方式中的Retryer</span><br>                <span class="hljs-attr">retryer:</span> <span class="hljs-string">com.example.SimpleRetryer</span><br>                <span class="hljs-comment"># 配置拦截器，相当于代码配置方式中的RequestInterceptor</span><br>                <span class="hljs-attr">requestInterceptors:</span><br>                    <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.FooRequestInterceptor</span><br>                    <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.BarRequestInterceptor</span><br>                <span class="hljs-attr">decode404:</span> <span class="hljs-literal">false</span><br> <br></code></pre></td></tr></table></figure><ul><li>feignName：FeginClient的名称</li><li>connectTimeout ： 建立链接的超时时长</li><li>readTimeout ： 读取超时时长</li><li>loggerLevel: Fegin的日志级别</li><li>errorDecoder ：Feign的错误解码器</li><li>retryer ： 配置重试</li><li>requestInterceptors ： 添加请求拦截器</li><li>decode404 ： 配置熔断不处理404异常</li></ul><h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>order_service中配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 日志配置</span><br><span class="hljs-comment"># NONE：不输出日志</span><br><span class="hljs-comment"># BASIC：适用于生产环境追踪问题</span><br><span class="hljs-comment"># HEADERS：在BASIC的基础上，记录请求和响应头信息</span><br><span class="hljs-comment"># FULL：记录所有</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">service-product:</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">cn.itcast.order.fegin.ProductFeginClient:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><ol><li><code>@EnableFeignClients</code>注解</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableFeignClients</span><br></code></pre></td></tr></table></figure><ol start="2"><li>FeignClientsRegistra类中的registerBeanDefinitions()方法中的registerFeignClients()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-built_in">this</span>.registerDefaultConfiguration(metadata, registry);<br>    <span class="hljs-built_in">this</span>.registerFeignClients(metadata, registry);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>registerFeignClients()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerFeignClients</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-comment">// AnnotationTypeFilter会找到项目中哪里用到了@FeignClient这个注解</span><br>scanner.addIncludeFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTypeFilter</span>(FeignClient.class));<br>    <span class="hljs-comment">// 这里完成相关注册工作，注册到Spring当中</span><br>    <span class="hljs-built_in">this</span>.registerFeignClient(registry, annotationMetadata, attributes);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>registerFeignClient()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerFeignClient</span><span class="hljs-params">(BeanDefinitionRegistry registry, AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">contextId</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContextId(beanFactory, attributes);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getName(attributes);<br>        <span class="hljs-type">FeignClientFactoryBean</span> <span class="hljs-variable">factoryBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FeignClientFactoryBean</span>();<br>        factoryBean.setBeanFactory(beanFactory);<br>        factoryBean.setName(name);<br>        factoryBean.setContextId(contextId);<br>        factoryBean.setType(clazz);<br>    <span class="hljs-comment">// 创建FeignClientFactoryBean对象，并设置它的一些属性</span><br>        <span class="hljs-type">BeanDefinitionBuilder</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(clazz, () -&gt; &#123;<br>            factoryBean.setUrl(<span class="hljs-built_in">this</span>.getUrl(beanFactory, attributes));<br>            factoryBean.setPath(<span class="hljs-built_in">this</span>.getPath(beanFactory, attributes));<br>            factoryBean.setDecode404(Boolean.parseBoolean(String.valueOf(attributes.get(<span class="hljs-string">&quot;decode404&quot;</span>))));<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">fallback</span> <span class="hljs-operator">=</span> attributes.get(<span class="hljs-string">&quot;fallback&quot;</span>);<br>            <span class="hljs-keyword">if</span> (fallback != <span class="hljs-literal">null</span>) &#123;<br>                factoryBean.setFallback(fallback <span class="hljs-keyword">instanceof</span> Class ? (Class)fallback : ClassUtils.resolveClassName(fallback.toString(), (ClassLoader)<span class="hljs-literal">null</span>));<br>            &#125;<br><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">fallbackFactory</span> <span class="hljs-operator">=</span> attributes.get(<span class="hljs-string">&quot;fallbackFactory&quot;</span>);<br>            <span class="hljs-keyword">if</span> (fallbackFactory != <span class="hljs-literal">null</span>) &#123;<br>                factoryBean.setFallbackFactory(fallbackFactory <span class="hljs-keyword">instanceof</span> Class ? (Class)fallbackFactory : ClassUtils.resolveClassName(fallbackFactory.toString(), (ClassLoader)<span class="hljs-literal">null</span>));<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> factoryBean.getObject();<br>        &#125;);<br><span class="hljs-comment">// 把FeignClientFactoryBean注册到Spring容器当中</span><br>        <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(beanDefinition, className, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;alias&#125;);<br>        BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>再看FeignClientFactoryBean类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个类实现了FactoryBean接口，实现了getObject()方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignClientFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;Object&gt;<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getTarget();<br>&#125;<br><br><span class="hljs-comment">// 方法中调用了getTarget()方法</span><br>&lt;T&gt; T <span class="hljs-title function_">getTarget</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> targeter.target(<span class="hljs-built_in">this</span>, builder, context, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HardCodedTarget</span>(<span class="hljs-built_in">this</span>.type, <span class="hljs-built_in">this</span>.name, url));<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// targeter.target开始着手去创建对象</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">target</span><span class="hljs-params">(FeignClientFactoryBean factory, Builder feign, FeignContext context, HardCodedTarget&lt;T&gt; target)</span> &#123;<br>    <span class="hljs-keyword">return</span> feign.target(target);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">target</span><span class="hljs-params">(Target&lt;T&gt; target)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.build().newInstance(target);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Target&lt;T&gt; target)</span> &#123;<br>    <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.factory.create(target, methodToHandler);<br>&#125;<br><span class="hljs-comment">// 到最后创建了标注了@FeignClinet接口的动态代理对象FeignInvocationHandler</span><br><span class="hljs-keyword">public</span> InvocationHandler <span class="hljs-title function_">create</span><span class="hljs-params">(Target target, Map&lt;Method, InvocationHandlerFactory.MethodHandler&gt; dispatch)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FeignInvocationHandler</span>(target, dispatch);<br>&#125;<br><br><span class="hljs-comment">// 实际上，下面调用findById()方法是productFeignClient的实现类执行的</span><br><span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductFeignClient productFeignClient;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/buy/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        product = productFeignClient.findById(id);<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="微服务架构的高并发问题"><a href="#微服务架构的高并发问题" class="headerlink" title="微服务架构的高并发问题"></a>微服务架构的高并发问题</h2><h3 id="性能工具Jmeter"><a href="#性能工具Jmeter" class="headerlink" title="性能工具Jmeter"></a>性能工具Jmeter</h3><h4 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol><li>官网下载解压</li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022170835776.png" alt="image-20221022170835776"></p><ol start="2"><li><p>找到<code>bin</code>目录下的<code>jmeter.bat</code>双击运行</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022170942820.png" alt="image-20221022170942820"></p></li><li><p>点击新建-&gt;创建测试计划-&gt;测试计划上右键-&gt;添加-&gt;Threads-&gt;线程组</p></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022171147208.png" alt="image-20221022171147208"></p><ol start="4"><li><p>线程组右键-&gt;添加-&gt;Sampler-&gt;HTTP请求</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022171246755.png" alt="image-20221022171246755"></p></li><li><p>填写接口信息</p><p><img src="https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20221022171402411.png" alt="image-20221022171402411"></p></li><li><p>在HTTP请求上添加结果树查看结果</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022171443299.png" alt="image-20221022171443299"></p></li><li><p>设置线程数量</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022171605690.png" alt="image-20221022171605690"></p></li><li><p>点击三角运行，去结果树查看结果</p><p><img src="https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20221022171649676.png" alt="image-20221022171649676"></p></li></ol><h3 id="系统负载过高存在的问题"><a href="#系统负载过高存在的问题" class="headerlink" title="系统负载过高存在的问题"></a>系统负载过高存在的问题</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，由于网络原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务累计，导致服务瘫痪。</p><p>在SpringBoot程序中，默认使用内置tomcat作为web服务器。单tomcat支持最大的并发请求是有限的，如果某一接口阻塞，待执行的任务积压越来越多，那么势必会影响其他接口的调用。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022172804967.png" alt="image-20221022172804967"></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li><p>线程池隔离</p><p>为下单方法分配线程池A，线程池A中最多有5个线程运行。</p><p>查询订单方法分配线程池B，线程池B中最多有4个线程运行。</p></li><li><p>信号量隔离</p><p>设置一个计数器，下单方法最大阈值为5，剩下的人再访问直接报错。（PV操作）</p></li></ol><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><h3 id="服务容错的核心知识"><a href="#服务容错的核心知识" class="headerlink" title="服务容错的核心知识"></a>服务容错的核心知识</h3><h4 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h4><p>在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问A服务，而A服务需要调用B服务，B服务需要调用C服务，由于网络原因或者自身的原因，如果B服务或者C服务不能及时响应，A服务将处于阻塞状态，直到B服务C服务响应。此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022175420170.png" alt="image-20221022175420170"></p><p>雪崩是系统中的蝴蝶效应导致其发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法响应变慢，亦或是某台机器的资源耗尽。从源头上我们无法完全杜绝雪崩源头的发生，但是雪崩的根本原因来源于服务之间的强依赖，所以我们可以提前评估，做好<strong>熔断，隔离，限流。</strong></p><h4 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h4><p>顾名思义，它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其它模块，不影响整体的系统服务。</p><h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h4><p>熔断这一概念来源于电子工程中的断路器（Circuit Breaker）。在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022175514562.png" alt="image-20221022175514562"></p><p>所谓降级，就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。 也可以理解为兜底</p><h4 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h4><p>限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳固运行，一旦达到的需要限制的阈值，就需要限制流量并采取少量措施以完成限制流量的目的。比方：推迟解决，拒绝解决，或者者部分拒绝解决等等。</p><h3 id="对RestTemplate的支持"><a href="#对RestTemplate的支持" class="headerlink" title="对RestTemplate的支持"></a>对RestTemplate的支持</h3><ol><li>引入hystrix的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>启动类中激活Hystrix</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-comment">//激活hystrix</span><br><span class="hljs-meta">@EnableCircuitBreaker</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestOrderApplication</span> &#123;&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>配置熔断触发的降级逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 降级方法</span><br><span class="hljs-comment"> *  和需要收到保护的方法的返回值一致</span><br><span class="hljs-comment"> *  方法参数一致</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Product <span class="hljs-title function_">orderFallBack</span><span class="hljs-params">(Long id)</span> &#123;<br>   <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>   product.setProductName(<span class="hljs-string">&quot;触发降级方法&quot;</span>);<br>   <span class="hljs-keyword">return</span> product;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置熔断触发的降级逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 降级方法</span><br><span class="hljs-comment"> *  和需要收到保护的方法的返回值一致</span><br><span class="hljs-comment"> *  方法参数一致</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Product <span class="hljs-title function_">orderFallBack</span><span class="hljs-params">(Long id)</span> &#123;<br>   <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>   product.setProductName(<span class="hljs-string">&quot;触发降级方法&quot;</span>);<br>   <span class="hljs-keyword">return</span> product;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>在需要保护的接口上使用@HystrixCommand配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用注解配置熔断保护</span><br><span class="hljs-comment"> *     fallbackmethod : 配置熔断之后的降级方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;orderFallBack&quot;)</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/buy/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br><span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>   <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://service-product/product/1&quot;</span>,Product.class);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="默认的Fallback"><a href="#默认的Fallback" class="headerlink" title="默认的Fallback"></a>默认的Fallback</h3><p>我们刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以我们可以把Fallback配置加在类上，实现默认fallback：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022181642272.png" alt="image-20221022181642272"></p><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><p>在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">command:</span><br>    <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">execution:</span><br>        <span class="hljs-attr">isolation:</span><br>          <span class="hljs-attr">thread:</span><br>            <span class="hljs-attr">timeoutInMilliseconds:</span> <span class="hljs-number">2000</span><span class="hljs-comment">#默认的连接超时时间1秒,若1秒没有返回数据,自动的触发降级逻辑</span><br></code></pre></td></tr></table></figure><p>在规定时间内没有获取到微服务数据，将自动触发熔断降级的方法</p><h3 id="对Feign的支持"><a href="#对Feign的支持" class="headerlink" title="对Feign的支持"></a>对Feign的支持</h3><ol><li><p>引入依赖（fegin中已经集成了Hystrix）</p><p>SpringCloud Fegin默认已为Feign整合了hystrix，所以添加Feign依赖后就不用在添加hystrix</p></li><li><p>在feign中配置开启Hystrix</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#HEADERS : 在BASIC的基础上,记录请求和响应头信息   FULL : 记录所有</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-comment">#开启对hystrix的支持</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="3"><li>自定义一个接口实现方法，这个实现类就是熔断触发的降级逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductFeignClientCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProductFeignClient</span> &#123;<br> <br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 熔断降级的方法</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(Long id)</span> &#123;<br>      <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>      product.setProductName(<span class="hljs-string">&quot;feign调用触发熔断降级方法&quot;</span>);<br>      <span class="hljs-keyword">return</span> product;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>修改feignClient接口添加降级方法的支持</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 声明需要调用的微服务名称</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@FeignClient</span></span><br><span class="hljs-comment"> *      * name : 服务提供者的名称</span><br><span class="hljs-comment"> *      * fallback : 配置熔断发生降级方法</span><br><span class="hljs-comment"> *                  实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FeignClient(name=&quot;service-product&quot;,fallback = ProductFeignClientCallBack.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductFeignClient</span> &#123;<br> <br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 配置需要调用的微服务接口</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@RequestMapping(value=&quot;/product/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br>   <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Hystrix的监控平台"><a href="#Hystrix的监控平台" class="headerlink" title="Hystrix的监控平台"></a>Hystrix的监控平台</h3><p>除了实现容错功能，Hystrix还提供了近乎实时的监控，HystrixCommand和HystrixObservableCommand在执行时，会生成执行结果和运行指标。比如每秒的请求数量，成功数量等。这些状态会暴露在Actuator提供的&#x2F;health端点中。只需为项目添加 spring-boot-actuator 依赖，重启项目，访问<a href="http://localhost:9001/actuator/hystrix.stream">http://localhost:9001/actuator/hystrix.stream</a> ,即可看到实时的监控数据。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023004314188.png" alt="image-20221023004314188"></p><h4 id="Hystrix设置监控信息"><a href="#Hystrix设置监控信息" class="headerlink" title="Hystrix设置监控信息"></a>Hystrix设置监控信息</h4><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入hystrix的监控信息--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>启动类上激活</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//激活hystrix</span><br><span class="hljs-meta">@EnableCircuitBreaker</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignOrderApplication</span> &#123;&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>暴露所有actuator端点</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>在页面上访问</p><p><a href="http://localhost:9001/actuator/hystrix.stream">http://localhost:9001/actuator/hystrix.stream</a></p></li></ol><h4 id="搭建Hystrix-DashBoard监控"><a href="#搭建Hystrix-DashBoard监控" class="headerlink" title="搭建Hystrix DashBoard监控"></a>搭建Hystrix DashBoard监控</h4><ol><li>在上一步的步骤后添加EnableHystrixDashboard 注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableHystrixDashboard</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderApplication</span> &#123;&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>访问测试</p><p>localhost:9001&#x2F;hystrix</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023005851870.png" alt="image-20221023005851870"></p></li><li><p>输入监控断点展示监控的详细数据</p></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023005901871.png" alt="image-20221023005901871"></p><p><strong>参数内容详解</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023005937374.png" alt="image-20221023005937374"></p><h4 id="断路器聚合监控Turbine"><a href="#断路器聚合监控Turbine" class="headerlink" title="断路器聚合监控Turbine"></a>断路器聚合监控Turbine</h4><p>在微服务架构体系中，每个服务都需要配置Hystrix DashBoard监控。如果每次只能查看单个实例的监控数据，就需要不断切换监控地址，这显然很不方便。要想看这个系统的Hystrix Dashboard数据就需要用到Hystrix Turbine。Turbine是一个聚合Hystrix 监控数据的工具，他可以将所有相关微服务的Hystrix 监控数据聚合到一起，方便使用。引入Turbine后，整个监控系统架构如下：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023010621078.png" alt="image-20221023010621078"></p><ol><li>创建单独的工程</li><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>配置多个微服务的hystrix监控</li></ol><p>在application.yml的配置文件中开启turbine并进行相关配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8031</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">microservice-hystrix-turbine</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span><br>    <span class="hljs-attr">instance:</span><br>      <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">turbine:</span><br>  <span class="hljs-comment"># 要监控的微服务列表，多个用,分隔</span><br>  <span class="hljs-attr">appConfig:</span> <span class="hljs-string">shop-service-order</span><br>  <span class="hljs-attr">clusterNameExpression:</span> <span class="hljs-string">&quot;&#x27;default&#x27;&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>eureka相关配置 ： 指定注册中心地址</p></li><li><p>turbine相关配置：指定需要监控的微服务列表</p></li></ul><p>turbine会自动的从注册中心中获取需要监控的微服务，并聚合所有微服务中的 &#x2F;hystrix.stream 数据</p><ol start="4"><li>配置启动类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableTurbine</span><br><span class="hljs-meta">@EnableHystrixDashboard</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TurbineServerApplication</span> &#123;&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>测试</p><p>浏览器访问 <a href="http://localhost:8031/hystrix">http://localhost:8031/hystrix</a> 展示HystrixDashboard。并在url位置输入 <a href="http://local/">http://local</a></p><p>host:8031&#x2F;turbine.stream，动态根据turbine.stream数据展示多个微服务的监控数据</p></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023010904611.png" alt="image-20221023010904611"></p><h4 id="熔断器的状态"><a href="#熔断器的状态" class="headerlink" title="熔断器的状态"></a>熔断器的状态</h4><p>熔断器有三个状态 CLOSED 、 OPEN 、 HALF_OPEN 熔断器默认关闭状态，当触发熔断后状态变更为OPEN，在等待到指定的时间，Hystrix会放请求检测服务是否开启，这期间熔断器会变为 HALF_OPEN 半开启状态，熔断探测服务可用则继续变更为 CLOSED 关闭熔断器。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221025003024102.png" alt="image-20221025003024102"></p><ul><li><p>Closed：关闭状态（断路器关闭），所有请求都正常访问。代理类维护了最近调用失败的次数，如果某次调用失败，则使失败次数加1。如果最近失败次数超过了在给定时间内允许失败的阈值，则代理类切换到断开(Open)状态。此时代理开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误。</p></li><li><p>Open：打开状态（断路器打开），所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全关闭。默认失败比例的阈值是50%，请求次数最少不低于20次。</p></li><li><p>Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放1次请求通过，若这个请求是健康的，则会关闭断路器，否则继续保持打开，再次进行5秒休眠计时</p></li></ul><p><strong>熔断策略</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">circuitBreaker.requestVolumeThreshold</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">circuitBreaker.sleepWindowInMilliseconds</span>=<span class="hljs-string">10000</span><br><span class="hljs-attr">circuitBreaker.errorThresholdPercentage</span>=<span class="hljs-string">50</span><br></code></pre></td></tr></table></figure><blockquote><p>requestVolumeThreshold：触发熔断的最小请求次数，默认20</p><p>errorThresholdPercentage：触发熔断的失败请求最小占比，默认50%</p><p>sleepWindowInMilliseconds：熔断多少秒后去尝试请求</p></blockquote><h4 id="熔断器的隔离策略"><a href="#熔断器的隔离策略" class="headerlink" title="熔断器的隔离策略"></a>熔断器的隔离策略</h4><p>微服务使用Hystrix熔断器实现了服务的自动降级，让微服务具备自我保护的能力，提升了系统的稳定性，也较好的解决雪崩效应。<strong>其使用方式目前支持两种策略：</strong></p><ul><li><p><strong>线程池隔离策略：</strong>使用一个线程池来存储当前的请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求堆积入线程池队列。这种方式需要为每个依赖的服务申请线程池，有一定的资源消耗，好处是可以应对突发流量（流量洪峰来临时，处理不完可将数据存储到线程池队里慢慢处理）</p></li><li><p><strong>信号量隔离策略：</strong>使用一个原子计数器（或信号量）来记录当前有多少个线程在运行，请求来先判断计数器的数值，若超过设置的最大线程个数则丢弃改类型的新请求，若不超过则执行计数操作请求来计数器+1，请求返回计数器-1。这种方式是严格的控制线程且立即返回模式，无法应对突发流量（流量洪峰来临时，处理的线程超过数量，其他的请求会直接返回，不继续去请求依赖的服务）</p></li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。Sentinel 具有以下特征:</p><ul><li><p><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p></li><li><p><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p></li><li><p><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 SpringCloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel。</p></li><li><p><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221025010345406.png" alt="image-20221025010345406"></p></li></ul><h3 id="Sentinel和Hystrix的区别"><a href="#Sentinel和Hystrix的区别" class="headerlink" title="Sentinel和Hystrix的区别"></a>Sentinel和Hystrix的区别</h3><table><thead><tr><th></th><th><strong>Sentinel</strong></th><th><strong>Hystrix</strong></th><th><strong>resilience4j</strong></th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离（并发线程数限流）</td><td>线程池隔离&#x2F;信号量隔离</td><td>信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于响应时间、异常比率、异常数</td><td>基于异常比率</td><td>基于异常比率、响应时间</td></tr><tr><td>实时统计实现</td><td>滑动窗口（LeapArray）</td><td>滑动窗口（基于 RxJava）</td><td>Ring Bit Buffffer</td></tr><tr><td>动态规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td><td>有限支持</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td><td>接口的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td><td>Rate Limiter</td></tr><tr><td>流量整形</td><td>支持预热模式、匀速器模式、预热排队模式</td><td>不支持</td><td>简单的 Rate Limiter模式</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>控制台</td><td>提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td><td>简单的监控查看</td><td>不提供控制台，可对接其它监控系统</td></tr></tbody></table><h3 id="Sentinel中的管理控制台"><a href="#Sentinel中的管理控制台" class="headerlink" title="Sentinel中的管理控制台"></a>Sentinel中的管理控制台</h3><ol><li><strong>获取</strong> <strong>Sentinel</strong> <strong>控制台</strong></li></ol><p>您可以从官方网站中下载最新版本的控制台 jar 包，下载地址如下：</p><p><a href="https://github.com/alibaba/Sentinel/releases/download/1.6.3/sentinel-dashboard-1.6.3.jar">https://github.com/alibaba/Sentinel/releases/download/1.6.3/sentinel-dashboard-1.6.3.jar</a></p><ol start="2"><li><strong>启动</strong></li></ol><p>使用如下命令启动控制台：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar<br></code></pre></td></tr></table></figure><p>其中 <code>-Dserver.port=8080</code> 用于指定 Sentinel 控制台端口为 8080 。</p><p>从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的<strong>登录</strong>功能，默认用户名和密码都是 sentinel 。可以参考 鉴权模块文档 配置用户名和密码。</p><blockquote><p>启动 Sentinel 控制台需要 JDK 版本为 1.8 及以上版本。</p></blockquote><ol start="3"><li><strong>客户端能接入控制台</strong></li></ol><p>控制台启动后，客户端需要按照以下步骤接入到控制台。</p><ol start="4"><li><strong>引入JAR包</strong></li></ol><p>客户端需要引入 Transport 模块来与 Sentinel 控制台进行通信。可以通过 pom.xml 引入 JAR 包:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>配置启动参数</strong></li></ol><p>在工程的application.yml中添加Sentinel 控制台配置信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br><span class="hljs-attr">sentinel:</span><br>  <span class="hljs-attr">transport:</span><br><span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p>这里的 <code>spring.cloud.sentinel.transport.dashboard</code> 配置控制台的请求路径。</p><ol start="6"><li><strong>查看机器列表以及健康情况</strong></li></ol><p>默认情况下Sentinel 会在客户端首次调用的时候进行初始化，开始向控制台发送心跳包。也可以配置<code>sentinel.eager=true </code>,取消Sentinel控制台懒加载。</p><p>打开浏览器即可展示Sentinel的管理控制台</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221028014217812.png" alt="image-20221028014217812"></p><h3 id="基于Sentinel的服务保护"><a href="#基于Sentinel的服务保护" class="headerlink" title="基于Sentinel的服务保护"></a>基于Sentinel的服务保护</h3><h4 id="通用资源保护"><a href="#通用资源保护" class="headerlink" title="通用资源保护"></a>通用资源保护</h4><ol><li><p><strong>引入依赖</strong></p><p>父工程引入alibaba实现的SpringCloud</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子工程中引入sentinel</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置熔断降级方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/buy/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@SentinelResource(value=&quot;order&quot;,blockHandler = &quot;orderblockHandler&quot;,fallback= &quot;orderfallback&quot;)</span><br><span class="hljs-keyword">public</span> Product <span class="hljs-title function_">order</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br><span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://shop-serviceproduct/product/1&quot;</span>, Product.class);<br>&#125;<br><br><span class="hljs-comment">//降级方法</span><br><span class="hljs-keyword">public</span> Product <span class="hljs-title function_">orderblockHandler</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>    product.setId(-<span class="hljs-number">1l</span>);<br>    product.setProductName(<span class="hljs-string">&quot;触发熔断降级方法&quot;</span>);<br>    <span class="hljs-keyword">return</span> product;<br>&#125;<br><br><span class="hljs-comment">//降级方法</span><br><span class="hljs-keyword">public</span> Product <span class="hljs-title function_">orderfallback</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>    product.setId(-<span class="hljs-number">1l</span>);<br>    product.setProductName(<span class="hljs-string">&quot;触发抛出异常方法&quot;</span>);<br>    <span class="hljs-keyword">return</span> product;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="Rest熔断方法"><a href="#Rest熔断方法" class="headerlink" title="Rest熔断方法"></a>Rest熔断方法</h5><p>Spring Cloud Alibaba Sentinel 支持对 RestTemplate 的服务调用使用 Sentinel 进行保护，在构造<code>RestTemplate</code> bean的时候需要加上 <code>@SentinelRestTemplate</code> 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@SentinelRestTemplate(fallback = &quot;handleFallback&quot;, fallbackClass = ExceptionUtil.class, blockHandler=&quot;handleBlock&quot;,blockHandlerClass=ExceptionUtil.class)</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">getRestTemplate</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@SentinelRestTemplate 注解的属性支持限流( blockHandler , blockHandlerClass )和降级( fallback , fallbackClass )的处理。</li><li>其中 blockHandler 或 fallback 属性对应的方法必须是对应 blockHandlerClass 或fallbackClass 属性中的静态方法。</li><li>该方法的参数跟返回值跟org.springframework.http.client.ClientHttpRequestInterceptor#interceptor 方法一致，其中参数多出了一个 BlockException 参数用于获取 Sentinel 捕获的异常。</li></ul><p><strong>比如上述 @SentinelRestTemplate 注解中 ExceptionUtil 的 handleException 属性对应的方法声明如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 熔断降级</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionUtil</span> &#123;<br>    <br><span class="hljs-comment">//限流熔断业务逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SentinelClientHttpResponse <span class="hljs-title function_">handleBlock</span><span class="hljs-params">(HttpRequest request,<span class="hljs-type">byte</span>[] body,ClientHttpRequestExecution execution, lockException ex)</span> &#123;<br>    System.err.println(<span class="hljs-string">&quot;Oops: &quot;</span> + ex.getClass().getCanonicalName());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SentinelClientHttpResponse</span>(<span class="hljs-string">&quot;限流熔断降级&quot;</span>);<br>&#125;<br>    <br><span class="hljs-comment">//异常熔断业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SentinelClientHttpResponse <span class="hljs-title function_">handleFallback</span><span class="hljs-params">(HttpRequest request, <span class="hljs-type">byte</span>[] body,ClientHttpRequestExecution execution, BlockException ex)</span> &#123;<br>    System.err.println(<span class="hljs-string">&quot;fallback: &quot;</span> + ex.getClass().getCanonicalName());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SentinelClientHttpResponse</span>(<span class="hljs-string">&quot;异常熔断降级&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Sentinel RestTemplate 限流的资源规则提供两种粒度：</p><ul><li><code>httpmethod:schema://host:port/path</code> ：协议、主机、端口和路径</li><li><code>httpmethod:schema://host:port</code> ：协议、主机和端口</li></ul><h5 id="Feign实现熔断"><a href="#Feign实现熔断" class="headerlink" title="Feign实现熔断"></a>Feign实现熔断</h5><p>Sentinel 适配了 Feign 组件。如果想使用，除了引入 sentinel-starter 的依赖外还需要 2 个步骤：</p><ul><li>配置文件打开 sentinel 对 feign 的支持： feign.sentinel.enabled&#x3D;true</li><li>加入 openfeign starter 依赖使 sentinel starter 中的自动化配置类生效：</li></ul><ol><li><p><strong>引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>开启sentinel支持</strong></p><p>在工程的application.yml中添加sentinel 对 feign 的支持</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置FeignClient</strong></p><p>和使用Hystrix的方式基本一致，需要配置FeignClient接口以及通过 fallback 指定熔断降级方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//指定需要调用的微服务名称</span><br><span class="hljs-meta">@FeignClient(name=&quot;shop-service-product&quot;,fallback = ProductFeginClientCallBack.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductFeginClient</span> &#123;<br>    <span class="hljs-comment">//调用的请求路径</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/product/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>配置熔断方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 实现自定义的ProductFeginClient接口</span><br><span class="hljs-comment">* 在接口实现类中编写熔断降级方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductFeginClientCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProductFeginClient</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 降级方法</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>        product.setId(-<span class="hljs-number">1l</span>);<br>        product.setProductName(<span class="hljs-string">&quot;熔断:触发降级方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> product;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h2><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>在学习完前面的知识后，微服务架构已经初具雏形。但还有一些问题：不同的微服务一般会有不同的网络地址，客户端在访问这些微服务时必须记住几十甚至几百个地址，这对于客户端方来说太复杂也难以维护。如下图：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221031231730432.png" alt="image-20221031231730432"></p><p>如果让客户端直接与各个微服务通讯，可能会有很多问题：</p><ul><li>客户端会请求多个不同的服务，需要维护不同的请求地址，增加开发难度</li><li>在某些场景下存在跨域请求的问题</li><li>加大身份认证的难度，每个微服务需要独立认证</li></ul><p>因此，我们需要一个微服务网关，介于客户端与服务器之间的中间层，所有的外部请求都会先经过微服务网关。客户端只需要与网关交互，只知道一个网关地址即可，这样简化了开发还有以下优点： </p><p>1、易于监控 </p><p>2、易于认证 </p><p>3、减少了客户端与各个微服务之间的交互次数</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221031231924956.png" alt="image-20221031231924956"></p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>ZUUL是Netflflix开源的微服务网关，它可以和Eureka、Ribbon、Hystrix等组件配合使用，Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：</p><ul><li>动态路由：动态将请求路由到不同后端集群</li><li>压力测试：逐渐增加指向集群的流量，以了解性能</li><li>负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求</li><li>静态响应处理：边缘位置进行响应，避免转发到内部集群</li><li>身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求。Spring Cloud对Zuul进行了整合和增强。</li></ul><p>Spring Cloud对Zuul进行了整合和增强</p><h3 id="使用步骤-2"><a href="#使用步骤-2" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li><p><strong>创建工程导入坐标</strong></p><p>在IDEA中创建ZUUL网关工程 shop_zuul_server ，并添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置启动类，开启网关服务器功能</strong></p><p>创建启动类<code> ZuulServerApplication</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableZuulProxy</span> <span class="hljs-comment">// 开启Zuul的网关功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZuulServerApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(ZuulServerApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>配置文件</strong></p><p>创建配置文件 application.yml ，并添加相应配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment">#服务端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span> <span class="hljs-comment">#指定服务名</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>最直观的理解：</p><p>“路由”是指根据请求URL，将请求分配到对应的处理程序。在微服务体系中，Zuul负责接收所有的请求。根据不同的URL匹配规则，将不同的请求转发到不同的微服务处理。</p><h4 id="基础路由配置"><a href="#基础路由配置" class="headerlink" title="基础路由配置"></a>基础路由配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">routes:</span><br><span class="hljs-attr">product-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/product-service/**</span> <span class="hljs-comment"># 这里是映射路径</span><br>  <span class="hljs-attr">url:</span> <span class="hljs-string">http://127.0.0.1:9002</span> <span class="hljs-comment"># 映射路径对应的实际url地址</span><br>      <span class="hljs-attr">sensitiveHeaders:</span> <span class="hljs-comment">#默认zuul会屏蔽cookie，cookie不会传到下游服务，这里设置为空则取消默认的黑名单，如果设置了具体的头信息则不会传到下游服务</span><br></code></pre></td></tr></table></figure><p>只需要在application.yml文件中配置路由规则即可：</p><ul><li>product-service：配置路由id，可以随意取名</li><li>url：映射路径对应的实际url地址</li><li>path：配置映射路径，这里将所有请求前缀为&#x2F;product-service&#x2F;的请求，转发到<a href="http://127.0.0.1:9002处理">http://127.0.0.1:9002处理</a></li></ul><h4 id="面向服务的路由"><a href="#面向服务的路由" class="headerlink" title="面向服务的路由"></a>面向服务的路由</h4><p>微服务一般是由几十、上百个服务组成，对于一个URL请求，最终会确认一个服务实例进行处理。如果对每个服务实例手动指定一个唯一访问地址，然后根据URL去手动实现请求匹配，这样做显然就不合理。</p><p>Zuul支持与Eureka整合开发，根据ServiceID自动的从注册中心中获取服务地址并转发请求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而且在添加或移除服务实例的时候不用修改Zuul的路由配置。</p><ol><li><p><strong>添加eureka的依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>开启eureka的客户端服务发现（可省略）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableZuulProxy</span> <span class="hljs-comment">// 开启Zuul的网关功能</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZuulServerApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(ZuulServerApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在zuul网关服务中配置eureka的注册中心相关信息</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">serviceUrl:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:8761/eureka/</span><br>        <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 获取服务列表的周期：5s</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">preferIpAddress:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>修改路由中的映射配置，通过服务名称获取</strong></p><p>因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#配置路由规则</span><br><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-attr">product-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/product-service/**</span> <span class="hljs-comment"># 这里是映射路径</span><br>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">shop-service-product</span> <span class="hljs-comment">#配置转发的微服务名称</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="简化路由配置"><a href="#简化路由配置" class="headerlink" title="简化路由配置"></a>简化路由配置</h4><p>如果路由ID和对应的微服务的serviceId一致的话，可以简写成一行。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-attr">shop-service-product:</span> <span class="hljs-string">/product-service/**</span><br></code></pre></td></tr></table></figure><h4 id="Zuul加入后的架构"><a href="#Zuul加入后的架构" class="headerlink" title="Zuul加入后的架构"></a>Zuul加入后的架构</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221101000306654.png" alt="image-20221101000306654"></p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>通过之前的学习，我们得知Zuul它包含了两个核心功能：对请求的<strong>路由</strong>和<strong>过滤</strong>。其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础；而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。其实，路由功能在真正运行时，它的路由映射和请求转发同样也由几个不同的过滤器完成的。所以，过滤器可以说是Zuul实现API网关功能最为核心的部件，每一个进入Zuul的HTTP请求都会经过一系列的过滤器处理链得到请求响应并返回给客户端。</p><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221101000819491.png" alt="image-20221101000819491"></p><p>Zuul 中的过滤器跟我们之前使用的 javax.servlet.Filter 不一样，javax.servlet.Filter 只有一种类型，可以通过配置 urlPatterns 来拦截对应的请求。而 Zuul 中的过滤器总共有 4 种类型，且每种类型都有对应的使用场景。 </p><ol><li><p><strong>PRE</strong>：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</p></li><li><p><strong>ROUTING</strong>：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfifilx Ribbon请求微服务。</p></li><li><p><strong>POST</strong>：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTPHeader、收集统计信息和指标、将响应从微服务发送给客户端等。</p></li><li><p><strong>ERROR</strong>：在其他阶段发生错误时执行该过滤器。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ZuulFilter <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IZuulFilter</span>&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *定义过滤器类型</span><br><span class="hljs-comment">    *pre</span><br><span class="hljs-comment">    *routing</span><br><span class="hljs-comment">    *post</span><br><span class="hljs-comment">    *error</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterType</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *指定过滤器的执行顺序</span><br><span class="hljs-comment">    *返回值越小，执行顺序越高</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">filterOrder</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *当前过滤器是否生效</span><br><span class="hljs-comment">    *true：使用此过滤器</span><br><span class="hljs-comment">    *false：不使用此过滤器</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldFilter</span><span class="hljs-params">()</span>;<span class="hljs-comment">// 来自IZuulFilter</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *执行过滤器中的业务逻辑</span><br><span class="hljs-comment">    */</span><br>    Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException;<span class="hljs-comment">// IZuulFilter</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h4><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZuulFilter</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterType</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 登录校验，肯定是在前置拦截</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pre&quot;</span>;<br>&#125;<br>    <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">filterOrder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 顺序设置为1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>    <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldFilter</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 返回true，代表过滤器生效。</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>    <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException &#123;<br>        <span class="hljs-comment">// 登录校验逻辑。</span><br>        <span class="hljs-comment">// 1）获取Zuul提供的请求上下文对象</span><br>        <span class="hljs-type">RequestContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> RequestContext.getCurrentContext();<br>        <span class="hljs-comment">// 2) 从上下文中获取request对象</span><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> ctx.getRequest();<br>        <span class="hljs-comment">// 3) 从请求中获取token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;access-token&quot;</span>);<br>        <span class="hljs-comment">// 4) 判断</span><br>        <span class="hljs-keyword">if</span>(token == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(token.trim()))&#123;<br>            <span class="hljs-comment">// 没有token，登录校验失败，拦截</span><br>            ctx.setSendZuulResponse(<span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">// 返回401状态码。也可以考虑重定向到登录页。</span><br>            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());<br>&#125;<br>        <span class="hljs-comment">// 校验通过，可以考虑把用户信息放入上下文，继续向后执行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><ol><li><p><code>spring.factories</code>文件中的<code>ZuulServerAutoConfiguration</code>自动配置类</p></li><li><p><code>ZuulHandlerMapping</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ZuulHandlerMapping <span class="hljs-title function_">zuulHandlerMapping</span><span class="hljs-params">(RouteLocator routes)</span><br></code></pre></td></tr></table></figure></li><li><p><code>ZuulHandlerMapping</code>继承的Spring的<code>AbstractUrlHandlerMapping</code></p><p>会自动加入到springMVC的handlerMapping链中，用于处理zuul的映射配置</p></li><li><p>上一步会把请求发送到<code>ZuulServerAutoConfiguration</code>中的<code>ZuulController</code>中</p><p>Controller中构造方法配置了一个<code>ZuulServlet</code>，下面将所有符合规则的请求交给<code>ZuulServlet</code>的<code>service</code>方法进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ZuulController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.setServletClass(ZuulServlet.class);<br>        <span class="hljs-built_in">this</span>.setServletName(<span class="hljs-string">&quot;zuul&quot;</span>);<br>        <span class="hljs-built_in">this</span>.setSupportedMethods((String[])<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ZuulController执行了<code>handlerRequest</code>方法，方法中调用了父类的<code>handleRequestInternal</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">handleRequest</span><span class="hljs-params">()</span>&#123;<br>    var3 = <span class="hljs-built_in">super</span>.handleRequestInternal(request, response);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>handleRequestInternal</code>执行<code>this.servletInstance.service(request, response);</code>对请求进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title function_">handleRequestInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Assert.state(<span class="hljs-built_in">this</span>.servletInstance != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No Servlet instance&quot;</span>);<br>        <span class="hljs-built_in">this</span>.servletInstance.service(request, response);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>servletInstance.service</code>执行的是<code>ZuulServlet</code>中的<code>service</code>方法</p><p>service方法包含了preRoute，route，postRoute，刚好是Zuul的声明周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.init((HttpServletRequest)servletRequest, (HttpServletResponse)servletResponse);<br>            <span class="hljs-type">RequestContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> RequestContext.getCurrentContext();<br>            context.setZuulEngineRan();<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.preRoute();<br>            &#125; <span class="hljs-keyword">catch</span> (ZuulException var12) &#123;<br>                <span class="hljs-built_in">this</span>.error(var12);<br>                <span class="hljs-built_in">this</span>.postRoute();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.route();<br>            &#125; <span class="hljs-keyword">catch</span> (ZuulException var13) &#123;<br>                <span class="hljs-built_in">this</span>.error(var13);<br>                <span class="hljs-built_in">this</span>.postRoute();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.postRoute();<br>            &#125; <span class="hljs-keyword">catch</span> (ZuulException var11) &#123;<br>                <span class="hljs-built_in">this</span>.error(var11);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var14) &#123;<br>            <span class="hljs-built_in">this</span>.error(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ZuulException</span>(var14, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;UNHANDLED_EXCEPTION_&quot;</span> + var14.getClass().getName()));<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            RequestContext.getCurrentContext().unset();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="Zuul存在的问题"><a href="#Zuul存在的问题" class="headerlink" title="Zuul存在的问题"></a>Zuul存在的问题</h3><p>在实际使用中我们会发现直接使用Zuul会存在诸多问题，包括：</p><ul><li>性能问题</li></ul><p>Zuul1x版本本质上就是一个<strong>同步Servlet</strong>，采用多线程阻塞模型进行请求转发。简单讲，每来一个请求，Servlet容器要为该请求分配一个线程专门负责处理这个请求，直到响应返回客户端这个线程才会被释放返回容器线程池。如果后台服务调用比较耗时，那么这个线程就会被阻塞，阻塞期间线程资源被占用，不能干其它事情。我们知道Servlet容器线程池的大小是有限制的，当<strong>前端请求量大，而后台慢服务比较多</strong>时，很容易<strong>耗尽容器线程池内的线程</strong>，造成容器无法接受新的请求。</p><ul><li>不支持任何长连接，如websocket</li></ul><h2 id="GateWay"><a href="#GateWay" class="headerlink" title="GateWay"></a>GateWay</h2><p>Zuul 1.x 是一个基于阻塞 IO 的 API Gateway 以及 Servlet；直到 2018 年 5 月，Zuul 2.x（基于Netty，也是非阻塞的，支持长连接）才发布，但 Spring Cloud 暂时还没有整合计划。Spring CloudGateway 比 Zuul 1.x 系列的性能和功能整体要好。</p><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式，统一访问接口。SpringCloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflflix ZUUL，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控&#x2F;埋点，和限流等。它是基于Nttey的响应式开发模式。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104003939821.png" alt="image-20221104003939821"></p><ol><li><p><strong>路由</strong>（route）</p><p>路由是网关最基础的部分，路由信息由一个ID、一个目的URL、一组断言工厂和一组Filter组成。如果断言为真，则说明请求URL和配置的路由匹配。</p></li><li><p><strong>断言</strong>（predicates）Java8中的断言函数，Spring Cloud Gateway中的断言函数输入类型是Spring5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自Http Request中的任何信息，比如请求头和参数等。</p></li><li><p><strong>过滤器</strong>（fifilter） </p><p>一个标准的Spring webFilter，Spring Cloud Gateway中的Filter分为两种类型，分别是Gateway Filter和GlobalFilter。过滤器Filter可以对请求和响应进行处理</p></li></ol><h3 id="路由-1"><a href="#路由-1" class="headerlink" title="路由"></a>路由</h3><h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><ol><li><p><strong>创建工程导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayServerApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(GatewayServerApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>编写配置文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment">#服务端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span> <span class="hljs-comment">#指定服务名</span><br><span class="hljs-attr">cloud:</span><br>  <span class="hljs-attr">gateway:</span><br>    <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product-service</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://127.0.0.1:9002</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span><br></code></pre></td></tr></table></figure><ul><li><p>id：我们自定义的路由 ID，保持唯一</p></li><li><p>uri：目标服务地址</p></li><li><p>predicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。</p></li><li><p>fifilters：过滤规则，暂时没用。</p></li></ul><p>上面这段配置的意思是，配置了一个 id 为 product-service的路由规则，当访问网关请求地址以product 开头时，会自动转发到地址： <a href="http://127.0.0.1:9002/">http://127.0.0.1:9002/</a> 。</p></li></ol><p>路由规则</p><p>Spring Cloud Gateway 的功能很强大，前面我们只是使用了 predicates 进行了简单的条件匹配，其实Spring Cloud Gataway 帮我们内置了很多 Predicates 功能。在 Spring Cloud Gateway 中 Spring 利用Predicate 的特性实现了各种路由匹配规则，有通过 Header、请求参数等不同的条件来进行作为条件匹配到对应的路由。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104004438074.png" alt="image-20221104004438074"></p><p><strong>示例</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#路由断言之后匹配</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://xxxx.com</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">After=xxxxx</span><br>      <br><span class="hljs-comment">#路由断言之前匹配</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">before_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://xxxx.com</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Before=xxxxx</span><br>      <br><span class="hljs-comment">#路由断言之间</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">between_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://xxxx.com</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Between=xxxx,xxxx</span><br>      <br><span class="hljs-comment">#路由断言Cookie匹配,此predicate匹配给定名称(chocolate)和正则表达式(ch.p)</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">cookie_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://xxxx.com</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=chocolate,</span> <span class="hljs-string">ch.p</span><br>        <br><span class="hljs-comment">#路由断言Header匹配，header名称匹配X-Request-Id,且正则表达式匹配\d+</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">header_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://xxxx.com</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Header=X-Request-Id,</span> <span class="hljs-string">\d+</span><br>        <br><span class="hljs-comment">#路由断言匹配Host匹配，匹配下面Host主机列表,**代表可变参数</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">host_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://xxxx.com</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Host=**.somehost.org,**.anotherhost.org</span><br>        <br><span class="hljs-comment">#路由断言Method匹配，匹配的是请求的HTTP方法</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">method_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://xxxx.com</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Method=GET</span><br>        <br><span class="hljs-comment">#路由断言匹配，&#123;segment&#125;为可变参数</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">host_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://xxxx.com</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/foo/&#123;segment&#125;,/bar/&#123;segment&#125;</span><br>        <br><span class="hljs-comment">#路由断言Query匹配，将请求的参数param(baz)进行匹配，也可以进行regexp正则表达式匹配 (参数包含foo,并且foo的值匹配ba.)</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">query_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://xxxx.com</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Query=baz</span> <span class="hljs-string">或</span> <span class="hljs-string">Query=foo,ba.</span><br>        <br><span class="hljs-comment">#路由断言RemoteAddr匹配，将匹配192.168.1.1~192.168.1.254之间的ip地址，其中24为子网掩码位数即255.255.255.0</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">remoteaddr_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span><br>      <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">RemoteAddr=192.168.1.1/24</span><br></code></pre></td></tr></table></figure><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>和zuul网关类似，在SpringCloud GateWay中也支持动态路由：即自动的从注册中心中获取服务列表并访问。</p><ol><li><p><strong>添加注册中心依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置动态路由</strong></p><p>修改 application.yml 配置文件，添加eureka注册中心的相关配置，并修改访问映射的URL为服务名称。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment">#服务端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span> <span class="hljs-comment">#指定服务名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product-service</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://shop-service-product</span> <span class="hljs-comment">#  uri以 lb: //开头（lb代表从注册中心获取服务），后面接的就是你需要转发到的服务名称</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">serviceUrl:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:8761/eureka/</span><br>      <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 获取服务列表的周期：5s</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">preferIpAddress:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="重写转发路径"><a href="#重写转发路径" class="headerlink" title="重写转发路径"></a>重写转发路径</h4><p>在SpringCloud Gateway中，路由转发是直接将匹配的路由path直接拼接到映射路径（URI）之后，那么在微服务开发中往往没有那么便利。这里就可以通过RewritePath机制来进行路径重写。</p><p><strong>添加RewritePath重写转发路径</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment">#服务端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span> <span class="hljs-comment">#指定服务名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product-service</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://shop-service-product</span> <span class="hljs-comment">#  uri以 lb: //开头（lb代表从注册中心获取服务），后面接的就是你需要转发到的服务名称</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span><br>        <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/product-service/(?&lt;segment&gt;.*),</span> <span class="hljs-string">/$\&#123;segment&#125;</span><br></code></pre></td></tr></table></figure><p>通过RewritePath配置重写转发的url，将&#x2F;product-service&#x2F;(?.*)，重写为{segment}，然后转发到订单微服务。比如在网页上请求<a href="http://localhost:8080/product-service/product%EF%BC%8C%E6%AD%A4%E6%97%B6%E4%BC%9A%E5%B0%86%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0http://127.0.0.1:9002/product/1">http://localhost:8080/product-service/product，此时会将请求转发到http://127.0.0.1:9002/product/1</a></p><h3 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="过滤器的生命周期"><a href="#过滤器的生命周期" class="headerlink" title="过滤器的生命周期"></a>过滤器的生命周期</h4><p>Spring Cloud Gateway 的 Filter 的生命周期不像 Zuul 的那么丰富，它只有两个：“pre” 和 “post”。</p><p><strong>PRE：</strong> </p><p>这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</p><p><strong>POST：</strong></p><p>这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221108004058426.png" alt="image-20221108004058426"></p><h4 id="过滤器类型"><a href="#过滤器类型" class="headerlink" title="过滤器类型"></a>过滤器类型</h4><p>Spring Cloud Gateway 的 Filter 从作用范围可分为另外两种GatewayFilter 与 GlobalFilter。</p><ul><li><strong>GatewayFilter</strong>：应用到单个路由或者一个分组的路由上。</li><li><strong>GlobalFilter</strong>：应用到所有的路由上。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">自定义一个过滤器，实现GlobalFilter, Ordered接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ServerWebExchange：相当于请求和响应的上下文（zuul中的RequestContext）</span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 获取请求参数access-token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-comment">// 判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(token)) &#123;<br>            <span class="hljs-comment">// 如果不存在，认证失败</span><br>        log.info( <span class="hljs-string">&quot;token is empty ...&quot;</span> );<br>            <span class="hljs-comment">// 返回认证码</span><br>        exchange.getResponse().setStatusCode( HttpStatus.UNAUTHORIZED );<br>            <span class="hljs-comment">// 请求结束</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>&#125;<br><span class="hljs-keyword">return</span> chain.filter(exchange);<br>&#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义全局过滤器需要实现GlobalFilter和Ordered接口。</p><ul><li>在fifilter方法中完成过滤器的逻辑判断处理</li><li>在getOrder方法指定此过滤器的优先级，返回值越大级别越低</li><li>ServerWebExchange 就相当于当前请求和响应的上下文，存放着重要的请求-响应属性、请求实例和响应实例等等。一个请求中的request，response都可以通过 ServerWebExchange 获取</li><li>调用 chain.filter 继续向下游执行</li></ul><h3 id="网关限流"><a href="#网关限流" class="headerlink" title="网关限流"></a>网关限流</h3><h4 id="常见的限流算法"><a href="#常见的限流算法" class="headerlink" title="常见的限流算法"></a>常见的限流算法</h4><ul><li><p><strong>计数器</strong></p><p>计数器限流算法是最简单的一种限流实现方式。其本质是通过维护一个单位时间内的计数器，每次请求计数器加1，当单位时间内计数器累加到大于设定的阈值，则之后的请求都被拒绝，直到单位时间已经过去，再将计数器重置为零</p></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221108010115995.png" alt="image-20221108010115995"></p><ul><li><p><strong>漏桶算法</strong></p><p>漏桶算法可以很好地限制容量池的大小，从而防止流量暴增。漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221108010155564.png" alt="image-20221108010155564"></p><p>为了更好的控制流量，漏桶算法需要通过两个变量进行控制：一个是桶的大小，支持流量突发增多时可以存多少的水（burst），另一个是水桶漏洞的大小（rate）。</p></li><li><p><strong>令牌桶算法</strong></p><p>令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221108010328065.png" alt="image-20221108010328065"></p><h4 id="基于Filter的限流"><a href="#基于Filter的限流" class="headerlink" title="基于Filter的限流"></a>基于Filter的限流</h4><p>SpringCloudGateway官方就提供了基于令牌桶的限流支持。基于其内置的过滤器工厂<code>RequestRateLimiterGatewayFilterFactory</code> 实现。在过滤器工厂中是通过Redis和lua脚本结合的方式进行流量控制。</p><h5 id="使用步骤-3"><a href="#使用步骤-3" class="headerlink" title="使用步骤"></a>使用步骤</h5><ul><li><p><strong>导入redis依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifatId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>修改application.yml文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span> <span class="hljs-comment">#指定服务名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-service</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://shop-service-order</span><br>        <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/order-service/(?&lt;segment&gt;.*),</span> <span class="hljs-string">/$\&#123;segment&#125;</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span><br>  <span class="hljs-attr">args:</span><br>            <span class="hljs-comment"># 使用SpEL从容器中获取对象</span><br>            <span class="hljs-attr">key-resolver:</span> <span class="hljs-string">&#x27;#&#123;@pathKeyResolver&#125;&#x27;</span><br>            <span class="hljs-comment"># 令牌桶每秒填充平均速率</span><br>            <span class="hljs-attr">redis-rate-limiter.replenishRate:</span> <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 令牌桶的总容量</span><br>            <span class="hljs-attr">redis-rate-limiter.burstCapacity:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>在 application.yml 中添加了redis的信息，并配置了RequestRateLimiter的限流过滤器：</p><ul><li><p>burstCapacity，令牌桶总容量。</p></li><li><p>replenishRate，令牌桶每秒填充平均速率。</p></li><li><p>key-resolver，用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。</p></li></ul></li></ul><ol start="3"><li><p><strong>配置KeyResolver</strong></p><p>为了达到不同的限流效果和规则，可以通过实现 KeyResolver 接口，定义不同请求类型的限流键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyResolverConfiguration</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于请求路径的限流</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> KeyResolver <span class="hljs-title function_">pathKeyResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exchange - &gt; Mono.just(<br>            exchange.getRequest()<br>            .getPath()<br>            .toString()<br>        );<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于请求ip地址的限流</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> KeyResolver <span class="hljs-title function_">ipKeyResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exchange - &gt; Mono.just(<br>            exchange.getRequest()<br>            .getHeaders()<br>            .getFirst(<span class="hljs-string">&quot;X-Forwarded-For&quot;</span>)<br>        );<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于用户的限流</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> KeyResolver <span class="hljs-title function_">userKeyResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exchange - &gt; Mono.just(<br>            exchange.getRequest()<br>            .getQueryParams()<br>            .getFirst(<span class="hljs-string">&quot;user&quot;</span>)<br>        );<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过reids的MONITOR可以监听redis的执行过程。这时候Redis中会有对应的数据：</p></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221116235817586.png" alt="image-20221116235817586"></p><p>大括号中就是我们的限流Key,这边是IP，本地的就是localhost</p><ul><li>timestamp:存储的是当前时间的秒数，也就是System.currentTimeMillis() &#x2F; 1000或者</li><li>Instant.now().getEpochSecond()</li></ul><p>tokens:存储的是当前这秒钟的对应的可用的令牌数量</p><h4 id="基于Sentinel的限流"><a href="#基于Sentinel的限流" class="headerlink" title="基于Sentinel的限流"></a>基于Sentinel的限流</h4><p>Sentinel 支持对 Spring Cloud Gateway、Zuul 等主流的 API Gateway 进行限流。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221117001723600.png" alt="image-20221117001723600"></p><p>从 1.6.0 版本开始，Sentinel 提供了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：</p><ul><li>route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 routeId</li><li>自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组</li></ul><p>Sentinel 1.6.0 引入了 Sentinel API Gateway Adapter Common 模块，此模块中包含网关限流的规则和自定义 API 的实体和管理逻辑：</p><ul><li><p><code>GatewayFlowRule</code> ：网关限流规则，针对 API Gateway 的场景定制的限流规则，可以针对不同route 或自定义的 API 分组进行限流，支持针对请求中的参数、Header、来源 IP 等进行定制化的限流。</p></li><li><p><code>ApiDefinition</code> ：用户自定义的 API 定义分组，可以看做是一些 URL 匹配的组合。比如我们可以定义一个 API 叫 my_api ，请求 path 模式为 &#x2F;foo&#x2F;** 和 &#x2F;baz&#x2F;** 的都归到 my_api 这个 API分组下面。限流的时候可以针对这个自定义的 API 分组维度进行限流。</p></li></ul><h5 id="使用步骤-4"><a href="#使用步骤-4" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-spring-cloud-gateway-adapter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.y.z<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List &lt; ViewResolver &gt; viewResolvers;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerCodecConfigurer serverCodecConfigurer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GatewayConfiguration</span><span class="hljs-params">(ObjectProvider &lt; List &lt; ViewResolver &gt;&gt; viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);<br>        <span class="hljs-built_in">this</span>.serverCodecConfigurer = serverCodecConfigurer;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置限流的异常处理器:SentinelGatewayBlockExceptionHandler</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span><br>    <span class="hljs-keyword">public</span> SentinelGatewayBlockExceptionHandler<br>    <span class="hljs-title function_">sentinelGatewayBlockExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SentinelGatewayBlockExceptionHandler</span>(viewResolvers<br>            , serverCodecConfigurer);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置限流过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span><br>    <span class="hljs-keyword">public</span> GlobalFilter <span class="hljs-title function_">sentinelGatewayFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SentinelGatewayFilter</span>();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置初始化的限流参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initGatewayRules</span><span class="hljs-params">()</span> &#123;<br>        Set &lt;GatewayFlowRule&gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        rules.add(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayFlowRule</span>(<span class="hljs-string">&quot;order-service&quot;</span>) <span class="hljs-comment">//资源名称</span><br>            .setCount(<span class="hljs-number">1</span>) <span class="hljs-comment">// 限流阈值</span><br>            .setIntervalSec(<span class="hljs-number">1</span>) <span class="hljs-comment">// 统计时间窗口，单位是秒，默认是 1 秒</span><br>        );<br>        GatewayRuleManager.loadRules(rules);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>基于Sentinel 的Gateway限流是通过其提供的Filter来完成的，使用时只需注入对应的SentinelGatewayFilter 实例以及 SentinelGatewayBlockExceptionHandler 实例即可。</p></li><li><p>@PostConstruct定义初始化的加载方法，用于指定资源的限流规则。这里资源的名称为 orderservice ，统计时间是1秒内，限流阈值是1。表示每秒只能访问一个请求。</p></li></ul></li><li><p>网关配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span> <span class="hljs-comment">#指定服务名</span><br>  <span class="hljs-attr">redis:</span><br><span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br><span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">cloud:</span><br><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-service</span><br>    <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://shop-service-order</span><br><span class="hljs-attr">predicates:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order-service/**</span><br><span class="hljs-attr">filters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/order-service/(?&lt;segment&gt;.*),</span> <span class="hljs-string">/$\&#123;segment&#125;</span><br></code></pre></td></tr></table></figure><p>在一秒钟内多次访问<a href="http://localhost:8080/order-service/order/buy/1%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%99%90%E6%B5%81%E5%90%AF%E4%BD%9C%E7%94%A8%E4%BA%86%E3%80%82">http://localhost:8080/order-service/order/buy/1就可以看到限流启作用了。</a></p></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221117002415373.png" alt="image-20221117002415373"></p><ol start="4"><li><p>自定义异常提示</p><p>当触发限流后页面显示的是Blocked by Sentinel: FlowException。为了展示更加友好的限流提示，Sentinel支持自定义异常处理。</p><p>您可以在 GatewayCallbackManager 注册回调进行定制：</p><ul><li>setBlockHandler ：注册函数用于实现自定义的逻辑处理被限流的请求，对应接口为BlockRequestHandler 。默认实现为 DefaultBlockRequestHandler ，当被限流时会返回类似于下面的错误信息： Blocked by Sentinel: FlowException 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initBlockHandlers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">BlockRequestHandler</span> <span class="hljs-variable">blockRequestHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockRequestHandler</span>() &#123;<br>        <span class="hljs-keyword">public</span> Mono &lt; ServerResponse &gt; handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) &#123;<br>            <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span> &lt; &gt; ();<br>            map.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">001</span>);<br>            map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;对不起,接口限流了&quot;</span>);<br>            <span class="hljs-keyword">return</span> ServerResponse.status(HttpStatus.OK)<br>                .<br>            contentType(MediaType.APPLICATION_JSON_UTF8)<br>                .<br>            body(BodyInserters.fromObject(map));<br>        &#125;<br>    &#125;;<br>    GatewayCallbackManager.setBlockHandler(blockRequestHandler);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221117002531334.png" alt="image-20221117002531334"></p></li><li><p>参数限流</p><p>上面的配置是针对整个路由来限流的，如果我们只想对某个路由的参数做限流，那么可以使用参数限流方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">rules.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayFlowRule</span>(<span class="hljs-string">&quot;order-service&quot;</span>)<br>    .setCount(<span class="hljs-number">1</span>)<br>    .setIntervalSec(<span class="hljs-number">1</span>)<br>    .setParamItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayParamFlowItem</span>()<br>        .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_URL_PARAM)<br>        .setFi <span class="hljs-title function_">eldName</span><span class="hljs-params">(<span class="hljs-string">&quot;id&quot;</span>)</span><br>    )<br>);<br></code></pre></td></tr></table></figure><p>通过指定PARAM_PARSE_STRATEGY_URL_PARAM表示从url中获取参数，setFieldName指定参数名称。</p></li><li><p>自定义API分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initCustomizedApis</span><span class="hljs-params">()</span> &#123;<br>    Set &lt; ApiDefinition &gt; definitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span> &lt; &gt; ();<br>    <span class="hljs-type">ApiDefinition</span> <span class="hljs-variable">api1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiDefinition</span>(<span class="hljs-string">&quot;product_api&quot;</span>)<br>        .setPredicateItems(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span> &lt; ApiPredicateItem &gt; () &#123;<br>            &#123;<br>                <span class="hljs-comment">//以/product-service/product 开头的请求</span><br>                add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiPathPredicateItem</span>()<br>                    .setPattern(<span class="hljs-string">&quot;/product-service/product/**&quot;</span>)<br>                    .setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX));<br>            &#125;<br>        &#125;);<br>    <span class="hljs-type">ApiDefinition</span> <span class="hljs-variable">api2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiDefinition</span>(<span class="hljs-string">&quot;order_api&quot;</span>)<br>        .setPredicateItems(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span> &lt; ApiPredicateItem &gt; () &#123;<br>            &#123;<br>                <span class="hljs-comment">///order-service/order 完成的url路径匹配</span><br>                add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiPathPredicateItem</span>()<br>                    .setPattern(<span class="hljs-string">&quot;/order-service/order&quot;</span>));<br>            &#125;<br>        &#125;);<br>    definitions.add(api1);<br>    definitions.add(api2);<br>    GatewayApiDefinitionManager.loadApiDefinitions(definitions);<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="网关高可用"><a href="#网关高可用" class="headerlink" title="网关高可用"></a>网关高可用</h3><p><strong>高可用HA</strong>（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207223836448.png" alt="image-20221207223836448"></p><p>我们实际使用 Spring Cloud Gateway 的方式如上图，不同的客户端使用不同的负载将请求分发到后端的 Gateway，Gateway 再通过HTTP调用后端服务，最后对外输出。因此为了保证 Gateway 的高可用性，前端可以同时启动多个 Gateway 实例进行负载，在 Gateway 的前端使用 Nginx 或者 F5 进行负载转发以达到高可用性。</p><h2 id="微服务的链路追踪概述"><a href="#微服务的链路追踪概述" class="headerlink" title="微服务的链路追踪概述"></a>微服务的链路追踪概述</h2><h3 id="微服务架构下的问题"><a href="#微服务架构下的问题" class="headerlink" title="微服务架构下的问题"></a><strong>微服务架构下的问题</strong></h3><p>在大型系统的微服务化构建中，一个系统会被拆分成许多模块。这些模块负责不同的功能，组合成系统，最终可以提供丰富的功能。在这种架构中，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心，也就意味着这种架构形式也会存在一些问题：</p><ul><li>如何快速发现问题？</li><li>如何判断故障影响范围？</li><li>如何梳理服务依赖以及依赖的合理性？</li><li>如何分析链路性能问题以及实时容量规划？</li></ul><p>分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p><p>目前业界比较流行的链路追踪系统如：Twitter的<strong>Zipkin</strong>，阿里的<strong>鹰眼</strong>，美团的<strong>Mtrace</strong>，大众点评的<strong>cat</strong>等，大部分都是基于google发表的<a href="http://bigbully.github.io/Dapper-translation/"><strong>Dapper</strong></a>。Dapper阐述了分布式系统，特别是微服务架构中链路追踪的概念、数据表示、埋点、传递、收集、存储与展示等技术细节。</p><h3 id="Sleuth概述"><a href="#Sleuth概述" class="headerlink" title="Sleuth概述"></a><strong>Sleuth概述</strong></h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><strong>相关概念</strong></h4><p>Spring Cloud Sleuth 为Spring Cloud提供了分布式根据的解决方案。它大量借用了Google Dapper的设计。先来了解一下Sleuth中的术语和相关概念。</p><p>Spring Cloud Sleuth采用的是Google的开源项目Dapper的专业术语。</p><ul><li><p>Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址) span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。</p></li><li><p>Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。</p></li><li><p>Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束</p><ul><li><p>cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始</p></li><li><p>sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟</p></li><li><p>ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间</p></li><li><p>cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间</p></li></ul></li></ul><h3 id="链路追踪Sleuth入门"><a href="#链路追踪Sleuth入门" class="headerlink" title="链路追踪Sleuth入门"></a><strong>链路追踪Sleuth入门</strong></h3><ol><li><p><strong>配置依赖</strong></p><p>修改微服务工程引入Sleuth依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>修改配置文件</strong></p><p>修改application.yml添加日志级别</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">INFO</span><br>    <span class="hljs-attr">org.springframework.web.servlet.DispatcherServlet:</span> <span class="hljs-string">DEBUG</span><br>    <span class="hljs-attr">org.springframework.cloud.sleuth:</span> <span class="hljs-string">DEBUG</span><br></code></pre></td></tr></table></figure><p>每个微服务都需要添加如上的配置。启动微服务，调用之后，我们可以在控制台观察到sleuth的日志输出。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207225954274.png" alt="image-20221207225954274"></p></li></ol><p>其中 ff8ff8b803a3b558 是TraceId，后面跟着的是SpanId，依次调用有一个全局的TraceId，将调用链路串起来。仔细分析每个微服务的日志，不难看出请求的具体过程。</p><p>查看日志文件并不是一个很好的方法，当微服务越来越多日志文件也会越来越多，通过Zipkin可以将日志聚合，并进行可视化展示和全文检索。</p><h3 id="Zipkin的概述"><a href="#Zipkin的概述" class="headerlink" title="Zipkin的概述"></a><strong>Zipkin的概述</strong></h3><p>Zipkin 是 Twitter 的一个开源项目，它基于 Google Dapper 实现，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。 我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的 REST API 接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。除了面向开发的 API 接口之外，它也提供了方便的 UI 组件来帮助我们直观的搜索跟踪信息和分析请求链路明细，比如：可以查询某段时间内各用户请求的处理时间等。 Zipkin 提供了可插拔数据存储方式：InMemory、MySql、Cassandra 以及 Elasticsearch。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207230304948.png" alt="image-20221207230304948"></p><p>上图展示了 Zipkin 的基础架构，它主要由 4 个核心组件构成：</p><ul><li>Collector：收集器组件，它主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为Zipkin 内部处理的 Span 格式，以支持后续的存储、分析、展示等功能。</li><li>Storage：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中。</li><li>RESTful API：API 组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。</li><li>Web UI：UI 组件，基于 API 组件实现的上层应用。通过 UI 组件用户可以方便而有直观地查询和分析跟踪信息。</li></ul><p>Zipkin 分为两端，一个是 Zipkin 服务端，一个是 Zipkin 客户端，客户端也就是微服务的应用。</p><p>客户端会配置服务端的 URL 地址，一旦发生服务间的调用的时候，会被配置在微服务里面的 Sleuth 的监听器监听，并生成相应的 Trace 和 Span 信息发送给服务端。</p><p>发送的方式主要有两种，一种是 HTTP 报文的方式，还有一种是消息总线的方式如 RabbitMQ。</p><p>不论哪种方式，我们都需要：</p><ul><li>一个 Eureka 服务注册中心，这里我们就用之前的 eureka 项目来当注册中心。</li><li>一个 Zipkin 服务端。</li><li>多个微服务，这些微服务中配置Zipkin 客户端。</li></ul><h3 id="Zipkin-Server的部署和配置"><a href="#Zipkin-Server的部署和配置" class="headerlink" title="Zipkin Server的部署和配置"></a><strong>Zipkin Server的部署和配置</strong></h3><ol><li><p><strong>Zipkin Server下载</strong></p><p>从spring boot 2.0开始，官方就不再支持使用自建Zipkin Server的方式进行服务链路追踪，而是直接提供了编译好的 jar 包来给我们使用。可以从官方网站下载先下载<a href="https://search.maven.org/remote_content?g=io.zipkin.java&a=zipkin-server&v=LATEST&c=exec">Zipkin</a>的web UI，我们这里下载的是zipkin-server-2.12.9-exec.jar</p></li><li><p><strong>启动</strong></p><p>在命令行输入<code>java -jar zipkin-server-2.12.9-exec.jar</code>启动 Zipkin Server</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207230909491.png" alt="image-20221207230909491"></p></li></ol><ul><li>默认Zipkin Server的请求端口为 <strong>9411</strong></li><li>Zipkin Server的启动参数可以通过官方提供的<a href="https://github.com/openzipkin/zipkin/blob/master/zipkin-server/src/main/resources/zipkin-server-shared.yml">yml配置文件查找</a></li><li>在浏览器输入 <a href="http://127.0.0.1:9411即可进入到Zipkin">http://127.0.0.1:9411即可进入到Zipkin</a> Server的管理后台</li></ul><h3 id="客户端Zipkin-Sleuth整合"><a href="#客户端Zipkin-Sleuth整合" class="headerlink" title="客户端Zipkin+Sleuth整合"></a><strong>客户端Zipkin+Sleuth整合</strong></h3><p>通过查看日志分析微服务的调用链路并不是一个很直观的方案，结合zipkin可以很直观地显示微服务之间的调用关系。</p><ol><li><p><strong>客户端添加依赖</strong></p><p>客户端指的是需要被追踪的微服务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>修改客户端配置文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">zipkin:</span><br>  <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://127.0.0.1:9411/</span> <span class="hljs-comment">#zipkin server的请求地址</span><br>  <span class="hljs-attr">sender:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">web</span> <span class="hljs-comment">#请求方式,默认以http的方式向zipkin server发送追踪数据</span><br><span class="hljs-attr">sleuth:</span><br>  <span class="hljs-attr">sampler:</span><br>    <span class="hljs-attr">probability:</span> <span class="hljs-number">1.0</span> <span class="hljs-comment">#采样的百分比</span><br></code></pre></td></tr></table></figure><p>指定了zipkin server的地址，下面制定需采样的百分比，默认为0.1，即10%，这里配置1，是记录全部的sleuth信息，是为了收集到更多的数据（仅供测试用）。在分布式系统中，过于频繁的采样会影响系统性能，所以这里配置需要采用一个合适的值。</p></li><li><p><strong>测试</strong></p><p>以此启动每个微服务，启动Zipkin Service。通过浏览器发送一次微服务请求。打开 Zipkin Service控制台，我们可以根据条件追踪每次请求调用过程。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207231354595.png" alt="image-20221207231354595"></p><p>单击该trace可以看到请求的细节</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207231423362.png" alt="image-20221207231423362"></p></li></ol><h3 id="基于消息中间件收集数据"><a href="#基于消息中间件收集数据" class="headerlink" title="基于消息中间件收集数据"></a><strong>基于消息中间件收集数据</strong></h3><p>在默认情况下，Zipkin客户端和Server之间是使用HTTP请求的方式进行通信（即同步的请求方式），在网络波动，Server端异常等情况下可能存在信息收集不及时的问题。Zipkin支持与rabbitMQ整合完成异步消息传输。</p><p>加了MQ之后，通信过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207231719874.png" alt="image-20221207231719874"></p><h4 id="RabbitMQ的安装与启动"><a href="#RabbitMQ的安装与启动" class="headerlink" title="RabbitMQ的安装与启动"></a><strong>RabbitMQ的安装与启动</strong></h4><p>略</p><h4 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar zipkin-server-2.12.9-exec.jar --RABBIT_ADDRESSES=127.0.0.1:5672<br></code></pre></td></tr></table></figure><ul><li>RABBIT_ADDRESSES ： 指定RabbitMQ地址</li><li>RABBIT_USER： 用户名（默认guest）</li><li>RABBIT_PASSWORD ： 密码（默认guest）</li></ul><p>启动Zipkin Server之后，我们打开RabbitMQ的控制台可以看到多了一个Queue</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207234028410.png" alt="image-20221207234028410"></p><p>其中<code>zipkin</code>就是为我们自动创建的Queue队列</p><h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><ol><li><p><strong>配置依赖</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">&lt;dependency&gt;</span><br>    <span class="hljs-string">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br>    <span class="hljs-string">&lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br>    <span class="hljs-string">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br>    <span class="hljs-string">&lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br>    <span class="hljs-string">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br>     <span class="hljs-string">&lt;artifactId&gt;spring-cloud-sleuth-zipkin&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br>    <span class="hljs-string">&lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br>    <span class="hljs-string">&lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br></code></pre></td></tr></table></figure><p>导入<code>spring-rabbit</code>依赖，是Spring提供的对rabbit的封装，客户端会根据配置自动的生产消息并发送到目标队列中</p></li><li><p><strong>配置消息中间件rabbit mq地址等信息</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">zipkin:</span><br>  <span class="hljs-comment">#base-url: http://127.0.0.1:9411/ #zipkin server的请求地址</span><br>  <span class="hljs-attr">sender:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">rabbit</span><br>    <span class="hljs-comment">#type: web #请求方式,默认以http的方式向zipkin server发送追踪数据</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">1.0</span> <span class="hljs-comment">#采样的百分比</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">listener:</span> <span class="hljs-comment"># 这里配置了重试策略</span><br>      <span class="hljs-attr">direct:</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li><p>修改消息的投递方式，改为rabbit即可。</p></li><li><p>添加rabbitmq的相关配置</p></li></ul></li><li><p><strong>测试</strong></p><p>关闭Zipkin Server，并随意请求连接。打开rabbitmq管理后台可以看到，消息已经推送到rabbitmq。</p><p>当Zipkin Server启动时，会自动的从rabbitmq获取消息并消费，展示追踪数据</p><p>可以看到如下效果：</p><ul><li><p>请求的耗时时间不会出现突然耗时特长的情况</p></li><li><p>当ZipkinServer不可用时（比如关闭、网络不通等），追踪信息不会丢失，因为这些信息会保存在Rabbitmq服务器上，直到Zipkin服务器可用时，再从Rabbitmq中取出这段时间的信息</p></li></ul></li></ol><h3 id="存储跟踪数据"><a href="#存储跟踪数据" class="headerlink" title="存储跟踪数据"></a>存储跟踪数据</h3><p>Zipkin Server默认时间追踪数据信息保存到内存，这种方式不适合生产环境。因为一旦Service关闭重启或者服务崩溃，就会导致历史数据消失。Zipkin支持将追踪数据持久化到mysql数据库或者存储到elasticsearch中。这里以mysql为例。</p><h4 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h4><p>可以从官网找到Zipkin Server持久mysql的数据库脚本。</p><h4 id="配置启动服务端"><a href="#配置启动服务端" class="headerlink" title="配置启动服务端"></a><strong>配置启动服务端</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar zipkin-server-2.12.9-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_DB=zipkin --MYSQL_USER=root --MYSQL_PASS=111111<br></code></pre></td></tr></table></figure><ul><li>STORAGE_TYPE : 存储类型</li><li>MYSQL_HOST： mysql主机地址</li><li>MYSQL_TCP_PORT：mysql端口</li><li>MYSQL_DB： mysql数据库名称</li><li>MYSQL_USER：mysql用户名</li><li>MYSQL_PASS ：mysql密码</li></ul><p>配置好服务端之后，可以在浏览器请求几次。回到数据库查看会发现数据已经持久化到mysql中</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207233059321.png" alt="image-20221207233059321"></p><h2 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h2><p><a href="https://www.bilibili.com/video/BV1eE41187Ug">SpringCloud从小白到精通教程，Spring Cloud微服务架构开发项目实战</a></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17. 电话号码的字母组合</title>
    <link href="/2022/10/18/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2022/10/18/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合</a></h4><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h5><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240304056.png" alt="以23为例的所有路径"></p><p>其实就是遍历这颗树的所有路径</p><p>当遍历到ad时，结果集加入结果，退回到a，要进行撤销选择，也就是删掉d，继续从a做出其他选择。</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><blockquote><p>result &#x3D; []<br>def backtrack(路径, 选择列表):</p><p>​    if 满足结束条件:<br>​        result.add(路径)<br>​        return</p><p>​    for 选择 in 选择列表:<br>​        做选择（排除不合法的选择）<br>​        backtrack(路径, 选择列表)<br>​        撤销选择</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        &#125;<br><br>        Map&lt;String,String[]&gt; letterMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">8</span>);<br>        letterMap.put(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;);<br>        letterMap.put(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>&#125;);<br>        letterMap.put(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>&#125;);<br>        letterMap.put(<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>&#125;);<br>        letterMap.put(<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>&#125;);<br>        letterMap.put(<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>&#125;);<br>        letterMap.put(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>&#125;);<br>        letterMap.put(<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>&#125;);<br><br>        String[] digitsArr = digits.split(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">// 结果集</span><br>        List&lt;String&gt; resultList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 路径的最顶端，就是空串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">// 开始回溯，路径s，选择列表letterMap.get(digitsArr[0])，结果集resultList</span><br>        backTrack(s,digitsArr,<span class="hljs-number">0</span>,letterMap,resultList);<br><br>        <span class="hljs-keyword">return</span> resultList;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(String s,String[] digitsArr, <span class="hljs-type">int</span> deep, Map&lt;String, String[]&gt; letterMap, List&lt;String&gt; resultList)</span> &#123;<br>        <br>        <span class="hljs-comment">// 结束条件：如果深度大于树深，结束。</span><br>        <span class="hljs-keyword">if</span>(deep==digitsArr.length)&#123;<br>            <span class="hljs-comment">// result.add(路径)</span><br>            resultList.add(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 选择列表，当前路径下的几种选择。</span><br>        String[] chooseArr = letterMap.get(digitsArr[deep]);<br><br><span class="hljs-comment">// for 选择 in 选择列表:</span><br>        deep++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chooseArr.length; i++) &#123;<br>            <span class="hljs-comment">// 做选择</span><br>            s += chooseArr[i];<br>            <span class="hljs-comment">// 继续往下一层走</span><br>            backTrack(s,digitsArr,deep,letterMap,resultList);<br>            <span class="hljs-comment">// 撤销选择</span><br>            s = s.substring(<span class="hljs-number">0</span>,s.length()-<span class="hljs-number">1</span>);<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode力扣</category>
      
      <category>Medium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15. 三数之和</title>
    <link href="/2022/10/08/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/10/08/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/description/">15. 三数之和</a></h4><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>标签：数组遍历</li><li>首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 000，满足则添加进结果集</li><li>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环</li><li>如果 nums[i] &#x3D;&#x3D; nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过</li><li>当 sum &#x3D;&#x3D; 0 时，nums[L] &#x3D;&#x3D; nums[L+1] 则会导致结果重复，应该跳过，L++</li><li>当 sum &#x3D;&#x3D; 0 时，nums[R] &#x3D;&#x3D; nums[R−1] 则会导致结果重复，应该跳过，R−−</li><li>时间复杂度：O(n²)，n 为数组长度</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Arrays.sort(nums);<br><br>        <span class="hljs-comment">// 三指针，固定一个指针i，每次+1，另外两个指针从i+1,nums.length-1向中间移动。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 因为排完序了，一旦i指向的数&gt;0，后面相加就不可能=0，退出循环，结束。</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// nums[i]==nums[i-1]，则说明该数字计算过了，会导致结果重复，所以应该跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 如果l&gt;=r，则数字全部遍历完。</span><br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                    result.add(Arrays.asList(nums[i], nums[l], nums[r]));<br>                    <span class="hljs-comment">// 如果 l 和 l+1 数字相同，计算过了，不用再计算了。</span><br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="hljs-number">1</span>]) &#123;<br>                        l++;<br>                    &#125;<br>                    <span class="hljs-comment">// r同理</span><br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="hljs-number">1</span>]) &#123;<br>                        r--;<br>                    &#125;<br>                    l++;<br>                    r--;<br>                &#125;<br>                <span class="hljs-comment">// 如果和大于0，说明右面高了，移动左面只会越来越大。</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;<br>                    r--;<br>                &#125;<br>                <span class="hljs-comment">// 和小于0同理</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    l++;<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><a href="https://leetcode.cn/problems/3sum/solutions/12307/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/">画解算法：15. 三数之和</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode力扣</category>
      
      <category>Medium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 寻找两个正序数组的中位数</title>
    <link href="/2022/10/08/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/10/08/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h4><p>在分析这道题之前，先贴一个普通解法。</p><p>执行用时: <strong>1 ms</strong></p><p>内存消耗: <strong>42.2 MB</strong></p><h4 id="普通解："><a href="#普通解：" class="headerlink" title="普通解："></a>普通解：</h4><h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><p>首先要了解中位数的定义，一个长度为sum的数组中，如果长度是奇数，则中位数所在的索引位置就是sum&#x2F;2+1，如果是偶数，为sum&#x2F;2+1和sum&#x2F;2的平均数。</p><p>其实我们不需要真正的全部遍历完，我们只需要找到中位数，遍历到中位数的位置停下即可。</p><h5 id="时间复杂度：O-m-n-1-x2F-2"><a href="#时间复杂度：O-m-n-1-x2F-2" class="headerlink" title="时间复杂度：O((m+n-1)&#x2F;2)"></a>时间复杂度：O((m+n-1)&#x2F;2)</h5><p>时间复杂度不用说了，遍历一半是肯定的要的。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums1.length + nums2.length;<br>    <br>    <span class="hljs-comment">// n1,n2分别代表两个数组的指针，从0开始往后移动。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n2 = <span class="hljs-number">0</span>, val1 = <span class="hljs-number">0</span>, val2 = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 遍历到中位数，停止</span><br>    <span class="hljs-keyword">while</span> (n1 + n2 &lt;= sum / <span class="hljs-number">2</span>) &#123;<br>        <br>        <span class="hljs-comment">// 赋值阶段，两个数组指针开始移动对比</span><br>        <span class="hljs-comment">// 哪个指针指向的数小，哪个就赋值给val2，下次遍历，val2赋值给val1，相当于清空val2</span><br>        <span class="hljs-comment">// 如果一个数组全部遍历完毕，接下来在另一个数组里指针一个一个往后移动即可。</span><br>        val1 = val2;<br>        <span class="hljs-keyword">if</span> (n1 == nums1.length) &#123;<br>            val2 = nums2[n2++];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n2 == nums2.length) &#123;<br>            val2 = nums1[n1++];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[n1] &lt; nums2[n2]) &#123;<br>            val2 = nums1[n1++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            val2 = nums2[n2++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> ? val2 : (val1 + val2) / <span class="hljs-number">2.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最优解："><a href="#最优解：" class="headerlink" title="最优解："></a>最优解：</h4><h5 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h5><p>首先时间复杂度要求O(log(m+n))，自然想到二分法。</p><hr><ol><li><p>设定一个k，k为第k小的数</p><p>如果数组长度是奇数，直接求<strong>k&#x3D;(sum+1)&#x2F;2</strong>小的数，即中位数</p><p>如果数组长度是偶数，不光要求上面的k，还要再求一个k，<strong>k&#x3D;(sum+2)&#x2F;2</strong>小的数，然后把他们平均。</p><p>ex：</p><p>假设两个数组和是7，奇数，k&#x3D;(7+1)&#x2F;2&#x3D;4，第4小的数就是中位数。</p><p>假设两个数组和是10，偶数，第一个k&#x3D;(10+1)&#x2F;2&#x3D;5，第二个k&#x3D;(10+2)&#x2F;2&#x3D;6，索引位置5和6的和的平均值，即为中位数。</p></li><li><p>在第一个数组中取前<strong>k&#x2F;2</strong>个数，则第二个数组取前<strong>k-k&#x2F;2</strong>个数。</p><p>设两个数组分别为A，B</p><p><strong>① 如果 A[k&#x2F;2] &lt; B[k-k&#x2F;2]，那么第k个数一定不在A中前k&#x2F;2中，直接删掉，删掉了k&#x2F;2个数，一共还剩k-k&#x2F;2个数。</strong></p><p><strong>② 如果 A[k&#x2F;2] &gt; B[k-k&#x2F;2]，那么第k个数一定不在B中前k-k&#x2F;2中，直接删掉，删掉了k&#x2F;2个数，一共还剩k-(k-k&#x2F;2)个数。</strong></p><p><strong>③ 如果 k&#x3D;&#x3D;1，这里是递归的出口。</strong></p><p>ex：</p><p><strong>A : [1,3,6,9]</strong></p><p><strong>B : [1,2,3,4,5,6,7]</strong></p><blockquote><ol><li><p>一共11个数，奇数个，k&#x3D;(11+1)&#x2F;2&#x3D;6，找出第6小的数。</p></li><li><p>k&#x3D;6，k&#x2F;2&#x3D;3，k-k&#x2F;2&#x3D;3。</p><p>A第3个数，6</p><p>B第3个数，3</p><p>A[k&#x2F;2] &gt; B[k-k&#x2F;2]，那么B中前k-k&#x2F;2，可以直接“删除”，指针移动到B中的4，A中不变。</p></li></ol></blockquote><p><strong>A : [1,3,6,9]</strong></p><p><strong>B : [4,5,6,7]</strong></p><blockquote><ol start="3"><li><p>一共还剩k&#x3D;k-(k-k&#x2F;2)&#x3D;3个数，找出第3小的数。</p></li><li><p>k&#x3D;3，k&#x2F;2&#x3D;1，k-k&#x2F;2&#x3D;2</p><p>A第1个数，1</p><p>B第2个数，5</p><p>A[k&#x2F;2] &lt; B[k-k&#x2F;2]，A中前k&#x2F;2个数，可以直接“删除”，指针移动到A中的3，B中不变。</p></li></ol></blockquote><p><strong>A : [3,6,9]</strong></p><p><strong>B : [4,5,6,7]</strong></p><blockquote><ol start="5"><li><p>一共还剩k&#x3D;k-k&#x2F;2&#x3D;2个数，找出第2小的数。</p></li><li><p>k&#x3D;2，k&#x2F;2&#x3D;1，k-k&#x2F;2&#x3D;1</p><p>A第1个数，3</p><p>B第1个数，4</p><p>A[k&#x2F;2] &lt; B[k-k&#x2F;2]，A中前k&#x2F;2个数，可以直接“删除”，指针移动到A中的6，B中不变。</p></li></ol></blockquote><p><strong>A : [6,9]</strong></p><p><strong>B : [4,5,6,7]</strong></p><blockquote><ol start="7"><li><p>一共还剩k&#x3D;k-k&#x2F;2&#x3D;1个数，找出第1小的数。</p></li><li><p>已经到了递归的出口，直接比较两个数组中，指针的位置，哪个更小，就是中位数。</p><p>4和6比较，4更小，4是中位数。</p></li></ol></blockquote></li></ol><h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums2.length;<br>    <span class="hljs-comment">// 中位数1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> (n + m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 中位数2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (n + m + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>   <br>    <span class="hljs-keyword">return</span> (getKth(nums1, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, left) + getKth(nums1, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, right)) * <span class="hljs-number">0.5</span>;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getKth</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> start1, <span class="hljs-type">int</span> end1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> start2, <span class="hljs-type">int</span> end2, <span class="hljs-type">int</span> k)</span> &#123;<br>    <br>    <span class="hljs-comment">// 求两个数组的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> end1 - start1 + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> end2 - start2 + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 如果nums1比nums2长，两个数组交换，让nums1总是数少的那个。</span><br>    <span class="hljs-keyword">if</span> (len1 &gt; len2) <span class="hljs-keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);<br>    <br>    <span class="hljs-comment">// 如果nums1用完了，直接找出中位数即可。</span><br>    <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> nums2[start2 + k - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 如果k==1，说明就在两个数组中的指针最开始的位置比较了，哪个小哪个就是中位数。</span><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Math.min(nums1[start1], nums2[start2]);<br><br>    <span class="hljs-comment">// 设定两个数组起始位置</span><br>    <span class="hljs-comment">// 这里把数组长度和k/2比较，是为了防止k/2越界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start1 + Math.min(len1, k / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> start2 + Math.min(len2, k / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 如果较小的数在第二个数组中</span><br>    <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;<br>        <span class="hljs-comment">// nums1的指针不动，nums2的指针移动j+1个距离，相当于把j+1前面的所有数都删掉了。</span><br>        <span class="hljs-keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="hljs-number">1</span>, end2, k - (j - start2 + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-comment">// 如果较小的数在第一个数组中</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// nums2的指针不动，nums1的指针移动i+1个距离，相当于把i+1前面的所有数都删掉了。</span><br>        <span class="hljs-keyword">return</span> getKth(nums1, i + <span class="hljs-number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode力扣</category>
      
      <category>Hard</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVCC原理</title>
    <link href="/2022/09/21/MVCC%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/21/MVCC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h1><p><a href="https://www.bilibili.com/video/BV1hL411479T/?spm_id_from=333.999.0.0&vd_source=b1d026ff22cbf6f06b334c7d53529a2a">【IT老齐030】这可能是最直白的MySQL MVCC机制讲解啦!</a></p><p>在MySQL InnoDB存储引擎下，RC（读已提交）、RR（可重复读）基于MVCC（多版本并发控制）进行并发事务控制。</p><p>MVCC是基于“数据版本”对并发事务进行访问。</p><h2 id="一、示例"><a href="#一、示例" class="headerlink" title="一、示例"></a>一、示例</h2><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230206234203521.png" alt="多个事务执行"></p><p>前面三个事务按照时间线依次执行，事务ID依次自增。</p><p>而第4个事务相对比较特殊，它没做任何数据调整，直接进行了两次读取操作，然而两次读取的时机非常的微妙。</p><p>第1次读取，在事务A提交后，事务B提交前执行的。</p><p>第2次读取，同样的SQL，是在事务C提交之前执行的。</p><p>此时事务A和事务B都已经结束了，针对于当前的处理来说，如果采用RR（可重复读）的隔离级别来说，RR可以解决不可重复读的问题，所以前后执行它都得到了同一个结果：</p><blockquote><p>RR级别：Select1 &#x3D; 张三，Select2 &#x3D; 张三</p></blockquote><p>而RC是读已提交，是不能保证不可重复读的。</p><blockquote><p>RR级别：Select1 &#x3D; 张三，Select2 &#x3D; 张小三</p></blockquote><h2 id="二、基本知识"><a href="#二、基本知识" class="headerlink" title="二、基本知识"></a>二、基本知识</h2><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230206234827436.png" alt="UNDO_LOG版本链"></p><h3 id="1-什么是UNDO-LOG？"><a href="#1-什么是UNDO-LOG？" class="headerlink" title="1. 什么是UNDO_LOG？"></a>1. 什么是UNDO_LOG？</h3><p>undo_log就是回滚日志的意思，在我们进行事务处理中，如果我们进行回滚操作，能够进行还原，在innoDB存储引擎中，采用UNDO_LOG链的方式来保存一个一个的数据变化。</p><h3 id="2-版本链是如何组织的？"><a href="#2-版本链是如何组织的？" class="headerlink" title="2. 版本链是如何组织的？"></a>2. 版本链是如何组织的？</h3><p>以示例为例，最上面一行保存了当前表中的数据，因为事务执行完以后，最后的结果为“张老三”。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230206235419152.png" alt="最后的结果"></p><p>当前的事务编号 trx_id为3，“张老三”的记录下，作为innoDB会额外的附加两个字段，<code>trx_id</code>和<code>DB_ROLL_PTR</code>。</p><blockquote><p>trx_id 代表最后一次更新的时候的事务编号</p><p>DB_ROLL_PTR 是一个指针，指向了上次进行版本变化时的数据。</p></blockquote><p>在3号id执行前，由2号id提交为“张小三”。</p><p>所以第二行保存了由2号事务处理时所产生的镜像。</p><p>在2号id之前还有1号事务的更新操作，name更新为“张三”。</p><p>无论1号事务是否提交，都会被记到版本链中。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230207000040876.png" alt="事务操作时的版本链"></p><p>还有一个最原始的数据。</p><p>因为“张三丰”是最原始的数据，所以最后一行没有事务编号，指针也是空的。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230207000142491.png" alt="原始数据"></p><p>到这里就明白了，原始数据为“张三丰”，经过了三次更新，更新为了“张老三”，每一次数据都采用事务编号作为版本来进行标识，这样就能有效的标识出每一个版本。</p><h3 id="3-UNDO-LOG不是会被删除吗？"><a href="#3-UNDO-LOG不是会被删除吗？" class="headerlink" title="3. UNDO_LOG不是会被删除吗？"></a>3. UNDO_LOG不是会被删除吗？</h3><p><strong>Q：中间数据万一被删了版本链不就断了吗？</strong></p><p>A：UNDO_LOG版本链并不是用完了立即删除的，而是MySQL确保版本链数据不再被“引用”后再进行删除。</p><p>所以UNDO_LOG版本链除了一些不可控因素外，应该都是完整的。</p><h3 id="4-什么是ReadView？"><a href="#4-什么是ReadView？" class="headerlink" title="4. 什么是ReadView？"></a>4. 什么是ReadView？</h3><p>ReadView是“快照读”SQL执行时MVCC提取数据的依据。</p><p>（1）<strong>快照读</strong>就是最普通的Select查询的SQL语句</p><p>（2）<strong>当前读</strong>指执行下列语句时进行数据的方式：</p><p>Insert、Update、Delete、</p><p>Select… for update（写锁）</p><p>Select… lock in share mode（读锁）</p><hr><p><strong>ReadView</strong>是一个数据结构，包含4个字段。</p><ul><li><strong>m_ids</strong>：当前活跃的事务编号集合</li><li><strong>min_trx_id</strong>：最小活跃事务编号</li><li><strong>max_trx_id</strong>：预分配事务编号，当前最大事务编号+1</li><li><strong>creator_trx_id</strong>：ReadView创建者的事务编号</li></ul><h2 id="三、MVCC分析"><a href="#三、MVCC分析" class="headerlink" title="三、MVCC分析"></a>三、MVCC分析</h2><h3 id="1-读已提交（RC）"><a href="#1-读已提交（RC）" class="headerlink" title="1. 读已提交（RC）"></a>1. 读已提交（RC）</h3><p>在每一次执行快照读的时候生成一次ReadView</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230207001231486.png" alt="RC级别ReadView分析"></p><p>第一次Select，当前活跃的事务id为2、3、4</p><p>最小的事务id&#x3D;2</p><p>预生成的事务编号&#x3D;5</p><p>创建者编号&#x3D;4</p><p>第二次Select，活跃的事务id为3、4，2已经被提交。</p><p>最小的事务id&#x3D;3</p><p>预生成的事务编号&#x3D;5</p><p>创建者编号&#x3D;4</p><h4 id="数据提取的过程"><a href="#数据提取的过程" class="headerlink" title="数据提取的过程"></a>数据提取的过程</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230207001544237.png" alt="RC级别数据提取的过程-第一次Select"></p><p>将每一个版本的数据代入到右侧的判断规则来，如果在右侧有符合条件的，直接把当前版本的数据返回。如果右侧的条件都不满足，按照版本链向下依次尝试，知道获得满足条件的结果。</p><ol><li><p>张老三</p><p>(1) 3&#x3D;4 不成立，向下判断</p><p>(2) 3&lt;2 不成立，向下判断</p><p>(3) 3&gt;5 不成立，向下判断</p><p>(4) 2&lt;&#x3D;3&lt;&#x3D;5 &amp;&amp; 3 not in {2,3,4} 不成立。</p></li><li><p>张小三</p><p>(1) 2&#x3D;4 不成立，向下判断</p><p>(2) 2&lt;2 不成立，向下判断</p><p>(3) 2&gt;5 不成立，向下判断</p><p>(4) 2&lt;&#x3D;2&lt;&#x3D;5 &amp;&amp; 2 not in {2,3,4} 不成立。</p></li><li><p>张三</p><p>(1) 1&#x3D;4 不成立，向下判断</p><p>(2) 1&lt;2 成立，说明数据已经被提交了，返回结果<strong>张三</strong>。</p></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230207002728887.png" alt="RC级别数据提取的过程-第二次Select"></p><ol><li><p>张老三</p><p>(1) 3&#x3D;4 不成立，向下判断</p><p>(2) 3&lt;3 不成立，向下判断</p><p>(3) 3&gt;5 不成立，向下判断</p><p>(4) 3&lt;&#x3D;3&lt;&#x3D;5 &amp;&amp; 3 not in {3,4} 不成立。</p></li><li><p>张小三</p><p>(1) 2&#x3D;4 不成立，向下判断</p><p>(2) 2&lt;3 成立，说明数据已经被提交了，返回结果<strong>张小三</strong>。</p></li></ol><p>总结：读已提交的隔离级别下，第一次读的是“张三”，第二次读的是“张小三”，显然出现了不可重复读的现象。所以在RC的级别下是不能解决不可重复读的。</p><h3 id="2-可重复读（RR）"><a href="#2-可重复读（RR）" class="headerlink" title="2. 可重复读（RR）"></a>2. 可重复读（RR）</h3><p>仅在第一次执行快照读的时候生成ReadView，后续快照读会复用第一次的ReadView。（有例外）</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230207003055059.png" alt="第二次Select复用了第一次的ReadView"></p><p>总结：所以第一次执行得到的是“张三”，第二次执行得到的也是“张三”，ReadView复用的方式解决了不可重复读的情况。</p><h3 id="3-RR级别下使用MVCC能避免幻读吗？"><a href="#3-RR级别下使用MVCC能避免幻读吗？" class="headerlink" title="3. RR级别下使用MVCC能避免幻读吗？"></a>3. RR级别下使用MVCC能避免幻读吗？</h3><p>能，但不完全能！</p><p>因为作为MVCC并不是采用锁的方式完全的对事务数据进行的隔离，而是通过版本控制的方式变相的实现了解决幻读的功能。</p><p>在连续多次读的情况下，ReadView会产生复用，没有幻读问题。</p><p><em>特例：当两次<strong>快照读</strong>之间存在<strong>当前读</strong>，ReadView会重新生成，导致幻读。</em></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230207003711816.png" alt="前后两个事务加入了当前读"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MySQL</category>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MVCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ShardingSphere-JDBC</title>
    <link href="/2022/07/23/ShardingSphere-JDBC/"/>
    <url>/2022/07/23/ShardingSphere-JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="ShardingSphere-JDBC"><a href="#ShardingSphere-JDBC" class="headerlink" title="ShardingSphere-JDBC"></a>ShardingSphere-JDBC</h1><h2 id="一、ShardingSphere介绍"><a href="#一、ShardingSphere介绍" class="headerlink" title="一、ShardingSphere介绍"></a>一、ShardingSphere介绍</h2><h3 id="1-Apache-ShardingSphere"><a href="#1-Apache-ShardingSphere" class="headerlink" title="1.Apache ShardingSphere"></a>1.Apache ShardingSphere</h3><p>Apache ShardingSphere 是一套开源的分布式数据库解决方案组成的生态圈，它由 JDBC、Proxy 和 Sidecar（规划中）这 3 款既能够独立部署，又支持混合部署配合使用的产品组成。它们均提供标准化的数据水平扩展、分布式事务和分布式治理等功能，可适用于如 Java 同构、异构语⾔、云原生等各种多样化的应用场景。</p><p>Apache ShardingSphere 旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。 关系型数据库当今依然占有巨大市场份额，是企业核心系统的基石，未来也难于撼动，我们更加注重在原有基础上提供增量，而非颠覆。</p><p>ShardingSphere 已于2020年4月16日成为 Apache 软件基金会的顶级项目。</p><h3 id="2-ShardingSphere-JDBC"><a href="#2-ShardingSphere-JDBC" class="headerlink" title="2.ShardingSphere-JDBC"></a>2.ShardingSphere-JDBC</h3><p>定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容JDBC 和各种 ORM 框架。</p><ul><li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBCTemplate 或直接使用 JDBC；</li><li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, HikariCP 等；</li><li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，PostgreSQL，Oracle，SQLServer 以及任何可使用 JDBC 访问的数据库。</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230517235839013.png"></p><h3 id="3-ShardingSphere-Proxy"><a href="#3-ShardingSphere-Proxy" class="headerlink" title="3.ShardingSphere-Proxy"></a>3.ShardingSphere-Proxy</h3><p>定位为透明化的数据库代理端，提供封装了数据库⼆进制协议的服务端版本，用于完成对异构语⾔的支持。 目前提供 MySQL 和 PostgreSQL（兼容 openGauss 等基于 PostgreSQL 的数据库）版本，它可以使用任何兼容MySQL&#x2F;PostgreSQL 协议的访问客户端（如：MySQLCommand Client, MySQL Workbench, Navicat 等）操作数据，对 DBA 更加友好。</p><ul><li>向应用程序完全透明，可直接当做 MySQL&#x2F;PostgreSQL 使用；</li><li>适用于任何兼容 MySQL&#x2F;PostgreSQL 协议的的客户端。</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518000240949.png"></p><h3 id="4-ShardingSphere-Sidecar（TODO）"><a href="#4-ShardingSphere-Sidecar（TODO）" class="headerlink" title="4.ShardingSphere-Sidecar（TODO）"></a>4.ShardingSphere-Sidecar（TODO）</h3><p>定位为 Kubernetes 的云原生数据库代理，以 Sidecar 的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的啮合层，即 <code>Database Mesh </code>，又可称数据库网格。</p><p>Database Mesh 的关注重点在于如何将分布式的数据访问应用与数据库有机串联起来，它更加关注的是交互，是将杂乱无章的应用与数据库之间的交互进行有效地梳理。 使⽤Database Mesh，访问数据库的应用和数据库终将形成一个巨大的网格体系，应用和数据库只需在网格体系中对号入座即可，它们都是被啮合层所治理的对象。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518000358776.png" alt="image-20230518000358776"></p><table><thead><tr><th></th><th>ShardingSphere-JDBC</th><th>ShardingSphere-Proxy</th><th>ShardingSphere-Sidecar</th></tr></thead><tbody><tr><td>数据库</td><td>任意</td><td>MySQL&#x2F;PostgreSQL</td><td>MySQL&#x2F;PostgreSQL</td></tr><tr><td>连接消耗数</td><td>高</td><td>低</td><td>高</td></tr><tr><td>异构语⾔</td><td>仅 Java</td><td>任意</td><td>任意</td></tr><tr><td>性能</td><td>损耗低</td><td>损耗略高</td><td>损耗低</td></tr><tr><td>无中心化</td><td>是</td><td>否</td><td>是</td></tr><tr><td>静态入口</td><td>无</td><td>有</td><td>无</td></tr></tbody></table><h2 id="二、快速开始"><a href="#二、快速开始" class="headerlink" title="二、快速开始"></a>二、快速开始</h2><h3 id="1-部署第一台MySQL服务器"><a href="#1-部署第一台MySQL服务器" class="headerlink" title="1.部署第一台MySQL服务器"></a>1.部署第一台MySQL服务器</h3><p>使⽤docker部署第一台MySQL服务器，先来快速体验ShardingSphere带来的分表功能。在之后的分库分表中，再加入第⼆台MySQL服务器。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql-0:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql-0</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span><br>      <span class="hljs-string">--character-set-server=utf8mb4</span><br>      <span class="hljs-string">--collation-server=utf8mb4_general_ci</span><br>      <span class="hljs-string">--explicit_defaults_for_timestamp=true</span><br>      <span class="hljs-string">--lower_case_table_names=1</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/var/lib/mysql</span><br></code></pre></td></tr></table></figure><p>使用<code>docker-compose up -d</code>命令启动</p><h3 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2.创建数据库"></a>2.创建数据库</h3><p>创建名为<code>db_device_0</code>的数据库。</p><h3 id="3-创建物理表"><a href="#3-创建物理表" class="headerlink" title="3.创建物理表"></a>3.创建物理表</h3><p>逻辑上tb_device表示的是描述设备信息的表，为了体现分表的概念，把tb_device表分成了两张。于是tb_device就是逻辑表，⽽tb_device_0和tb_device_1就是该逻辑表的物理表。</p><ul><li>创建<code>tb_device_0</code>表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_device_0` (<br> `device_id` bigint NOT NULL AUTO_INCREMENT,<br> `device_type` int DEFAULT NULL,<br> PRIMARY KEY (`device_id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb3;<br></code></pre></td></tr></table></figure><ul><li>创建<code>tb_device_1</code>表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_device_1` (<br> `device_id` bigint NOT NULL AUTO_INCREMENT,<br> `device_type` int DEFAULT NULL,<br> PRIMARY KEY (`device_id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb3;<br></code></pre></td></tr></table></figure><h3 id="4-创建ShardingSphere项目并引入依赖"><a href="#4-创建ShardingSphere项目并引入依赖" class="headerlink" title="4.创建ShardingSphere项目并引入依赖"></a>4.创建ShardingSphere项目并引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.qf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>my-sharding-jdbc-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>my-sharding-jdbc-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-boot.version</span>&gt;</span>2.3.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.qf.my.sharding.jdbc.demo.MyShardingJdbcDemoApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-编写配置⽂件application-properties"><a href="#5-编写配置⽂件application-properties" class="headerlink" title="5.编写配置⽂件application.properties"></a>5.编写配置⽂件application.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 配置真实数据源</span><br><span class="hljs-attr">spring.shardingsphere.datasource.names</span>=<span class="hljs-string">ds1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置第 1 个数据源</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.url</span>=<span class="hljs-string">jdbc:mysql://172.16.253.84:3306/db_device_0?serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置物理表</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.actual-data-nodes</span>=<span class="hljs-string">ds1.tb_device_$-&gt;&#123;0..1&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置分表策略：根据device_id作为分片的依据（分片键）</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.table-strategy.inline.sharding-column</span>=<span class="hljs-string">device_id</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.table-strategy.inline.algorithm-expression</span>=<span class="hljs-string">tb_device_$-&gt;&#123;device_id%2&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 开启SQL显示</span><br><span class="hljs-attr">spring.shardingsphere.props.sql.show</span> = <span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><h3 id="6-创建逻辑表对应的实体"><a href="#6-创建逻辑表对应的实体" class="headerlink" title="6.创建逻辑表对应的实体"></a>6.创建逻辑表对应的实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.entity;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TbDevice</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> deviceId;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> deviceType;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-使用MyBatis-Plus做映射"><a href="#7-使用MyBatis-Plus做映射" class="headerlink" title="7.使用MyBatis-Plus做映射"></a>7.使用MyBatis-Plus做映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.mapper;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<br><span class="hljs-keyword">import</span> com.qf.my.sharding.jdbc.demo.entity.TbDevice;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeviceMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;TbDevice&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-配置Springboot启动类"><a href="#8-配置Springboot启动类" class="headerlink" title="8.配置Springboot启动类"></a>8.配置Springboot启动类</h3><p>关键是配置MapperScan</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo;<br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.qf.my.sharding.jdbc.demo.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyShardingJdbcDemoApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(MyShardingJdbcDemoApplication.class,args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-编写单元测试"><a href="#9-编写单元测试" class="headerlink" title="9.编写单元测试"></a>9.编写单元测试</h3><p>尝试插入10条device数据，因为分片键是device_id，且分片策略是 <code>tb_device_$-&gt;&#123;device_id%2&#125;</code> ，因此会根据device_id来决定该条数据会插入到哪张物理表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo;<br><span class="hljs-keyword">import</span> com.qf.my.sharding.jdbc.demo.entity.TbDevice;<br><span class="hljs-keyword">import</span> com.qf.my.sharding.jdbc.demo.mapper.DeviceMapper;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyShardingJdbcDemoApplicationTests</span> &#123;<br>    <br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DeviceMapper deviceMapper;<br>    <br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">initData</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-type">TbDevice</span> <span class="hljs-variable">device</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TbDevice</span>();<br>device.setDeviceId((<span class="hljs-type">long</span>) i);<br>device.setDeviceType(i);<br>deviceMapper.insert(device);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现，根据分片策略，这10条数据中id是奇数的数据将会被插入到tb_device_1表中，id是奇数的数据将会被插入到tb_device_0表中。</p><h2 id="三、尝试分库分表"><a href="#三、尝试分库分表" class="headerlink" title="三、尝试分库分表"></a>三、尝试分库分表</h2><h3 id="1-准备第二台MySQL服务器"><a href="#1-准备第二台MySQL服务器" class="headerlink" title="1.准备第二台MySQL服务器"></a>1.准备第二台MySQL服务器</h3><p>使⽤docker创建第⼆台MySQL服务器。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql-1:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql-1</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span><br>      <span class="hljs-string">--character-set-server=utf8mb4</span><br>      <span class="hljs-string">--collation-server=utf8mb4_general_ci</span><br>      <span class="hljs-string">--explicit_defaults_for_timestamp=true</span><br>      <span class="hljs-string">--lower_case_table_names=1</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/var/lib/mysql</span><br></code></pre></td></tr></table></figure><p>创建db_device_1数据库。并在数据库中创建两张物理表：</p><ul><li>创建tb_device_0表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_device_0` (<br> `device_id` bigint NOT NULL AUTO_INCREMENT,<br> `device_type` int DEFAULT NULL,<br> PRIMARY KEY (`device_id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb3;<br></code></pre></td></tr></table></figure><ul><li>创建tb_device_1表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_device_1` (<br> `device_id` bigint NOT NULL AUTO_INCREMENT,<br> `device_type` int DEFAULT NULL,<br> PRIMARY KEY (`device_id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb3;<br></code></pre></td></tr></table></figure><h3 id="2-配置数据库源"><a href="#2-配置数据库源" class="headerlink" title="2.配置数据库源"></a>2.配置数据库源</h3><p>提供两个数据源，将之前搭建的两台MySQL服务器作为数据源。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 配置真实数据源</span><br><span class="hljs-attr">spring.shardingsphere.datasource.names</span>=<span class="hljs-string">ds0,ds1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置第 1 个数据源</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.url</span>=<span class="hljs-string">jdbc:mysql://172.16.253.84:3306/db_device_0?serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置第 2 个数据源</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.url</span>=<span class="hljs-string">jdbc:mysql://172.16.253.85:3306/db_device_1?serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><h3 id="3-配置数据库表的分片策略"><a href="#3-配置数据库表的分片策略" class="headerlink" title="3.配置数据库表的分片策略"></a>3.配置数据库表的分片策略</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 配置分库的分片策略，根据device_id进行分片，奇偶不同进入不同的数据库：ds1,ds2</span><br><span class="hljs-attr">spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column</span>=<span class="hljs-string">device_id</span><br><span class="hljs-attr">spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression</span>=<span class="hljs-string">ds$-&gt;&#123;device_id % 2&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 根据groovy脚本配置数据源+表名</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.actual-data-nodes</span>=<span class="hljs-string">ds$-&gt;&#123;0..1&#125;.tb_device_$-&gt;&#123;0..1&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置分表策略</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.table-strategy.inline.sharding-column</span>=<span class="hljs-string">device_id</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.table-strategy.inline.algorithm-expression</span>=<span class="hljs-string">tb_device_$-&gt;&#123;device_id%2&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 开启显示sql语句</span><br><span class="hljs-attr">spring.shardingsphere.props.sql.show</span> = <span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>相比之前的配置，这次加入了两个数据库的分片策略，根据device_id的奇偶特性决定存入哪个数据库中。同时，使用groovy脚本确定了数据库和表之间的关系。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ds$-&gt;&#123;<span class="hljs-number">0.</span><span class="hljs-number">.1</span>&#125;.tb_device_$-&gt;&#123;<span class="hljs-number">0.</span><span class="hljs-number">.1</span>&#125;<br></code></pre></td></tr></table></figure><p>等效于：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ds0<span class="hljs-selector-class">.tb_device_0</span><br>ds0<span class="hljs-selector-class">.tb_device_1</span><br>ds1<span class="hljs-selector-class">.tb_device_0</span><br>ds1.tb_device_1<br></code></pre></td></tr></table></figure><p>此时再运行测试用例，发现device_id的奇数数据会存入 <code>ds1.tb_device_1</code> 表中，偶数数据会存入 <code>ds0.tb_device_0</code> 表中。</p><h3 id="4-在分库分表下做查询"><a href="#4-在分库分表下做查询" class="headerlink" title="4.在分库分表下做查询"></a>4.在分库分表下做查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryDeviceByID</span><span class="hljs-params">()</span>&#123;<br> QueryWrapper&lt;TbDevice&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br> queryWrapper.eq(<span class="hljs-string">&quot;device_id&quot;</span>,<span class="hljs-number">1L</span>);<br> List&lt;TbDevice&gt; deviceList =<br>deviceMapper.selectList(queryWrapper);<br> System.out.println(deviceList);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="5-分库分表存在的问题"><a href="#5-分库分表存在的问题" class="headerlink" title="5.分库分表存在的问题"></a>5.分库分表存在的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">queryDeviceByID</span><span class="hljs-params">()</span>&#123;<br>QueryWrapper&lt;TbDevice&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>queryWrapper.eq(<span class="hljs-string">&quot;device_id&quot;</span>,<span class="hljs-number">1L</span>);<br>List&lt;TbDevice&gt; deviceList =<br>deviceMapper.selectList(queryWrapper);<br>System.out.println(deviceList);<br>&#125;<br></code></pre></td></tr></table></figure><p>使⽤device_id做范围查询时，发现报错了：inline的分片策略没有办法支持范围查询。</p><p>### Cause: java.lang.IllegalStateException: Inline strategy cannot support this type sharding:RangeRouteValue(columnName&#x3D;device_id, tableName&#x3D;tb_device, valueRange&#x3D;[1‥10])</p><p>接下来需要掌握的是分片策略</p><h2 id="四、分库分表核心知识点"><a href="#四、分库分表核心知识点" class="headerlink" title="四、分库分表核心知识点"></a>四、分库分表核心知识点</h2><h3 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1.核心概念"></a>1.核心概念</h3><p>在了解分片策略之前，先来了解以下几个重点概念：逻辑表、真实表、数据节点、绑定表、⼴播表。</p><ul><li><p>逻辑表</p><p>水平拆分的数据库（表）的相同逻辑和数据结构表的总称。例：订单数据根据主键尾数拆分为10张表，分别是 <code>t_order_0</code> 到 <code>t_order_9</code> ，他们的逻辑表名为 <code>t_order</code> 。</p></li><li><p>真实表</p><p>在分片的数据库中真实存在的物理表。即上个示例中的 <code>t_order_0</code> 到 <code>t_order_9</code> 。</p></li><li><p>数据节点</p><p>数据分片的最小单元。由数据源名称和数据表组成，例： <code>ds_0.t_order_0</code> 。</p></li><li><p>绑定表</p><p>指分片规则一致的主表和子表。例如： <code>t_order</code> 表和 <code>t_order_item</code> 表，均按照 <code>order_id</code> 分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。举例说明，如果SQL为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);<br></code></pre></td></tr></table></figure><p>在不配置绑定表关系时，假设分片键 order_id 将数值10路由至第0⽚，将数值11路由至第1片，那么路由后的SQL应该为4条，它们呈现为笛卡尔积：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);<br>SELECT i.* FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);<br>SELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);<br>SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);<br></code></pre></td></tr></table></figure><p>在配置绑定表关系后，路由的SQL应该为2条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);<br>SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);<br></code></pre></td></tr></table></figure><p>其中 <code>t_order</code> 在FROM的最左侧，ShardingSphere将会以它作为整个绑定表的主表。 所有路由计算将会只使用主表的策略，那么 <code>t_order_item</code> 表的分片计算将会使用 <code>t_order</code> 的条件。故绑定表之间的分区键要完全相同。</p></li><li><p>⼴播表</p><p>指所有的分片数据源中都存在的表，表结构和表中的数据在每个数据库中均完全一致。适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。</p></li></ul><h3 id="2-分片及分片策略"><a href="#2-分片及分片策略" class="headerlink" title="2.分片及分片策略"></a>2.分片及分片策略</h3><h4 id="1）分片键"><a href="#1）分片键" class="headerlink" title="1）分片键"></a>1）分片键</h4><p>用于分片的数据库字段，是将数据库(表)水平拆分的关键字段。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，ShardingSphere也支持根据多个字段进行分片。</p><h4 id="2）分片算法"><a href="#2）分片算法" class="headerlink" title="2）分片算法"></a>2）分片算法</h4><p>通过分片算法将数据分片，支持通过 <code>=</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>BETWEEN</code> 和 <code>IN</code> 分片。分片算法需要应用方开发者自行实现，可实现的灵活度非常高。</p><p>目前提供4种分片算法。由于分片算法和业务实现紧密相关，因此并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。</p><ul><li><p>精确分片算法</p><p>对应<code>PreciseShardingAlgorithm</code>，用于处理使用单一键作为分片键的&#x3D;与IN进行分片的场景。需要配合<code>StandardShardingStrategy</code>使用。</p></li><li><p>范围分片算法</p><p>对应<code>RangeShardingAlgorithm</code>，用于处理使用单一键作为分片键的BETWEEN AND、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;进行分片的场景。需要配合<code>StandardShardingStrategy</code>使用。</p></li><li><p>复合分片算法</p><p>对应C<code>omplexKeysShardingAlgorithm</code>，用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。需要配合<code>ComplexShardingStrategy</code>使用。</p></li><li><p>Hint分片算法</p><p>对应<code>HintShardingAlgorithm</code>，用于处理使⽤Hint⾏分片的场景。需要配合<code>HintShardingStrategy</code>使用</p></li></ul><h4 id="3）分片策略"><a href="#3）分片策略" class="headerlink" title="3）分片策略"></a>3）分片策略</h4><p>包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。目前提供5种分片策略。</p><ul><li><p>标准分片策略</p><p>对应StandardShardingStrategy。</p><p>提供对SQL语句中的&#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, IN和BETWEEN AND的分片操作支持。</p><p>StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。</p><p>PreciseShardingAlgorithm是必选的，用于处理&#x3D;和IN的分片。</p><p>RangeShardingAlgorithm是可选的，用于处理BETWEEN AND, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;分片，如果不配置RangeShardingAlgorithm，SQL中的BETWEEN AND将按照全库路由处理。</p></li><li><p>复合分片策略</p><p>对应ComplexShardingStrategy。</p><p>复合分片策略。提供对SQL语句中的&#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, IN和BETWEEN AND的分片操作支持。</p><p>ComplexShardingStrategy⽀持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度。</p></li><li><p>行表达式分片策略</p><p>对应InlineShardingStrategy。</p><p>使⽤Groovy的表达式，提供对SQL语句中的&#x3D;和IN的分片操作支持，只支持单分片键。</p><p>对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: <code>t_user_$-&gt;&#123;u_id % 8&#125;</code> 表示t_user表根据u_id模8，而分成8张表，表名称为 <code>t_user_0</code> 到 <code>t_user_7</code> 。</p></li><li><p>Hint分片策略</p><p>对应HintShardingStrategy。通过Hint指定分片值而非从SQL中提取分片值的方式进行分片的策略。</p></li><li><p>不分片策略</p><p>对应NoneShardingStrategy。不分片的策略。</p></li></ul><h3 id="3-分片策略的实现"><a href="#3-分片策略的实现" class="headerlink" title="3.分片策略的实现"></a>3.分片策略的实现</h3><h4 id="1）Standard标准分片策略的精准分片"><a href="#1）Standard标准分片策略的精准分片" class="headerlink" title="1）Standard标准分片策略的精准分片"></a>1）Standard标准分片策略的精准分片</h4><p>在Standard标准分片策略可以分别配置在分库和分表中。配置时需要指明分片键，精确分片或范围分片。</p><ul><li><p>配置分库的精确分片</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.shardingsphere.sharding.default-databasestrategy.standard.sharding-column</span>=<span class="hljs-string">device_id</span><br><span class="hljs-attr">spring.shardingsphere.sharding.default-databasestrategy.standard.precise-algorithm-class-name</span>=<span class="hljs-string">com.qf.my.sharding.jdbc.demo.sharding.algorithm.database.MyDatabaseStandardPreciseAlgorithm</span><br></code></pre></td></tr></table></figure><p>需要提供一个实现精确分片算法的实现类，其中精确分片的逻辑可以与inline中的行表达式用意相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.sharding.algorithm.database;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.standard.PreciseShardingAlgorithm;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDatabaseStandardPreciseAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PreciseShardingAlgorithm</span>&lt;<span class="hljs-type">long</span>&gt; &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据库的标准分片策略</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> collection 具体的物理库</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> preciseShardingValue 分片条件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doSharding</span><span class="hljs-params">(Collection&lt;String&gt; collection,PreciseShardingValue&lt;<span class="hljs-type">long</span>&gt; preciseShardingValue)</span> &#123;<br>        <span class="hljs-comment">//获得逻辑表名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">logicTableName</span> <span class="hljs-operator">=</span>preciseShardingValue.getLogicTableName();<br>        <span class="hljs-comment">//分片键，列名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">columnName</span> <span class="hljs-operator">=</span> preciseShardingValue.getColumnName();<br>        <span class="hljs-comment">//分片键的具体值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> preciseShardingValue.getValue();<br>        <span class="hljs-comment">//根据分片策略：ds$-&gt;&#123;device_id % 2&#125; 做精确分片</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shardingKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ds&quot;</span> + (value % <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(!collection.contains(shardingKey))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;数据库:&quot;</span>+shardingKey+<span class="hljs-string">&quot;不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> shardingKey;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置分表的精确分片</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># standard</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.tablestrategy.standard.sharding-column</span>=<span class="hljs-string">device_id</span><br><span class="hljs-comment"># 精确查找的算法实现类</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.tablestrategy.standard.precise-algorithm-class-name</span>=<span class="hljs-string">com.qf.my.sharding.jdbc.demo.sharding.algorithm.table.MyTableStandardPreciseAlgorithm</span><br></code></pre></td></tr></table></figure><p>同时，需要提供分表的精确分片算法的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.sharding.algorithm.table;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.standard.PreciseShardingAlgorithm;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTableStandardPreciseAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PreciseShardingAlgorithm</span>&lt;<span class="hljs-type">long</span>&gt; &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doSharding</span><span class="hljs-params">(Collection&lt;String&gt; collection,PreciseShardingValue&lt;<span class="hljs-type">long</span>&gt; preciseShardingValue)</span> &#123;<br>        <span class="hljs-comment">//获得逻辑表名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">logicTableName</span> <span class="hljs-operator">=</span>preciseShardingValue.getLogicTableName();<br>        <span class="hljs-comment">//分片键，列名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">columnName</span> <span class="hljs-operator">=</span> preciseShardingValue.getColumnName();<br>        <span class="hljs-comment">//分片键的具体值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> preciseShardingValue.getValue();<br>        <span class="hljs-comment">//根据分片策略：tb_device_$-&gt;&#123;device_id%2&#125; 做精确分片</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shardingKey</span> <span class="hljs-operator">=</span> logicTableName + <span class="hljs-string">&quot;_&quot;</span> + (value % <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (!collection.contains(shardingKey)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;表:&quot;</span> + shardingKey+ <span class="hljs-string">&quot;不存在&quot;</span>);<br>        &#125;<br><span class="hljs-keyword">return</span> shardingKey;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试在之前的精确查找测试用例，发现与之前的效果相同，根据id定位到某个库的某张表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">queryDeviceByID</span><span class="hljs-params">()</span>&#123;<br>QueryWrapper&lt;TbDevice&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>queryWrapper.eq(<span class="hljs-string">&quot;device_id&quot;</span>,<span class="hljs-number">1L</span>);<br>List&lt;TbDevice&gt; deviceList =deviceMapper.selectList(queryWrapper);<br>System.out.println(deviceList);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2）Standard标准分片策略的范围分片"><a href="#2）Standard标准分片策略的范围分片" class="headerlink" title="2）Standard标准分片策略的范围分片"></a>2）Standard标准分片策略的范围分片</h4><ul><li><p>配置分库的范围分片</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.shardingsphere.sharding.default-database-strategy.standard.range-algorithm-class-name</span>=<span class="hljs-string">com.qf.my.sharding.jdbc.demo.sharding.algorithm.database.MyDatabaseStandardRangeAlgorithm</span><br></code></pre></td></tr></table></figure><p>提供范围查询算法的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.sharding.algorithm.database;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.standard.RangeShardingAlgorithm;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDatabaseStandardRangeAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RangeShardingAlgorithm</span>&lt;Long&gt; &#123;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * select * from tb_device where id between (1,10);</span><br><span class="hljs-comment"> * 由于范围查询，需要在两个库的两张表中查。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> collection</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> rangeShardingValue 提供了这次查询的条件 1,10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回要进行范围查询的库名</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Collection&lt;String&gt; <span class="hljs-title function_">doSharding</span><span class="hljs-params">(Collection&lt;String&gt; collection,RangeShardingValue&lt;Long&gt; rangeShardingValue)</span> &#123;<br> <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;ds0&quot;</span>,<span class="hljs-string">&quot;ds1&quot;</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置分表的范围分片</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.tablestrategy.standard.range-algorithm-class-name</span>=<span class="hljs-string">com.qf.my.sharding.jdbc.demo.sharding.algorithm.table.MyTableStandardRangeAlgorithm</span><br></code></pre></td></tr></table></figure><p>提供范围查询算法的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.sharding.algorithm.table;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.standard.RangeShardingAlgorithm;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTableStandardRangeAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RangeShardingAlgorithm</span>&lt;<span class="hljs-type">long</span>&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Collection&lt;String&gt; <span class="hljs-title function_">doSharding</span><span class="hljs-params">(Collection&lt;String&gt; collection,RangeShardingValue&lt;<span class="hljs-type">long</span>&gt; rangeShardingValue)</span> &#123;<br>        <span class="hljs-comment">//返回两种物理表</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">logicTableName</span> <span class="hljs-operator">=</span> rangeShardingValue.getLogicTableName();<br>        <span class="hljs-keyword">return</span> Arrays.asList(logicTableName+<span class="hljs-string">&quot;_0&quot;</span>,logicTableName+<span class="hljs-string">&quot;_1&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，再运行范围查询的测试用例，发现成功了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">queryDeviceByRange</span><span class="hljs-params">()</span>&#123;<br>QueryWrapper&lt;TbDevice&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>queryWrapper.between(<span class="hljs-string">&quot;device_id&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);<br>List&lt;TbDevice&gt; deviceList =deviceMapper.selectList(queryWrapper);<br>System.out.println(deviceList);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-Complex分片策略"><a href="#3-Complex分片策略" class="headerlink" title="3) Complex分片策略"></a>3) Complex分片策略</h4><ul><li><p>问题的出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">queryDeviceByRangeAndDeviceType</span><span class="hljs-params">()</span>&#123;<br>QueryWrapper&lt;TbDevice&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>queryWrapper.between(<span class="hljs-string">&quot;device_id&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);<br>queryWrapper.eq(<span class="hljs-string">&quot;device_type&quot;</span>, <span class="hljs-number">5</span>);<br>List&lt;TbDevice&gt; deviceList =deviceMapper.selectList(queryWrapper);<br>System.out.println(deviceList);<br>&#125;<br></code></pre></td></tr></table></figure><p>在对device_id进行范围查询的同时，需要根据device_type做精确查找，发现此时也需要查两个库的三张表，但是奇数的device_type只会在奇数库的奇数表中，此时冗余了多次不必要的查询。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">INFO <span class="hljs-number">5879</span> --- [ main] <span class="hljs-keyword">ShardingSphere-SQL </span>: Actual SQL: ds0 ::: SELECT device_id,device_type FROM tb_device_0 <br>WHERE device_id <span class="hljs-keyword">BETWEEN </span>? <span class="hljs-keyword">AND </span>? <span class="hljs-keyword">AND </span>device_type = ? ::: [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>]<br>INFO <span class="hljs-number">5879</span> --- [ main] <span class="hljs-keyword">ShardingSphere-SQL </span>: Actual SQL: ds0 ::: SELECT device_id,device_type FROM tb_device_1 <br>WHERE device_id <span class="hljs-keyword">BETWEEN </span>? <span class="hljs-keyword">AND </span>? <span class="hljs-keyword">AND </span>device_type = ? ::: [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>]<br>INFO <span class="hljs-number">5879</span> --- [ main] <span class="hljs-keyword">ShardingSphere-SQL </span>: Actual SQL: ds1 ::: SELECT device_id,device_type FROM tb_device_0 <br>WHERE device_id <span class="hljs-keyword">BETWEEN </span>? <span class="hljs-keyword">AND </span>? <span class="hljs-keyword">AND </span>device_type = ? ::: [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>]<br>INFO <span class="hljs-number">5879</span> --- [ main] <span class="hljs-keyword">ShardingSphere-SQL </span>: Actual SQL: ds1 ::: SELECT device_id,device_type FROM tb_device_1 <br>WHERE device_id <span class="hljs-keyword">BETWEEN </span>? <span class="hljs-keyword">AND </span>? <span class="hljs-keyword">AND </span>device_type = ? ::: [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>为了解决冗余的多次查找，可以使⽤complex的分片策略。</p></li><li><p>complex的分片策略</p><p>支持多个字段的分片策略。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 分库的分片策略</span><br><span class="hljs-attr">spring.shardingsphere.sharding.default-database-strategy.complex.sharding-columns</span>=<span class="hljs-string">device_id,device_type</span><br><span class="hljs-attr">spring.shardingsphere.sharding.default-database-strategy.complex.algorithm-class-name</span>=<span class="hljs-string">com.qf.my.sharding.jdbc.demo.sharding.algorithm.database.MyDatabaseComplexAlgorithm</span><br><span class="hljs-comment"># 分表的分片策略</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.table-strategy.complex.sharding-columns</span>=<span class="hljs-string">device_id,device_type</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.table-strategy.complex.algorithm-class-name</span>=<span class="hljs-string">com.qf.my.sharding.jdbc.demo.sharding.algorithm.table.MyTableComplexAlgorithm</span><br></code></pre></td></tr></table></figure><p>配置分库的算法实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.sharding.algorithm.database;<br><span class="hljs-keyword">import</span> com.google.common.collect.Range;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.complex.ComplexKeysShardingAlgorithm;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.complex.ComplexKeysShardingValue;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDatabaseComplexAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComplexKeysShardingAlgorithm</span>&lt;Integer&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Collection&lt;String&gt; <span class="hljs-title function_">doSharding</span><span class="hljs-params">(Collection&lt;String&gt; collection,ComplexKeysShardingValue&lt;Integer&gt; complexKeysShardingValue)</span> &#123;<br><span class="hljs-comment">//获得这一次查询的device_type的所有值。</span><br>Collection&lt;Integer&gt; deviceTypes =complexKeysShardingValue.getColumnNameAndShardingValuesMap().get(<span class="hljs-string">&quot;devic</span><br><span class="hljs-string">e_type&quot;</span>);<br><span class="hljs-comment">//存放指定的库</span><br>Collection&lt;String&gt; databases = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (Integer deviceType : deviceTypes) &#123;<br><span class="hljs-comment">//根据deviceType的奇偶选择哪个数据库</span><br><span class="hljs-type">String</span> <span class="hljs-variable">database</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ds&quot;</span> + (deviceType % <span class="hljs-number">2</span>);<br>databases.add(database);<br>&#125;<br><span class="hljs-keyword">return</span> databases;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置分表的算法实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.sharding.algorithm.table;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.complex.ComplexKeysShardingAlgorithm;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.complex.ComplexKeysShardingValue ;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTableComplexAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComplexKeysShardingAlgorithm</span>&lt;Integer&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Collection&lt;String&gt; <span class="hljs-title function_">doSharding</span><span class="hljs-params">(Collection&lt;String&gt; collection,ComplexKeysShardingValue&lt;Integer&gt; complexKeysShardingValue)</span> &#123;<br><span class="hljs-comment">//获得这一次查询的device_type的所有值。</span><br>Collection&lt;Integer&gt; deviceTypes =complexKeysShardingValue.getColumnNameAndShardingValuesMap().get(<span class="hljs-string">&quot;devic</span><br><span class="hljs-string">e_type&quot;</span>);<br><span class="hljs-comment">//存放指定的表</span><br>Collection&lt;String&gt; tables = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (Integer deviceType : deviceTypes) &#123;<br><span class="hljs-comment">//根据deviceType的奇偶选择哪个数据库</span><br><span class="hljs-type">String</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span>complexKeysShardingValue.getLogicTableName()+ <span class="hljs-string">&quot;_&quot;</span> + (deviceType % <span class="hljs-number">2</span>);<br>tables.add(tableName);<br>&#125;<br><span class="hljs-keyword">return</span> tables;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-Hint强制路由策略"><a href="#4-Hint强制路由策略" class="headerlink" title="4) Hint强制路由策略"></a>4) Hint强制路由策略</h4><p>hint可以不根据sql语句特性，强制路由到某个库的某个表中。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#hint</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.table-strategy.hint.algorithm-class-name</span>=<span class="hljs-string">com.qf.my.sharding.jdbc.demo.sharding.algorithm.table.MyTableHintAlgorithm</span><br></code></pre></td></tr></table></figure><p>配置hint算法的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.sharding.algorithm.table;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.hint.HintShardingAlgorithm;<br><span class="hljs-keyword">import</span> org.apache.shardingsphere.api.sharding.hint.HintShardingValue;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTableHintAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HintShardingAlgorithm</span>&lt;<span class="hljs-type">long</span>&gt; &#123;<br>    <br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Collection&lt;String&gt; <span class="hljs-title function_">doSharding</span><span class="hljs-params">(Collection&lt;String&gt; collection,HintShardingValue&lt;<span class="hljs-type">long</span>&gt; hintShardingValue)</span> &#123;<br><span class="hljs-comment">//根据指定参数强制路由</span><br><span class="hljs-type">String</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> hintShardingValue.getLogicTableName() + <span class="hljs-string">&quot;_&quot;</span>+ hintShardingValue.getValues().toArray()[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (!collection.contains(tableName)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;表：&quot;</span> + tableName+ <span class="hljs-string">&quot;，不存在&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> Arrays.asList(tableName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写单元测试。这次查询都会查询两个数据库的tb_device_0这张表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">queryByHint</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">HintManager</span> <span class="hljs-variable">hintManager</span> <span class="hljs-operator">=</span> HintManager.getInstance();<br><span class="hljs-comment">//指定强制路由的表</span><br>hintManager.addTableShardingValue(<span class="hljs-string">&quot;tb_device&quot;</span>,<span class="hljs-number">0</span>);<br>List&lt;TbDevice&gt; deviceList = deviceMapper.selectList(<span class="hljs-literal">null</span>);<br>System.out.println(deviceList);<br>hintManager.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-绑定表"><a href="#4-绑定表" class="headerlink" title="4.绑定表"></a>4.绑定表</h3><p>先来模拟笛卡尔积的出现。</p><ul><li><p>创建 <code>tb_device_info</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_device_info_0` (<br> `id` bigint NOT NULL,<br> `device_id` bigint DEFAULT NULL,<br> `device_intro` varchar(255) COLLATE utf8mb4_general_ci DEFAULT NULL,<br> PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;<br></code></pre></td></tr></table></figure></li><li><p>配置 tb_device 和 tb_device_info 表的分片策略。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># tb_device表的分片策略</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.actual-data-nodes</span>=<span class="hljs-string">ds$-&gt;&#123;0..1&#125;.tb_device_$-&gt;&#123;0..1&#125;</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.table-strategy.inline.sharding-column</span>=<span class="hljs-string">device_id</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device.table-strategy.inline.algorithm-expression</span>=<span class="hljs-string">tb_device_$-&gt;&#123;device_id%2&#125;</span><br><span class="hljs-comment"># # tb_device_info表的分片策略</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device_info.actual-data-nodes</span>=<span class="hljs-string">ds$-&gt;&#123;0..1&#125;.tb_device_info_$-&gt;&#123;0..1&#125;</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device_info.table-strategy.inline.sharding-column</span>=<span class="hljs-string">device_id</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_device_info.table-strategy.inline.algorithm-expression</span>=<span class="hljs-string">tb_device_info_$-&gt;&#123;device_id%2&#125;</span><br></code></pre></td></tr></table></figure><p>两张表的分片键都是device_id。</p></li><li><p>编写测试用例，插入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsertType</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-type">TbDevice</span> <span class="hljs-variable">device</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TbDevice</span>();<br>device.setDeviceId((<span class="hljs-type">long</span>) i);<br>device.setDeviceType(i);<br>deviceMapper.insert(device);<br><span class="hljs-type">TbDeviceInfo</span> <span class="hljs-variable">deviceInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TbDeviceInfo</span>();<br>deviceInfo.setDeviceId((<span class="hljs-type">long</span>) i);<br>deviceInfo.setDeviceIntro(<span class="hljs-string">&quot;&quot;</span>+i);<br>deviceInfoMapper.insert(deviceInfo);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>join查询时出现笛卡尔积</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.my.sharding.jdbc.demo.mapper;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<br><span class="hljs-keyword">import</span> com.qf.my.sharding.jdbc.demo.entity.TbDeviceInfo;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeviceInfoMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;TbDeviceInfo&gt; &#123;<br> <span class="hljs-meta">@Select(&quot;select a.id,a.device_id,a.device_intro,b.device_type from tb_device_info a left join tb_device b on a.device_id = b.device_id &quot;)</span><br> <span class="hljs-keyword">public</span> List&lt;TbDeviceInfo&gt; <span class="hljs-title function_">queryDeviceInfo</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>出现笛卡尔积的查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryDeviceInfo</span><span class="hljs-params">()</span>&#123;<br>List&lt;TbDeviceInfo&gt; deviceInfos =deviceInfoMapper.queryDeviceInfo();<br>deviceInfos.forEach( deviceInfo -&gt;System.out.println(deviceInfo));<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs routeros">2022-03-28 21:09:17.413 <span class="hljs-built_in">INFO</span> 14006 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds0 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_1 a left join tb_device_0 b on a.device_id = b.device_id<br>2022-03-28 21:09:17.413 <span class="hljs-built_in">INFO</span> 14006 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds0 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_1 a left join tb_device_1 b on a.device_id = b.device_id<br>2022-03-28 21:09:17.414 <span class="hljs-built_in">INFO</span> 14006 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds0 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_0 a left join tb_device_0 b on a.device_id = b.device_id<br>2022-03-28 21:09:17.414 <span class="hljs-built_in">INFO</span> 14006 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds0 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_0 a left join tb_device_1 b on a.device_id = b.device_id<br>2022-03-28 21:09:17.414 <span class="hljs-built_in">INFO</span> 14006 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds1 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_1 a left join tb_device_0 b on a.device_id = b.device_id<br>2022-03-28 21:09:17.414 <span class="hljs-built_in">INFO</span> 14006 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds1 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_1 a left join tb_device_1 b on a.device_id = b.device_id<br>2022-03-28 21:09:17.414 <span class="hljs-built_in">INFO</span> 14006 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds1 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_0 a left join tb_device_0 b on a.device_id = b.device_id<br>2022-03-28 21:09:17.414 <span class="hljs-built_in">INFO</span> 14006 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds1 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_0 a left join tb_device_1 b on a.device_id = b.device_id<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423776753684482, <span class="hljs-attribute">deviceId</span>=0, <span class="hljs-attribute">deviceIntro</span>=0)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423776938233858, <span class="hljs-attribute">deviceId</span>=2, <span class="hljs-attribute">deviceIntro</span>=2)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777097617410, <span class="hljs-attribute">deviceId</span>=4, <span class="hljs-attribute">deviceIntro</span>=4)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777210863618, <span class="hljs-attribute">deviceId</span>=6, <span class="hljs-attribute">deviceIntro</span>=6)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777328304130, <span class="hljs-attribute">deviceId</span>=8, <span class="hljs-attribute">deviceIntro</span>=8)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423776753684482, <span class="hljs-attribute">deviceId</span>=0, <span class="hljs-attribute">deviceIntro</span>=0)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423776938233858, <span class="hljs-attribute">deviceId</span>=2, <span class="hljs-attribute">deviceIntro</span>=2)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777097617410, <span class="hljs-attribute">deviceId</span>=4, <span class="hljs-attribute">deviceIntro</span>=4)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777210863618, <span class="hljs-attribute">deviceId</span>=6, <span class="hljs-attribute">deviceIntro</span>=6)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777328304130, <span class="hljs-attribute">deviceId</span>=8, <span class="hljs-attribute">deviceIntro</span>=8)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423776858542081, <span class="hljs-attribute">deviceId</span>=1, <span class="hljs-attribute">deviceIntro</span>=1)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777030508546, <span class="hljs-attribute">deviceId</span>=3, <span class="hljs-attribute">deviceIntro</span>=3)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777152143362, <span class="hljs-attribute">deviceId</span>=5, <span class="hljs-attribute">deviceIntro</span>=5)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777273778177, <span class="hljs-attribute">deviceId</span>=7, <span class="hljs-attribute">deviceIntro</span>=7)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777378635778, <span class="hljs-attribute">deviceId</span>=9, <span class="hljs-attribute">deviceIntro</span>=9)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423776858542081, <span class="hljs-attribute">deviceId</span>=1, <span class="hljs-attribute">deviceIntro</span>=1)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777030508546, <span class="hljs-attribute">deviceId</span>=3, <span class="hljs-attribute">deviceIntro</span>=3)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777152143362, <span class="hljs-attribute">deviceId</span>=5, <span class="hljs-attribute">deviceIntro</span>=5)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777273778177, <span class="hljs-attribute">deviceId</span>=7, <span class="hljs-attribute">deviceIntro</span>=7)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777378635778, <span class="hljs-attribute">deviceId</span>=9, <span class="hljs-attribute">deviceIntro</span>=9)<br></code></pre></td></tr></table></figure></li><li><p>配置绑定表</p><p>配置绑定表：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.shardingsphere.sharding.binding-tables[0]</span>=<span class="hljs-string">tb_device,tb_device_info</span><br></code></pre></td></tr></table></figure><p>再次查询，不再出现笛卡尔积：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros">2022-03-28 21:10:48.549 <span class="hljs-built_in">INFO</span> 14661 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds0 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_0 a left join tb_device_0 b on a.device_id = b.device_id<br>2022-03-28 21:10:48.550 <span class="hljs-built_in">INFO</span> 14661 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds0 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_1 a left join tb_device_1 b on a.device_id = b.device_id<br>2022-03-28 21:10:48.550 <span class="hljs-built_in">INFO</span> 14661 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds1 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_0 a left join tb_device_0 b on a.device_id = b.device_id<br>2022-03-28 21:10:48.550 <span class="hljs-built_in">INFO</span> 14661 --- [ main]<br>ShardingSphere-SQL : Actual SQL: ds1 ::: select a.id,a.device_id,a.device_intro,b.device_type <span class="hljs-keyword">from</span> tb_device_info_1 a left join tb_device_1 b on a.device_id = b.device_id<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423776753684482, <span class="hljs-attribute">deviceId</span>=0, <span class="hljs-attribute">deviceIntro</span>=0)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423776938233858, <span class="hljs-attribute">deviceId</span>=2, <span class="hljs-attribute">deviceIntro</span>=2)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777097617410, <span class="hljs-attribute">deviceId</span>=4, <span class="hljs-attribute">deviceIntro</span>=4)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777210863618, <span class="hljs-attribute">deviceId</span>=6, <span class="hljs-attribute">deviceIntro</span>=6)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777328304130, <span class="hljs-attribute">deviceId</span>=8, <span class="hljs-attribute">deviceIntro</span>=8)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423776858542081, <span class="hljs-attribute">deviceId</span>=1, <span class="hljs-attribute">deviceIntro</span>=1)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777030508546, <span class="hljs-attribute">deviceId</span>=3, <span class="hljs-attribute">deviceIntro</span>=3)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777152143362, <span class="hljs-attribute">deviceId</span>=5, <span class="hljs-attribute">deviceIntro</span>=5)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777273778177, <span class="hljs-attribute">deviceId</span>=7, <span class="hljs-attribute">deviceIntro</span>=7)<br>TbDeviceInfo(<span class="hljs-attribute">id</span>=1508423777378635778, <span class="hljs-attribute">deviceId</span>=9, <span class="hljs-attribute">deviceIntro</span>=9)<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-广播表"><a href="#5-广播表" class="headerlink" title="5.广播表"></a>5.广播表</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518004837728.png"></p><p>现在有这么一个场景，device_type列对应的tb_device_type表中的数据，不应该被分表，两个库中都应该有全量的该表的数据。</p><ul><li><p>在两个数据库中创建 tb_device_type 表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_device_type` (<br> `type_id` int NOT NULL AUTO_INCREMENT,<br> `type_name` varchar(255) COLLATE utf8mb4_general_ci DEFAULT NULL,<br> PRIMARY KEY (`type_id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;<br></code></pre></td></tr></table></figure></li><li><p>配置⼴播表</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#⼴播表配置</span><br><span class="hljs-attr">spring.shardingsphere.sharding.broadcast-tables</span>=<span class="hljs-string">tb_device_type</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.t_dict.key-generator.column</span>=<span class="hljs-string">type_id</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.t_dict.key-generator.type</span>=<span class="hljs-string">SNOWFLAKE</span><br></code></pre></td></tr></table></figure></li><li><p>编写测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddDeviceType</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">TbDeviceType</span> <span class="hljs-variable">deviceType1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TbDeviceType</span>();<br>deviceType1.setTypeId(<span class="hljs-number">1</span>);<br>deviceType1.setTypeName(<span class="hljs-string">&quot;人脸考勤&quot;</span>);<br>deviceTypeMapper.insert(deviceType1);<br><span class="hljs-type">TbDeviceType</span> <span class="hljs-variable">deviceType2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TbDeviceType</span>();<br>deviceType2.setTypeId(<span class="hljs-number">2</span>);<br>deviceType2.setTypeName(<span class="hljs-string">&quot;人脸通道&quot;</span>);<br>deviceTypeMapper.insert(deviceType2);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="五、实现读写分离"><a href="#五、实现读写分离" class="headerlink" title="五、实现读写分离"></a>五、实现读写分离</h2><h3 id="1-搭建主从同步数据库"><a href="#1-搭建主从同步数据库" class="headerlink" title="1.搭建主从同步数据库"></a>1.搭建主从同步数据库</h3><ul><li>主从同步原理</li></ul><p>Master将数据写入到binlog⽇志中。Slave读取主节点的Binlog数据到本地的relaylog⽇志⽂件中。此时，Slave持续不断的与Master同步，且数据存在于relaylog中，而并非落在数据库。于是Slave开启一条线程，专门讲relaylog中的数据写入到数据库中。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518005118415.png"></p><ul><li><p>准备Master主库</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.25</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-string">--character-set-server=utf8mb4</span><br>      <span class="hljs-string">--collation-server=utf8mb4_general_ci</span><br>      <span class="hljs-string">--explicit_defaults_for_timestamp=true</span><br>      <span class="hljs-string">--lower_case_table_names=1</span><br>      <span class="hljs-string">--max_allowed_packet=128M</span><br>      <span class="hljs-string">--server-id=47</span><br>      <span class="hljs-string">--log_bin=master-bin</span><br>      <span class="hljs-string">--log_bin-index=master-bin.index</span><br>      <span class="hljs-string">--skip-name-resolve</span><br>      <span class="hljs-string">--sql-mode=&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql-data:/var/lib/mysql</span><br>      <br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysql-data:</span><br></code></pre></td></tr></table></figure><p>注意其中的配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">服务id：<span class="hljs-attribute">server-id</span>=47<br>开启binlog：<span class="hljs-attribute">log_bin</span>=master-bin<br>binlog索引：<span class="hljs-attribute">log_bin-index</span>=master-bin.index<br></code></pre></td></tr></table></figure><p>通过 <code>show master status</code> 命令查看并记录⽂件名和偏移量。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518005437414.png"></p></li><li><p>准备Slave从库：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.25</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-string">--character-set-server=utf8mb4</span><br>      <span class="hljs-string">--collation-server=utf8mb4_general_ci</span><br>      <span class="hljs-string">--explicit_defaults_for_timestamp=true</span><br>      <span class="hljs-string">--lower_case_table_names=1</span><br>      <span class="hljs-string">--max_allowed_packet=128M</span><br>      <span class="hljs-string">--server-id=48</span><br>      <span class="hljs-string">--relay-log-index=slave-relay-bin.index</span><br>      <span class="hljs-string">--relay-log=slave-relay-bin</span><br>      <span class="hljs-string">--log-bin=mysql-bin</span><br>      <span class="hljs-string">--log-slave-updates=1</span><br>      <span class="hljs-string">--sql-mode=&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql-data:/var/lib/mysql</span><br>      <br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysql-data:</span><br></code></pre></td></tr></table></figure><p>注意其中的关键配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">服务id：<span class="hljs-attribute">server-id</span>=48<br>开启中继日志：<span class="hljs-attribute">relay-log-index</span>=slave-relay-bin.index<br>开启中继日志：<span class="hljs-attribute">relay-log</span>=slave-relay-bin<br></code></pre></td></tr></table></figure><p>启动从库后进入到从库，并依次执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#登录从服务<br>mysql -u root -p;<br>#设置同步主节点：<br>CHANGE MASTER TO<br>MASTER_HOST=&#x27;172.16.253.31&#x27;,<br>MASTER_PORT=3306,<br>MASTER_USER=&#x27;root&#x27;,<br>MASTER_PASSWORD=&#x27;123456&#x27;,<br>MASTER_LOG_FILE=&#x27;master-bin.000003&#x27;,<br>MASTER_LOG_POS=154;<br>#开启slave<br>start slave;<br></code></pre></td></tr></table></figure><p>至此，主从同步集群搭建完成。</p><p>在主库中创建 db_device 数据库，并在库中创建表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_user` (<br> `id` bigint(20) NOT NULL AUTO_INCREMENT,<br> `name` varchar(255) DEFAULT NULL,<br> PRIMARY KEY (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-使⽤sharding-jdbc实现读写分离"><a href="#2-使⽤sharding-jdbc实现读写分离" class="headerlink" title="2.使⽤sharding-jdbc实现读写分离"></a>2.使⽤sharding-jdbc实现读写分离</h3><ul><li><p>编写配置⽂件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 配置真实数据源</span><br><span class="hljs-attr">spring.shardingsphere.datasource.names</span>=<span class="hljs-string">m0,s0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置主数据源</span><br><span class="hljs-attr">spring.shardingsphere.datasource.m0.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-attr">spring.shardingsphere.datasource.m0.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.shardingsphere.datasource.m0.url</span>=<span class="hljs-string">jdbc:mysql://172.16.253.73:3306/db_device?serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">spring.shardingsphere.datasource.m0.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.shardingsphere.datasource.m0.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置从数据源</span><br><span class="hljs-attr">spring.shardingsphere.datasource.s0.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-attr">spring.shardingsphere.datasource.s0.driver-classname</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.shardingsphere.datasource.s0.url</span>=<span class="hljs-string">jdbc:mysql://172.16.253.74:3306/db_device?serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">spring.shardingsphere.datasource.s0.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.shardingsphere.datasource.s0.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 分配读写规则</span><br><span class="hljs-attr">spring.shardingsphere.sharding.master-slave-rules.ds0.master-data-source-name</span>=<span class="hljs-string">m0</span><br><span class="hljs-attr">spring.shardingsphere.sharding.master-slave-rules.ds0.slave-data-source-names[0]</span>=<span class="hljs-string">s0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 确定实际表</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.tb_user.actual-data-nodes</span>=<span class="hljs-string">ds0.tb_user</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 确定主键生成策略</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.t_dict.key-generator.column</span>=<span class="hljs-string">id</span><br><span class="hljs-attr">spring.shardingsphere.sharding.tables.t_dict.key-generator.type</span>=<span class="hljs-string">SNOWFLAKE</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 开启显示sql语句</span><br><span class="hljs-attr">spring.shardingsphere.props.sql.show</span> = <span class="hljs-string">true</span><br></code></pre></td></tr></table></figure></li><li><p>测试写数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsertUser</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>         <span class="hljs-type">TbUser</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TbUser</span>();<br>         user.setName(<span class="hljs-string">&quot;&quot;</span>+i);<br>         userMapper.insert(user);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，所有的数据只会往主库中写，然后再同步到从库。</p></li><li><p>测试读数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUser</span><span class="hljs-params">()</span>&#123;<br>List&lt;TbUser&gt; tbUsers = userMapper.selectList(<span class="hljs-literal">null</span>);<br>tbUsers.forEach( tbUser -&gt; System.out.println(tbUser));<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，所有的数据都读自于从库。</p></li></ul><h2 id="六、实现原理-连接模式"><a href="#六、实现原理-连接模式" class="headerlink" title="六、实现原理-连接模式"></a>六、实现原理-连接模式</h2><p>ShardingSphere 采用一套自动化的执行引擎，负责将路由和改写完成之后的真实 SQL 安全且高效发送到底层数据源执行。 它不是简单地将 SQL 通过 JDBC 直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题。 执行引擎的目标是自动化的平衡资源控制与执行效率。</p><h3 id="1-连接模式"><a href="#1-连接模式" class="headerlink" title="1.连接模式"></a>1.连接模式</h3><p>从资源控制的⻆度看，业务方访问数据库的连接数量应当有所限制。它能够有效地防⽌某一业务操作过多的占用资源，从而将数据库连接的资源耗尽，以致于影响其他业务的正常访问。 特别是在一个数据库实例中存在较多分表的情况下，一条不包含分片键的逻辑 SQL 将产生落在同库不同表的大量真实 SQL ，如果每条真实SQL都占用一个独立的连接，那么一次查询无疑将会占用过多的资源。</p><p>从执行效率的⻆度看，为每个分片查询维持一个独立的数据库连接，可以更加有效的利用多线程来提升执行效率。 为每个数据库连接开启独立的线程，可以将 I&#x2F;O 所产生的消耗并行处理。为每个分片维持一个独立的数据库连接，还能够避免过早的将查询结果数据加载至内存。 独立的数据库连接，能够持有查询结果集游标位置的引用，在需要获取相应数据时移动游标即可。</p><p>以结果集游标下移进行结果归并的方式，称之为流式归并，它无需将结果数据全数加载至内存，可以有效的节省内存资源，进而减少垃圾回收的频次。 当无法保证每个分片查询持有一个独立数据库连接时，则需要在复用该数据库连接获取下一张分表的查询结果集之前，将当前的查询结果集全数加载至内存。 因此，即使可以采用流式归并，在此场景下也将退化为内存归并。</p><p>一方⾯是对数据库连接资源的控制保护，一方⾯是采用更优的归并模式达到对中间件内存资源的节省，如何处理好两者之间的关系，是 ShardingSphere 执行引擎需要解决的问题。 具体来说，如果一条 SQL 在经过 ShardingSphere 的分片后，需要操作某数据库实例下的 200张表。 那么，是选择创建 200 个连接并行执行，还是选择创建一个连接串行执行呢？效率与资源控制又应该如何抉择呢？</p><p>针对上述场景，ShardingSphere 提供了一种解决思路。 它提出了连接模式（ConnectionMode）的概念，将其划分为内存限制模式（MEMORY_STRICTLY）和连接限制模式（CONNECTION_STRICTLY）这两种类型。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518005933107.png"></p><h4 id="1）内存限制模式"><a href="#1）内存限制模式" class="headerlink" title="1）内存限制模式"></a>1）内存限制模式</h4><p>使用此模式的前提是，ShardingSphere 对一次操作所耗费的数据库连接数量不做限制。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，则对每张表创建一个新的数据库连接，并通过多线程的方式并发处理，以达成执行效率最大化。 并且在 SQL 满⾜条件情况下，优先选择流式归并，以防⽌出现内存溢出或避免频繁垃圾回收情况。</p><h4 id="2）连接限制模式"><a href="#2）连接限制模式" class="headerlink" title="2）连接限制模式"></a>2）连接限制模式</h4><p>使用此模式的前提是，ShardingSphere 严格控制对一次操作所耗费的数据库连接数量。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，那么只会创建唯一的数据库连接，并对其 200 张表串行处理。 如果一次操作中的分片散落在不同的数据库，仍然采用多线程处理对不同库的操作，但每个库的每次操作仍然只创建一个唯一的数据库连接。 这样即可以防⽌对一次请求对数据库连接占用过多所带来的问题。该模式始终选择内存归并。</p><p>内存限制模式适用于 OLAP 操作，可以通过放宽对数据库连接的限制提升系统吞吐量； 连接限制模式适用于 OLTP 操作，OLTP 通常带有分片键，会路由到单一的分片，因此严格控制数据库连接，以保证在线系统数据库资源能够被更多的应用所使用，是明智的选择。</p><h3 id="2-自动化执行引擎"><a href="#2-自动化执行引擎" class="headerlink" title="2.自动化执行引擎"></a>2.自动化执行引擎</h3><p>ShardingSphere 最初将使用何种模式的决定权交由用户配置，让开发者依据自己业务的实际场景需求选择使用内存限制模式或连接限制模式。</p><p>这种解决方案将两难的选择的决定权交由用户，使得用户必须要了解这两种模式的利弊，并依据业务场景需求进行选择。 这无疑增加了用户对 ShardingSphere 的学习和使用的成本，并非最优方案。</p><p>这种一分为⼆的处理方案，将两种模式的切换交由静态的初始化配置，是缺乏灵活应对能力的。在实际的使用场景中，⾯对不同 SQL 以及占位符参数，每次的路由结果是不同的。 这就意味着某些操作可能需要使用内存归并，而某些操作则可能选择流式归并更优，具体采用哪种方式不应该由用户在 ShardingSphere 启动之前配置好，而是应该根据 SQL 和占位符参数的场景，来动态的决定连接模式。</p><p>为了降低用户的使用成本以及连接模式动态化这两个问题，ShardingSphere 提炼出自动化执行引擎的思路，在其内部消化了连接模式概念。 用户无需了解所谓的内存限制模式和连接限制模式是什么，而是交由执行引擎根据当前场景自动选择最优的执行方案。</p><p>自动化执行引擎将连接模式的选择粒度细化至每一次 SQL 的操作。 针对每次 SQL 请求，自动化执行引擎都将根据其路由结果，进行实时的演算和权衡，并自主地采用恰当的连接模式执行，以达到资源控制和效率的最优平衡。 针对自动化的执行引擎，用户只需配置maxConnectionSizePerQuery 即可，该参数表示一次查询时每个数据库所允许使用的最大连接数。</p><p>执行引擎分为准备和执行两个阶段。</p><h3 id="3-准备阶段"><a href="#3-准备阶段" class="headerlink" title="3.准备阶段"></a>3.准备阶段</h3><p>顾名思义，此阶段用于准备执行的数据。它分为结果集分组和执行单元创建两个步骤。</p><p>结果集分组是实现内化连接模式概念的关键。执行引擎根据maxConnectionSizePerQuery配置项，结合当前路由结果，选择恰当的连接模式。 具体步骤如下：</p><ul><li><p>将 SQL 的路由结果按照数据源的名称进行分组。</p></li><li><p>通过下图的公式，可以获得每个数据库实例在 <code>maxConnectionSizePerQuery</code> 的允许范围内，每个连接需要执行的 SQL 路由结果组，并计算出本次请求的最优连接模式。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518010213578.png" alt="image-20230518010213578"></p><p>在 maxConnectionSizePerQuery 允许的范围内，当一个连接需要执行的请求数量大于 1时，意味着当前的数据库连接无法持有相应的数据结果集，则必须采用内存归并； 反之，当一个连接需要执行的请求数量等于 1 时，意味着当前的数据库连接可以持有相应的数据结果集，则可以采用流式归并。</p><p>每一次的连接模式的选择，是针对每一个物理数据库的。也就是说，在同一次查询中，如果路由至一个以上的数据库，每个数据库的连接模式不一定一样，它们可能是混合存在的形态。</p></li></ul><h2 id="七、实现原理-归并引擎"><a href="#七、实现原理-归并引擎" class="headerlink" title="七、实现原理-归并引擎"></a>七、实现原理-归并引擎</h2><p>将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。</p><p>ShardingSphere 支持的结果归并从功能上分为遍历、排序、分组、分页和聚合 5 种类型，它们是组合而非互斥的关系。 从结构划分，可分为流式归并、内存归并和装饰者归并。流式归并和内存归并是互斥的，装饰者归并可以在流式归并和内存归并之上做进一步的处理。</p><p>由于从数据库中返回的结果集是逐条返回的，并不需要将所有的数据一次性加载至内存中，因此，在进行结果归并时，沿用数据库返回结果集的方式进行归并，能够极大减少内存的消耗，是归并方式的优先选择。</p><p>流式归并是指每一次从结果集中获取到的数据，都能够通过逐条获取的方式返回正确的单条数据，它与数据库原生的返回结果集的方式最为契合。遍历、排序以及流式分组都属于流式归并的一种。</p><p>内存归并则是需要将结果集的所有数据都遍历并存储在内存中，再通过统一的分组、排序以及聚合等计算之后，再将其封装成为逐条访问的数据结果集返回。</p><p>装饰者归并是对所有的结果集归并进行统一的功能增强，目前装饰者归并有分页归并和聚合归并这 2 种类型。</p><h3 id="1-遍历归并"><a href="#1-遍历归并" class="headerlink" title="1.遍历归并"></a>1.遍历归并</h3><p>它是最为简单的归并方式。 只需将多个数据结果集合并为一个单向链表即可。在遍历完成链表中当前数据结果集之后，将链表元素后移一位，继续遍历下一个数据结果集即可。</p><h3 id="2-排序归并"><a href="#2-排序归并" class="headerlink" title="2.排序归并"></a>2.排序归并</h3><p>由于在 SQL 中存在 <code>ORDER BY</code> 语句，因此每个数据结果集自身是有序的，因此只需要将数据结果集当前游标指向的数据值进行排序即可。 这相当于对多个有序的数组进行排序，归并排序是最适合此场景的排序算法。</p><p>ShardingSphere 在对排序的查询进行归并时，将每个结果集的当前数据值进行比较（通过实现 Java 的 Comparable 接口完成），并将其放入优先级队列。 每次获取下一条数据时，只需将队列顶端结果集的游标下移，并根据新游标重新进入优先级排序队列找到自己的位置即可。</p><p>通过一个例子来说明 ShardingSphere 的排序归并，下图是一个通过分数进行排序的示例图。 图中展示了 3 张表返回的数据结果集，每个数据结果集已经根据分数排序完毕，但是 3个数据结果集之间是无序的。 将 3 个数据结果集的当前游标指向的数据值进行排序，并放入优先级队列，t_score_0 的第一个数据值最大，t_score_2 的第一个数据值次之，t_score_1的第一个数据值最小，因此优先级队列根据 t_score_0，t_score_2 和 t_score_1 的方式排序队列。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518010426647.png"></p><p>下图则展现了进行 next 调用的时候，排序归并是如何进行的。 通过图中我们可以看到，当进行第一次 next 调用时，排在队列⾸位的 t_score_0 将会被弹出队列，并且将当前游标指向的数据值（也就是 100）返回至查询客户端，并且将游标下移一位之后，重新放入优先级队列。 而优先级队列也会根据 t_score_0 的当前数据结果集指向游标的数据值（这⾥是 90）进行排序，根据当前数值，t_score_0 排列在队列的最后一位。 之前队列中排名第⼆的t_score_2 的数据结果集则自动排在了队列⾸位。</p><p>在进行第⼆次 next 时，只需要将目前排列在队列⾸位的 t_score_2 弹出队列，并且将其数据结果集游标指向的值返回至客户端，并下移游标，继续加入队列排队，以此类推。 当一个结果集中已经没有数据了，则无需再次加入队列。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518010459607.png"></p><p>可以看到，对于每个数据结果集中的数据有序，而多数据结果集整体无序的情况下，ShardingSphere 无需将所有的数据都加载至内存即可排序。 它使用的是流式归并的方式，每次 next 仅获取唯一正确的一条数据，极大的节省了内存的消耗。</p><p>从另一个⻆度来说，ShardingSphere 的排序归并，是在维护数据结果集的纵轴和横轴这两个维度的有序性。 纵轴是指每个数据结果集本身，它是天然有序的，它通过包含 ORDER BY 的SQL 所获取。 横轴是指每个数据结果集当前游标所指向的值，它需要通过优先级队列来维护其正确顺序。 每一次数据结果集当前游标的下移，都需要将该数据结果集重新放入优先级队列排序，而只有排列在队列⾸位的数据结果集才可能发生游标下移的操作。</p><h3 id="3-分组归并"><a href="#3-分组归并" class="headerlink" title="3.分组归并"></a>3.分组归并</h3><p>分组归并的情况最为复杂，它分为流式分组归并和内存分组归并。 流式分组归并要求 SQL 的排序项与分组项的字段以及排序类型（ASC 或 DESC）必须保持一致，否则只能通过内存归并才能保证其数据的正确性。</p><p>举例说明，假设根据科目分片，表结构中包含考生的姓名（为了简单起见，不考虑重名的情况）和分数。通过 SQL 获取每位考生的总分，可通过如下 SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name, SUM(score) FROM t_score GROUP BY name ORDER BY name;<br></code></pre></td></tr></table></figure><p>在分组项与排序项完全一致的情况下，取得的数据是连续的，分组所需的数据全数存在于各个数据结果集的当前游标所指向的数据值，因此可以采用流式归并。如下图所示。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518010609103.png"></p><p>进行归并时，逻辑与排序归并类似。 下图展现了进行 next 调用的时候，流式分组归并是如何进行的。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518010634421.png"></p><p>通过图中我们可以看到，当进行第一次 next 调用时，排在队列⾸位的 t_score_java 将会被弹出队列，并且将分组值同为 “Jerry” 的其他结果集中的数据一同弹出队列。 在获取了所有的姓名为 “Jerry” 的同学的分数之后，进行累加操作，那么，在第一次 next 调用结束后，取出的结果集是 “Jerry” 的分数总和。 与此同时，所有的数据结果集中的游标都将下移至数据值“Jerry” 的下一个不同的数据值，并且根据数据结果集当前游标指向的值进行重排序。 因此，包含名字顺着第⼆位的 “John” 的相关数据结果集则排在的队列的前列。</p><p>流式分组归并与排序归并的区别仅仅在于两点：</p><ul><li>它会一次性的将多个数据结果集中的分组项相同的数据全数取出。</li><li>它需要根据聚合函数的类型进行聚合计算。</li></ul><p>对于分组项与排序项不一致的情况，由于需要获取分组的相关的数据值并非连续的，因此无法使用流式归并，需要将所有的结果集数据加载至内存中进行分组和聚合。 例如，若通过以下 SQL 获取每位考生的总分并按照分数从高至低排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name, SUM(score) FROM t_score GROUP BY name ORDER BY score DESC;<br></code></pre></td></tr></table></figure><p>那么各个数据结果集中取出的数据与排序归并那张图的上半部分的表结构的原始数据一致，是无法进行流式归并的。</p><p>当 SQL 中只包含分组语句时，根据不同数据库的实现，其排序的顺序不一定与分组顺序一致。 但由于排序语句的缺失，则表示此 SQL 并不在意排序顺序。 因此，ShardingSphere 通过 SQL 优化的改写，自动增加与分组项一致的排序项，使其能够从消耗内存的内存分组归并方式转化为流式分组归并方案。</p><h3 id="4-聚合归并"><a href="#4-聚合归并" class="headerlink" title="4.聚合归并"></a>4.聚合归并</h3><p>无论是流式分组归并还是内存分组归并，对聚合函数的处理都是一致的。 除了分组的 SQL 之外，不进行分组的 SQL 也可以使用聚合函数。 因此，聚合归并是在之前介绍的归并类的之上追加的归并能力，即装饰者模式。聚合函数可以归类为比较、累加和求平均值这 3 种类型。</p><p>比较类型的聚合函数是指 <code>MAX</code> 和 <code>MIN</code> 。它们需要对每一个同组的结果集数据进行比较，并且直接返回其最大或最小值即可。</p><p>累加类型的聚合函数是指 <code>SUM</code> 和 <code>COUNT</code> 。它们需要将每一个同组的结果集数据进行累加。</p><p>求平均值的聚合函数只有 <code>AVG</code> 。它必须通过 SQL 改写的 <code>SUM</code> 和 <code>COUNT</code> 进行计算，相关内容已在 SQL 改写的内容中涵盖，不再赘述。</p><h3 id="5-分页归并"><a href="#5-分页归并" class="headerlink" title="5.分页归并"></a>5.分页归并</h3><p>上⽂所述的所有归并类型都可能进行分页。 分页也是追加在其他归并类型之上的装饰器，ShardingSphere 通过装饰者模式来增加对数据结果集进行分页的能力。 分页归并负责将无需获取的数据过滤掉。</p><p>ShardingSphere 的分页功能比较容易让使用者误解，用户通常认为分页归并会占用大量内存。 在分布式的场景中，将 <code>LIMIT 10000000, 10</code> 改写为 <code>LIMIT 0, 10000010</code> ，才能保证其数据的正确性。 用户非常容易产生 ShardingSphere 会将大量无意义的数据加载至内存中，造成内存溢出⻛险的错觉。 其实，通过流式归并的原理可知，会将数据全部加载到内存中的只有内存分组归并这一种情况。 而通常来说，进行 OLAP 的分组 SQL，不会产生大量的结果数据，它更多的用于大量的计算，以及少量结果产出的场景。 除了内存分组归并这种情况之外，其他情况都通过流式归并获取数据结果集，因此 ShardingSphere 会通过结果集的next 方法将无需取出的数据全部跳过，并不会将其存入内存。</p><p>但同时需要注意的是，由于排序的需要，大量的数据仍然需要传输到 ShardingSphere 的内存空间。 因此，采用 LIMIT 这种方式分页，并非最佳实践。 由于 LIMIT 并不能通过索引查询数据，因此如果可以保证 ID 的连续性，通过 ID 进行分页是比较好的解决方案，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_order WHERE id &gt; 100000 AND id &lt;= 100010 ORDER BY id;<br></code></pre></td></tr></table></figure><p>或通过记录上次查询结果的最后一条记录的 ID 进行下一页的查询，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_order WHERE id &gt; 10000000 LIMIT 10;<br></code></pre></td></tr></table></figure><p>归并引擎的整体结构划分如下图。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230518010917074.png"></p><p><strong>文献来源：</strong></p><p><a href="https://www.bilibili.com/video/BV1CL4y157ie">Sharding-JDBC+Mycat，从原理到配置</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>分库分表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分库分表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引篇</title>
    <link href="/2022/06/08/MySQL%E7%B4%A2%E5%BC%95%E7%AF%87/"/>
    <url>/2022/06/08/MySQL%E7%B4%A2%E5%BC%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引篇"><a href="#MySQL索引篇" class="headerlink" title="MySQL索引篇"></a><strong>MySQL索引篇</strong></h1><h2 id="一、一条Select语句"><a href="#一、一条Select语句" class="headerlink" title="一、一条Select语句"></a>一、一条Select语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from tab_user WHERE id=1<br></code></pre></td></tr></table></figure><p>执行流程：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250228.png"></p><h2 id="二、MySQL索引简介"><a href="#二、MySQL索引简介" class="headerlink" title="二、MySQL索引简介"></a>二、MySQL索引简介</h2><h3 id="2-1-什么是索引？"><a href="#2-1-什么是索引？" class="headerlink" title="2.1 什么是索引？"></a>2.1 什么是索引？</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250002.png"></p><p>官方介绍索引是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构</strong>。更通俗的说，数据库索引好比是一本书前面的目录，能<strong>加快数据库的查询速度</strong>。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此<strong>索引往往是存储在磁盘上的文件中</strong>的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。</p><p><strong>我们通常所说的索引，包括聚簇索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织的索引。</strong></p><h3 id="2-2-优势和劣势"><a href="#2-2-优势和劣势" class="headerlink" title="2.2 优势和劣势"></a>2.2 优势和劣势</h3><p><strong>优势：</strong></p><ul><li><p><strong>可以提高数据检索的效率，降低数据库的IO成本</strong>，类似于书的目录。</p></li><li><p>通过<strong>索引列对数据进行排序</strong>，降低数据排序的成本，降低了CPU的消耗。</p><ul><li><p>被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。</p></li><li><p>如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。</p></li></ul></li></ul><p><strong>劣势：</strong></p><ul><li><strong>索引会占据磁盘空间</strong></li><li><strong>索引虽然会提高查询效率，但是会降低更新表的效率。</strong>比如每次对表进行增删改操作，MySQL不仅要保存数据，还要维护索引文件。</li></ul><h3 id="2-3-不用索引行不行？"><a href="#2-3-不用索引行不行？" class="headerlink" title="2.3 不用索引行不行？"></a>2.3 不用索引行不行？</h3><ul><li>行不行？完全可以</li><li>时间复杂度O(n)</li></ul><blockquote><p>用不用的选择权在谁手里？</p></blockquote><h2 id="三、索引的使用"><a href="#三、索引的使用" class="headerlink" title="三、索引的使用"></a>三、索引的使用</h2><h3 id="3-1-索引的类型"><a href="#3-1-索引的类型" class="headerlink" title="3.1 索引的类型"></a>3.1 索引的类型</h3><p>按照索引列的数量分类：</p><ul><li><strong>单列索引：</strong>索引中只有一个列。</li><li><strong>组合索引：</strong>使用2个以上的字段创建的索引</li></ul><h4 id="3-1-1-单列索引"><a href="#3-1-1-单列索引" class="headerlink" title="3.1.1 单列索引"></a>3.1.1 单列索引</h4><ul><li>主键索引：索引列中的值必须是唯一的不允许有空值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name ADD PRIMARY KEY (column_name);<br></code></pre></td></tr></table></figure><ul><li>普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name ADD INDEX index_name (column_name);<br></code></pre></td></tr></table></figure><ul><li>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE UNIQUE INDEX index_name ON table(column_name);<br></code></pre></td></tr></table></figure><ul><li><p>全文索引：只能在文本类型CHAR，VARCHAR，TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。</p></li><li><p>InnoDB全文索引，官网介绍：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-fulltext-index.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-fulltext-index.html</a></p><ul><li><p>全文搜索时候，全文索引一般很少使用，数据量比较少或者并发度低的时候可以用。但是数据</p><p>量大或者并发度高的时候一般是用专业的工具Lucene，ES，Solr</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建表时，创建全文索引<br>CREATE TABLE `t_fulltext` (<br>`id` int(11) NOT NULL AUTO_INCREMENT,<br>`content` varchar(100) DEFAULT NULL,<br>PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br><br>#创建全文索引<br>ALTER TABLE `t_fulltext` ADD FULLTEXT INDEX `idx_content`(`content`);<br><br>INSERT INTO `t_fulltext` (`id`,`content`) VALUES (&#x27;1&#x27;,&#x27;Mention&#x27;);<br>INSERT INTO `t_fulltext` (`id`,`content`) VALUES (&#x27;2&#x27;,&#x27;Vincent hero man&#x27;);<br>INSERT INTO `t_fulltext` (`id`,`content`) VALUES (&#x27;3&#x27;,&#x27;Benson&#x27;);<br>INSERT INTO `t_fulltext` (`id`,`content`) VALUES (&#x27;4&#x27;,&#x27;Carol&#x27;);<br>INSERT INTO `t_fulltext` (`id`,`content`) VALUES (&#x27;5&#x27;,&#x27;yilia&#x27;);<br>INSERT INTO `t_fulltext` (`id`,`content`) VALUES (&#x27;6&#x27;,&#x27;lock and lock&#x27;);<br></code></pre></td></tr></table></figure><p>可以使用MATCH() … AGAINST语法执行全文搜索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_fulltext WHERE MATCH(content) AGAINST(&#x27;Vincent&#x27;);<br></code></pre></td></tr></table></figure><ul><li><p>空间索引：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。（本课程中不做过多介绍）</p><p>参考资料：<a href="https://dev.mysql.com/doc/refman/5.7/en/opengis-geometry-model.html">MySQL中 OpenGIS Geometry Model</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-types.html">空间数据类型</a></p></li><li><p>前缀索引：在文本类型如CHAR，VARCHAR，TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name ADD INDEX index_name (column1(length));<br></code></pre></td></tr></table></figure><h4 id="3-1-2-组合索引"><a href="#3-1-2-组合索引" class="headerlink" title="3.1.2 组合索引"></a>3.1.2 组合索引</h4><ul><li>组合索引的使用，需要遵循<strong>最左前缀原则（最左匹配原则，后面详细讲解）</strong>。</li><li>一般情况下，<strong>建议使用组合索引代替单列索引</strong>（主键索引除外，具体原因后面讲解）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name ADD INDEX index_name (column1,column2);<br></code></pre></td></tr></table></figure><h3 id="3-2-删除索引"><a href="#3-2-删除索引" class="headerlink" title="3.2 删除索引"></a>3.2 删除索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP INDEX index_name ON table<br></code></pre></td></tr></table></figure><h3 id="3-3-查看索引"><a href="#3-3-查看索引" class="headerlink" title="3.3 查看索引"></a>3.3 查看索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW INDEX FROM table_name<br></code></pre></td></tr></table></figure><h2 id="四、索引的数据结构"><a href="#四、索引的数据结构" class="headerlink" title="四、索引的数据结构"></a>四、索引的数据结构</h2><h3 id="4-1-索引基本需求"><a href="#4-1-索引基本需求" class="headerlink" title="4.1 索引基本需求"></a>4.1 索引基本需求</h3><p>索引的数据结构，至少需要支持两种最常用的查询需求：</p><ol><li>等值查询：根据某个值查找数据，比如： <code>select * from t_user where age=76;</code></li><li>范围查询：根据某个范围区间查找数据，比如： <code>select * from t_user where age&gt;=76 and age&lt;=86;</code></li><li>排序</li><li>分组</li><li>..</li></ol><p>同时需要考虑时间和空间因素：<strong>性价比高</strong></p><ul><li>在执行时间方面，我们希望通过索引，查询数据的时间尽可能小；</li><li>在存储空间方面，我们希望索引不要消耗太多的内存空间和磁盘空间。</li></ul><h3 id="4-2-索引应该使用什么数据结构？"><a href="#4-2-索引应该使用什么数据结构？" class="headerlink" title="4.2 索引应该使用什么数据结构？"></a>4.2 索引应该使用什么数据结构？</h3><p>常用的数据结构：Hash表，二叉树，平衡二叉查找树（红黑树是一个近似平衡二叉树），B树，B+树。</p><blockquote><p>数据结构示例网站：可以通过动画看到操作过程，非常好的一个网站。<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p></blockquote><h4 id="4-2-1-Hash表"><a href="#4-2-1-Hash表" class="headerlink" title="4.2.1 Hash表"></a>4.2.1 Hash表</h4><p>Hash表，常见的数据结构之一。</p><p>我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；</p><ul><li>但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。</li><li>数据结构比较稀疏，不适合做聚合，不适合做范围等查找。</li></ul><p>使用场景：</p><ul><li>对查询并发要求很高，<strong>K&#x2F;V内存数据库，缓存</strong></li></ul><h4 id="4-2-2-二叉查找树"><a href="#4-2-2-二叉查找树" class="headerlink" title="4.2.2 二叉查找树"></a>4.2.2 二叉查找树</h4><ul><li>二叉树特点：每个节点最多有2个分叉，左子树和右子树数据顺序左小右大。</li><li>二叉树的检索复杂度和树高相关：理想状态下效率可以达到O(logn)</li></ul><p><strong>是不是任何列使用二叉树效率都会提升呢？答案是否定的。</strong></p><p>极端情况下，二叉查找树会构建成为单向链表 &#x3D; 查找全表扫描。</p><p>对磁盘不友好【一旦变成了全表扫描，磁盘io将是极其沉重】</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250893.png"></p><h4 id="4-2-3-红黑树"><a href="#4-2-3-红黑树" class="headerlink" title="4.2.3 红黑树"></a>4.2.3 红黑树</h4><blockquote><p>红黑树是一个近似平衡的二叉树</p></blockquote><p>平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级<strong>最多相差1</strong>。在插入删除数据时通过左旋&#x2F;右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。</p><p>使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。</p><blockquote><p>unique key 为什么不用红黑树，反正只存一个主键？</p></blockquote><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250217.png"></p><p><strong>平衡二叉树存在的问题</strong></p><ul><li>时间复杂度和树高相关：树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作【瓶颈】。<ul><li><strong>磁盘每次寻道时间为10ms</strong>，在表数据量大时，对响应时间要求高的场景下，查询性能就会出现瓶颈。</li><li>举例：1百万的数据量，log2n约等于20次磁盘IO，时间20*10&#x3D;0.2s</li></ul></li><li>平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率极差。</li><li>数据量大的情况下，索引存储空间占用巨大</li></ul><p>举个栗子：</p><ul><li>10亿行数据，时间复杂度O(logn)，最多不超过30次查到数据</li><li>最简单索引构成：&lt;ID，行号，指针&gt;</li><li>假如key为bigint&#x3D;8字节，每个节点有两个指针，每个指针为4个字节，一个节点占用的空间16个字节（8+4*2&#x3D;16）。</li><li>索引大小：10亿x16(bigint)&#x3D;15GB</li></ul><p><strong>为什么磁盘IO操作就慢？</strong>我举个栗子</p><ul><li>从磁盘读取数据时，系统会将逻辑地址发给磁盘，磁盘将逻辑地址转换为物理地址（哪个磁道，哪个扇区）。 磁头进行机械运动，先找到相应磁道，再找该磁道的对应扇区，扇区是磁盘的最小存储单元。</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251961.png"></p><ul><li><p>随机读写时，磁头需要不停的移动，时间都浪费在了磁头寻址上。 而在实际的磁盘存储里，是很少顺序存储的，因为这样的维护成本会很高。</p></li><li><p>性能差异：机械硬盘的连续读写性能很好，但随机读写性能很差。</p><ul><li><p>顺序访问：<strong>内存访问速度</strong>是硬盘访问速度的6~7倍</p></li><li><p>随机访问：<strong>内存访问速度</strong>就要比硬盘访问速度快上10万倍以上</p></li></ul></li></ul><p><strong>如何减少IO操作次数呢？如何才能降低存储空间呢？</strong></p><h4 id="4-2-4-B树：改进二叉树，为多叉树"><a href="#4-2-4-B树：改进二叉树，为多叉树" class="headerlink" title="4.2.4 B树：改进二叉树，为多叉树"></a>4.2.4 B树：改进二叉树，为多叉树</h4><p>想要减少耗时的IO操作，就要尽量降低树的高度。每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k&#x2F;16&#x3D;1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。</p><p>举例：构建1百万条数据，树的高度只需要2层就可以（1000*1000&#x3D;1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。</p><p>主要特点：</p><ol><li>B树的节点中存储着多个元素，每个内节点有多个分叉。</li><li>节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。</li><li>父节点当中的元素不会出现在子节点中。</li><li>所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。</li></ol><p>以下面的B树为例，我们的键值为表主键，具备唯一性。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251234.png"></p><p>B树如何查询数据？：假如我们查询值等于15的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块7。</p><p><strong>优点：</strong></p><ul><li>磁盘IO次数会大大减少。</li><li>比较是在内存中进行的，比较的耗时可以忽略不计。</li><li>B树的高度一般2至3层就能满足大部分的应用场景，所以使用B树构建索引可以很好的提升查询的效率。</li></ul><p><strong>缺点：</strong></p><ul><li>B树不支持范围查询的快速查找：如果我们想要查找15和26之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。</li><li>空间占用较大：如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。</li></ul><h4 id="4-2-5-B-树：改进B树，非叶子节点不存储数据"><a href="#4-2-5-B-树：改进B树，非叶子节点不存储数据" class="headerlink" title="4.2.5 B+树：改进B树，非叶子节点不存储数据"></a>4.2.5 B+树：改进B树，非叶子节点不存储数据</h4><p>在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于<strong>非叶子节点是否存储数据</strong>的问题</p><ul><li>B树：非叶子节点和叶子节点都会存储数据。</li><li>B+树：只有叶子节点才会存储数据，非叶子节点只存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。</li></ul><p>B+树的最底层叶子节点包含所有索引项。具备中路返回特性</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251725.png"></p><p><strong>等值查询</strong>：假如我们查询值等于15的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块5。</p><p><strong>范围查询</strong>：假如我们想要查找15和26之间的数据。</p><ul><li>查找路径是磁盘块1-&gt;磁盘块2-&gt;磁盘块5。</li><li>首先查找值等于15的数据，将值等于15的数据缓存到结果集【三次磁盘IO】。</li><li>查找到15之后，底层的叶子节点是一个有序列表，我们从磁盘块5，键值15开始向后遍历筛选所有符合筛选条件的数据。</li><li>第四次磁盘IO：根据磁盘5后继指针到磁盘中寻址定位到磁盘块6，将磁盘6加载到内存中，在内存中从头遍历比较，15&lt;17&lt;26，15&lt;26&lt;&#x3D;26，将data缓存到结果集。</li></ul><p><strong>优点：</strong></p><ul><li>继承了B树的优点【多叉树的优点】</li><li>保证等值和范围查询的快速查找</li><li>MySQL的索引就采用了B+树的数据结构。</li></ul><h2 id="五、存储引擎的索引案例"><a href="#五、存储引擎的索引案例" class="headerlink" title="五、存储引擎的索引案例"></a>五、存储引擎的索引案例</h2><h3 id="5-1-MyISAM索引"><a href="#5-1-MyISAM索引" class="headerlink" title="5.1 MyISAM索引"></a>5.1 MyISAM索引</h3><p>我们以t_user_myisam为例，来说明。t_user_myisam的id列为主键，age列为普通索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_user_myisam` (<br>`id` int(11) NOT NULL AUTO_INCREMENT,<br>`username` varchar(20) DEFAULT NULL,<br>`age` int(11) DEFAULT NULL,<br>PRIMARY KEY (`id`) USING BTREE,<br>KEY `idx_age` (`age`) USING BTREE<br>) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br><br>insert into t_user_myisam values(15,&#x27;Nick&#x27;,5);<br>insert into t_user_myisam values(18,&#x27;Zero&#x27;,22);<br>insert into t_user_myisam values(20,&#x27;Tom&#x27;,34);<br>insert into t_user_myisam values(30,&#x27;Nick&#x27;,55);<br>insert into t_user_myisam values(49,&#x27;Mary&#x27;,22);<br>insert into t_user_myisam values(50,&#x27;James&#x27;,77);<br>insert into t_user_myisam values(56,&#x27;John&#x27;,89);<br>insert into t_user_myisam values(77,&#x27;Lily&#x27;,100);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251293.png"></p><p>MyISAM的数据文件和索引文件是分开存储的。MyISAM使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。</p><h4 id="5-1-1-主键索引"><a href="#5-1-1-主键索引" class="headerlink" title="5.1.1 主键索引"></a>5.1.1 主键索引</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251269.png"></p><p>表t_user_myisam的索引存储在索引文件t_user_myisam.MYI中，数据文件存储在数据文件t_user_myisam.MYD中。</p><h5 id="1）等值查询数据"><a href="#1）等值查询数据" class="headerlink" title="1）等值查询数据"></a>1）等值查询数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_myisam where id=30;<br></code></pre></td></tr></table></figure><ol><li>先在主键树中从根节点开始检索，将根节点加载到内存，比较30&lt;56，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较20&lt;30&lt;49，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中遍历，比较20&lt;30，30&#x3D;30。查找到值等于30的索引项。（1次磁盘IO）</li><li>从索引项中获取磁盘地址，然后到数据文件t_user_myisam.MYD中获取对应整行记录。（1次磁盘IO）</li><li>将记录返给客户端。</li></ol><p><font style="background: yellow"><strong>磁盘IO次数：3+1次。</strong></font></p><h5 id="2）范围查询数据"><a href="#2）范围查询数据" class="headerlink" title="2）范围查询数据"></a>2）范围查询数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_myisam where id between 30 and 49;<br></code></pre></td></tr></table></figure><ol><li>先在主键树中从根节点开始检索，将根节点加载到内存，比较30&lt;56，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较20&lt;30&lt;49，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中遍历比较20&lt;30，30&lt;&#x3D;30&lt;49。查找到值等于30的索引项。</li><li>根据磁盘地址从数据文件中获取行记录缓存到结果集中。（2次磁盘IO）</li><li>我们的查询语句时范围查找，需要向后遍历底层叶子链表，直至到达最后一个不满足筛选条件。</li><li>向后遍历底层叶子链表，将下一个节点加载到内存中，遍历比较，30&lt;49&lt;&#x3D;49，根据磁盘地址从数据文件中获取行记录缓存到结果集中。（2次磁盘IO）</li><li>最后得到两条符合筛选条件，将查询结果集返给客户端。</li></ol><p><font style="background: yellow"><strong>磁盘IO次数：2+检索叶子节点数量+记录数。</strong></font></p><blockquote><p>MyISAM在查询时，会将索引节点缓存在MySQL缓存中，而数据缓存依赖于操作系统自身的缓存。</p></blockquote><h4 id="5-1-2-辅助索引"><a href="#5-1-2-辅助索引" class="headerlink" title="5.1.2 辅助索引"></a>5.1.2 辅助索引</h4><p>在 MyISAM 中，辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复。</p><p>查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据。</p><h3 id="5-2-InnoDB索引"><a href="#5-2-InnoDB索引" class="headerlink" title="5.2 InnoDB索引"></a>5.2 InnoDB索引</h3><h4 id="5-2-1-InnoDB索引简介"><a href="#5-2-1-InnoDB索引简介" class="headerlink" title="5.2.1 InnoDB索引简介"></a>5.2.1 InnoDB索引简介</h4><p>每个InnoDB表都有一个聚簇索引 ，也叫聚集索引。聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。</p><p><strong>除聚簇索引之外的所有索引都称为辅助索引</strong>。在中InnoDB，辅助索引中的叶子节点存储的数据都是该行的主键值。 在检索时，InnoDB使用此主键值在聚簇索引中搜索行记录。</p><p><strong>InnoDB创建索引的具体规则如下：</strong></p><ol><li>在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。</li><li>如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。</li><li>如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。</li></ol><p>下面我们一起来看一看这两种索引的实现。</p><p>我们以t_user_innodb为例，来说明。t_user_innodb的id列为主键，age列为普通索引。</p><p>t_user_innodb的表结构和数据与MyISAM引擎表t_user_myisam完全一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_user_innodb` (<br>`id` int(11) NOT NULL AUTO_INCREMENT,<br>`username` varchar(20) DEFAULT NULL,<br>`age` int(11) DEFAULT NULL,<br>PRIMARY KEY (`id`) USING BTREE,<br>KEY `idx_age` (`age`) USING BTREE<br>) ENGINE=InnoDB;<br><br>insert into t_user_innodb values(15,&#x27;Nick&#x27;,5);<br>insert into t_user_innodb values(18,&#x27;Zero&#x27;,22);<br>insert into t_user_innodb values(20,&#x27;Tom&#x27;,34);<br>insert into t_user_innodb values(30,&#x27;Nick&#x27;,55);<br>insert into t_user_innodb values(49,&#x27;Mary&#x27;,22);<br>insert into t_user_innodb values(50,&#x27;James&#x27;,77);<br>insert into t_user_innodb values(56,&#x27;John&#x27;,89);<br>insert into t_user_innodb values(77,&#x27;Lily&#x27;,100);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251820.png"></p><p>InnoDB的数据和索引存储在一个文件t_user_innodb.ibd中。InnoDB的数据组织方式是聚簇索引。</p><h4 id="5-2-2-主键索引"><a href="#5-2-2-主键索引" class="headerlink" title="5.2.2 主键索引"></a>5.2.2 主键索引</h4><ul><li>主键索引的叶子节点会存储数据行，辅助索引只会存储主键值。</li><li>InnoDB要求表必须有一个主键索引(MyISAM 可以没有)。</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251317.png"></p><h5 id="1）等值查询"><a href="#1）等值查询" class="headerlink" title="1）等值查询"></a>1）等值查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_innodb where id=30;<br></code></pre></td></tr></table></figure><ol><li><p>先在主键树中从根节点开始检索，将根节点加载到内存，比较30&lt;56，走左路。（1次磁盘IO）</p></li><li><p>将左子树节点加载到内存中，比较20&lt;30&lt;49，向下检索。（1次磁盘IO）</p></li><li><p>检索到叶节点，将节点加载到内存中遍历，比较20&lt;30，30&#x3D;30。查找到值等于30的索引项，直接可以获取整行数据。将改记录返回给客户端。（1次磁盘IO）</p></li></ol><p><font style="background: yellow"><strong>磁盘IO次数：3次。</strong></font></p><p><strong>流程分析：</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251373.png"></p><h5 id="2）范围查询"><a href="#2）范围查询" class="headerlink" title="2）范围查询"></a>2）范围查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_innodb where id between 30 and 49;<br></code></pre></td></tr></table></figure><ol><li>先在主键树中从根节点开始检索，将根节点加载到内存，比较30&lt;56，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较20&lt;30&lt;49，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中遍历比较20&lt;30，30&lt;&#x3D;30&lt;49。查找到值等于30的索引项。获取行数据缓存到结果集中。（1次磁盘IO）</li><li>向后遍历底层叶子链表，将下一个节点加载到内存中，遍历比较，30&lt;49&lt;&#x3D;49，获取行数据缓存到结果集中。（1次磁盘IO）</li><li>最后得到2条符合筛选条件，将查询结果集返给客户端。</li></ol><p>可以看到，因为在主键索引中直接存储了行数据，所以InnoDB在使用主键查询时可以快速获取行数据。当表很大时，与在索引树中存储磁盘地址的方式相比，因为不用再去磁盘中获取数据，所以聚簇索引通常可以节省磁盘IO操作。</p><p><font style="background: yellow"><strong>磁盘IO次数：2次+检索叶子节点数量。</strong></font></p><h4 id="5-2-3-辅助索引"><a href="#5-2-3-辅助索引" class="headerlink" title="5.2.3 辅助索引"></a>5.2.3 辅助索引</h4><ul><li>除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键值而非磁盘地址。</li><li>使用辅助索引需要检索两遍索引：<ul><li>首先检索辅助索引获得主键</li><li>然后使用主键到主索引中检索获得记录。</li></ul></li></ul><p>以表t_user_innodb的age列为例，age索引的索引结果如下图。底层叶子节点的按照（age，id）的顺序排序，先按照age列从小到大排序，age列相同时按照id列从小到大排序。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251545.png"></p><h5 id="1）等值查询-1"><a href="#1）等值查询-1" class="headerlink" title="1）等值查询"></a>1）等值查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_innodb where age=22;<br></code></pre></td></tr></table></figure><ol><li>先在索引树中从根节点开始检索，将根节点加载到内存，比较22&lt;77，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，比较22&lt;34，向下检索。（1次磁盘IO）</li><li>检索到叶节点，将节点加载到内存中从前往后遍历比较。（1次磁盘IO）</li></ol><ul><li>第一项5：5&lt;22不符合要求，丢弃。</li><li>第二项22：等于22，符合要求，获取主键id&#x3D;18，去主键索引树中检索id&#x3D;18的数据放入结果集中。（回表查：3次磁盘IO）。</li><li>第三项22：等于22，符合要求，获取主键id&#x3D;49，去主键索引树中检索id&#x3D;49的数据放入结果集中。（回表查：3次磁盘IO）</li></ul><ol start="4"><li>向后遍历底层叶子链表，将下一个节点加载到内存中，遍历比较。（1次磁盘IO）</li></ol><ul><li>第一项34：34&gt;22不符合要求，丢弃。查询结束。</li></ul><ol start="5"><li>最后得到2条符合筛选条件，将查询结果集返给客户端。</li></ol><p><font style="background: yellow"><strong>磁盘IO次数：2次+检索叶子节点数量+记录数*3。</strong></font></p><h5 id="2）什么是回表查询？"><a href="#2）什么是回表查询？" class="headerlink" title="2）什么是回表查询？"></a>2）什么是回表查询？</h5><p>根据在辅助索引树中获取的主键id，到主键索引树检索数据的过程称为回表查询。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251053.png"></p><h5 id="3）范围查询"><a href="#3）范围查询" class="headerlink" title="3）范围查询"></a>3）范围查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user_innodb where age between 30 and 49;<br></code></pre></td></tr></table></figure><ul><li>辅助索引的范围查询流程和等值查询基本一致，先使用辅助索引到叶子节点检索到第一个符合条件的索引项，然后向后遍历，直到遇到第一个不符合条件的索引项，终止。</li><li>检索过程中需要将符合筛选条件的id值，依次到主键索引检索将检索的数据放入结果集中。</li><li>最后将查询结果返回客户端。</li></ul><h4 id="5-2-4-组合索引"><a href="#5-2-4-组合索引" class="headerlink" title="5.2.4 组合索引"></a>5.2.4 组合索引</h4><h5 id="1）组合索引存储结构"><a href="#1）组合索引存储结构" class="headerlink" title="1）组合索引存储结构"></a>1）组合索引存储结构</h5><p>我们在使用索引时，组合索引是我们常用的索引类型。那组合索引是如何构建的，查找的时候又是如何进行查找的呢？</p><p>表t_multiple_index，id为主键列，创建了一个联合索引idx_abc(a,b,c)，构建的B+树索引结构如图所示。索引树中节点中的索引项按照（a，b，c）的顺序从大到小排列，先按照a列排序，a列相同时按照b列排序，b列相同按照c列排序。在最底层的叶子节点中，如果两个索引项的a，b，c三列都相同，索引项按照主键id排序。</p><p>所以组合索引的最底层叶子节点中不存在完全相同的索引项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_multiple_index` (<br>`id` int(11) NOT NULL AUTO_INCREMENT,<br>`a` int(11) DEFAULT NULL,<br>`b` int(11) DEFAULT NULL,<br>`c` varchar(10) DEFAULT NULL,<br>`d` varchar(10) DEFAULT NULL,<br>PRIMARY KEY (`id`) USING BTREE,<br>KEY `idx_abc` (`a`,`b`,`c`)<br>) ENGINE=InnoDB;<br>insert into t_multiple_index (a,b,c,id,d) values(1 ,1 ,4,5,&#x27;dll&#x27;);<br>insert into t_multiple_index (a,b,c,id,d) values(1 ,5 ,4,2,&#x27;doc&#x27;);<br>insert into t_multiple_index (a,b,c,id,d) values(5 ,3 ,6,7,&#x27;img&#x27;);<br>insert into t_multiple_index (a,b,c,id,d) values(13,14,3,4,&#x27;xml&#x27;);<br>insert into t_multiple_index (a,b,c,id,d) values(13,16,4,1,&#x27;txt&#x27;);<br>insert into t_multiple_index (a,b,c,id,d) values(13,16,5,3,&#x27;pdf&#x27;);<br>insert into t_multiple_index (a,b,c,id,d) values(13,16,5,6,&#x27;exe&#x27;);<br>insert into t_multiple_index (a,b,c,id,d) values(14,14,14,8,&#x27;ddd&#x27;);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251378.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251409.png"></p><h5 id="2）组合索引的查找方式"><a href="#2）组合索引的查找方式" class="headerlink" title="2）组合索引的查找方式"></a>2）组合索引的查找方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_multiple_index where a=13 and b=16 and c=4;<br></code></pre></td></tr></table></figure><ol><li>先在索引树中从根节点开始检索，将根节点加载到内存，先比较a列，a&#x3D;14，14&gt;13，走左路。（1次磁盘IO）</li><li>将左子树节点加载到内存中，先比较a列，a&#x3D;13，比较b列b&#x3D;16，14&lt;16，走右路，向下检索。（1次磁盘IO）</li><li>达到叶节点，将节点加载到内存中从前往后遍历比较。（1次磁盘IO）</li></ol><ul><li>第一项（13,14,3,id&#x3D;4）：先比较a列，a&#x3D;13，比较b列b&#x3D;14，b!&#x3D;16不符合要求，丢弃。</li><li>第二项（13,14,4,id&#x3D;1）：一样的比较方式，a&#x3D;13，b&#x3D;16，c&#x3D;4 满足筛选条件。取出索引</li><li>data值即主键id&#x3D;1，再去主键索引树中检索id&#x3D;1的数据放入结果集中。（回表：3次磁盘IO）第三项（13,14,5,id&#x3D;3）：a&#x3D;13，b&#x3D;16，c!&#x3D;4 不符合要求，丢弃。查询结束。</li></ul><ol start="4"><li>最后得到1条符合筛选条件，将查询结果集返给客户端。</li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251247.png"></p><h5 id="3）最左前缀匹配原则"><a href="#3）最左前缀匹配原则" class="headerlink" title="3）最左前缀匹配原则"></a>3）最左前缀匹配原则</h5><p><strong>组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(&gt;、&lt;、between、like)就停止匹配。</strong></p><ul><li>最左前缀匹配原则和联合索引的<strong>索引存储结构和检索方式</strong>是有关系的。</li><li>在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。</li><li>所以当我们使用 where a&#x3D;13 and b&#x3D;16 and c&#x3D;4去查询数据的时候，B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。！</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251327.png"></p><p>所以联合索引只能从第一列开始查找，比如以下三个查询都可以使用idx_abc索引树，检索数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_multiple_index where a=13;<br>select * from t_multiple_index where a=13 and b=16;<br>select * from t_multiple_index where a=13 and b=16 and c=4;<br>select * from t_multiple_index where a=13 and b&gt;13;<br>select * from t_multiple_index where a&gt;11 and b=14;<br>select * from t_multiple_index where a=16 and c=4;<br></code></pre></td></tr></table></figure><p>而如果查询条件不包含a列，比如筛选条件只有(b，c)或者c列是无法使用组合索引的。下面的查询没有用到索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_multiple_index where b=16 and c=4;<br>select * from t_multiple_index where c=4;<br></code></pre></td></tr></table></figure><p>所以创建的idx_abc(a,b,c)索引，相当于创建了(a)、（a,b）（a,b,c）三个索引。</p><p>另外，我们还需要注意的是，书写SQL条件的顺序，不一定是执行时候的where条件顺序。优化器会帮助我们优化成索引可以识别的形式。比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_multiple_index where b=16 and c=4 and a=13;<br>#等价于下面的sql，优化器会按照索引的顺序优化<br>select * from t_multiple_index where a=13 and b=16 and c=4;<br><br>explain select a,b from t_multiple_index where b=16;<br>explain select b from t_multiple_index where b=16 and c=4;<br>explain select b,c from t_multiple_index where c=4;<br></code></pre></td></tr></table></figure><p>一颗索引树等价与三颗索引树，从另一方面来说，组合索引也为我们节省了磁盘空间。所以在业务中尽量选用组合索引，能使用组合索引就不要使用单列索引。</p><blockquote><p><strong>索引使用口诀</strong></p><p>全值匹配我最爱，最左前缀要遵守。</p><p>带头大哥不能死，中间兄弟不能断。</p><p>索引列上不计算，范围之后全失效。</p><p>Like百分写最右，覆盖索引不写星。</p><p>不等空值还有OR，索引失效要少用。</p></blockquote><h5 id="4）组合索引创建原则"><a href="#4）组合索引创建原则" class="headerlink" title="4）组合索引创建原则"></a>4）组合索引创建原则</h5><ol><li>频繁出现在where条件中的列，建议创建组合索引。</li><li>频繁出现在order by和group by语句中的列，建议按照<strong>顺序</strong>去创建组合索引。</li></ol><ul><li>order by a,b 需要组合索引列顺序（a,b）。如果索引的顺序是（b,a），是用不到索引的。</li></ul><ol start="3"><li>常出现在select语句中的列，也建议创建组合索引。</li></ol><blockquote><p><font color=red>大家思考个问题，这个是咱们同学遇到的一个面试题。下面的SQL语句除了建a，b联合索引，还有更好的方案吗？</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t where a=1 and b&gt;2 order by c<br></code></pre></td></tr></table></figure><p>可以考虑建立（a , c）联合索引：select * from xxx where a&#x3D;1 and b&gt;2 order by c 这样 a等值查询 c就是已经排好序的了。这种情况实际上比较的是b的区分度和c的区分度，如果b的区分度比较差，建议使用a，c。如果c的区分度比较差，建议使用a , b。</p></blockquote><h4 id="5-2-5-覆盖索引"><a href="#5-2-5-覆盖索引" class="headerlink" title="5.2.5 覆盖索引"></a>5.2.5 覆盖索引</h4><p>前面我们提到，根据在辅助索引树查询数据时，首先通过辅助索引找到主键值，然后需要再根据主键值到主键索引中找到主键对应的数据。这个过程称为<strong>回表</strong>。</p><p>使用辅助索引查询比基于主键索引的查询多检索了一棵索引树。<strong>那是不是所有使用辅助索引的查询都需要回表查询呢？</strong></p><p>表t_multiple_index，组合索引idx_abc(a,b,c)的叶子节点中包含(a,b,c,id)四列的值，对于以下查询语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select a from t_multiple_index where a=13 and b=16;<br>select a,b from t_multiple_index where a=13 and b=16;<br>select a,b,c from t_multiple_index where a=13 and b=16;<br>select a,b,c,id from t_multiple_index where a=13 and b=16;<br></code></pre></td></tr></table></figure><p><strong>什么是覆盖索引？</strong></p><p>select中列数据如果可以直接在辅助索引树上全部获取，也就是说索引树已经“覆盖”了我们的查询需求，这时MySQL就不会白费力气的回表查询，这中现象就是<strong>覆盖索引</strong>。</p><p>使用explain工具查看执行计划，可以看到extra中“Using index”，代表使用了覆盖索引。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251453.png"></p><p><font color=red size=5>大家试试将上面的语句，改为如下语句。大家猜猜这时会不会用到组合索引？</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select a,b from t_multiple_index where b=16;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251618.png" alt="052401022218020"></p><p>上面的查询语句用到了覆盖索引进行索引扫描。MySQL基于成本考虑，会使用了覆盖索引进行全表扫描，使用覆盖索引可以减少了磁盘IO次数，显著提升查询性能。</p><p>覆盖索引相比与主键索引一个索引项占用的空间少，覆盖索引一个叶子节点中的就可以比主键索引存放 更多的数据量，相应的存放数据用到的总叶子树很少一些。</p><p><strong>覆盖索引是一种很常用的优化手段。</strong></p><h4 id="5-2-6-索引条件下推ICP"><a href="#5-2-6-索引条件下推ICP" class="headerlink" title="5.2.6 索引条件下推ICP"></a>5.2.6 索引条件下推ICP</h4><p>官方索引条件下推： Index Condition Pushdown，简称ICP。是MySQL5.6对使用索引从表中检索行的一种优化。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。可用于 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">InnoDB</a> 和 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html">MyISAM</a> 表，对于InnoDB表ICP仅用于辅助索引。</p><p>可以通过参数optimizer_switch控制ICP的开始和关闭。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#optimizer_switch优化相关参数开关<br>mysql&gt; show VARIABLES like &#x27;optimizer_switch&#x27;;<br>#关闭ICP<br>SET optimizer_switch = &#x27;index_condition_pushdown=off&#x27;;<br>#开启ICP<br>SET optimizer_switch = &#x27;index_condition_pushdown=on&#x27;;<br></code></pre></td></tr></table></figure><p>以InnoDB的辅助索引为例，来讲解ICP的作用：MySQl在使用组合索引在检索数据时是使用最左前缀原则来定位记录，左侧前缀之后不匹配的后缀，MySQL会怎么处理？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_multiple_index where a=13 and b&gt;15 and c=&#x27;5&#x27; and d=&#x27;pdf&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251785.png"></p><ul><li>根据最左前缀匹配原则，这个SQL语句会使用组合索引idx_abc(a,b,c)的（a,b）两列来检索记录。</li><li>MySQL首先会在组合索引中定位到第一个满足a&#x3D;13 and b&gt;&#x3D;15的索引项，<strong>MySQL之后会怎么处理呢</strong>？<ul><li>使用explain工具，查看执行计划，extra列中的“Using index condition”执行器表示使用了索引条件下推ICP。</li><li><strong>在MySQL 5.6之前</strong>：不使用ICP时，MySQL只能从索引项（13,16,4,1）开始，一个个回表查询找到行数据，然后再在服务层过滤后，返回给客户端。</li><li><strong>在MySQL 5.6之后</strong>：在使用ICP和不使用ICP时MySQL的执行情况会有所不同。</li></ul></li><li>关闭ICP，使用explain工具，查看执行计划，extra列中的“Using where”执行器表示没有使用了索</li><li>引条件下推ICP。</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251142.png"></p><p><strong>举个栗子：</strong></p><h5 id="1）不使用索引ICP"><a href="#1）不使用索引ICP" class="headerlink" title="1）不使用索引ICP"></a>1）不使用索引ICP</h5><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252930.png"></p><p>具体步骤如下：</p><ol><li>执行器使用索引(a,b,c)，筛选条件a&#x3D;13 and b&gt;&#x3D;15，调用存储引擎”下一行”接口。根据最左前缀原则联合索引检索定位到索引项（13,16,4,id&#x3D;1），然后使用id&#x3D;1回表查询，获得id&#x3D;1的行记录。返回给MySQL服务层，MySQL服务层使用剩余条件c&#x3D;5 and d&#x3D;’pdf’过滤，不符合要求，直接丢弃。</li><li>执行器调用”下一行”接口，存储引擎遍历向后找到索引项（13,16,5,id&#x3D;3）,使用id&#x3D;3回表获得id&#x3D;3的行记录。返回给MySQL服务层，MySQL服务层使用剩余条件c&#x3D;5 and d&#x3D;’pdf’过滤，符合要求，缓存到结果集。</li><li>执行器调用”下一行”接口，存储引擎遍历向后找到索引项（13,16,5,id&#x3D;6）,使用id&#x3D;6回表获得id&#x3D;6的行记录。返回给MySQL服务层，MySQL服务层使用剩余条件c&#x3D;5 and d&#x3D;’pdf’过滤，不符合要求，直接丢弃。</li><li>执行器调用”下一行”接口，存储引擎遍历向后找到索引项（14,14,14,id&#x3D;8）不满足筛选条件，执行器终止查询。</li><li>最终获取一条记录，返回给客户端。</li></ol><p>可以看到，<strong>在不使用ICP时，回表查询了3次，然后在服务层筛选后（筛选3次）</strong>，最后返回客户端。</p><p>在MySQL 5.6 引入了ICP，可以在索引遍历过程中，对where中包含的索引条件先做判断，只有满足条件的才会回表查询读取行数据。这么做可以减少回表查询，从而减少磁盘IO次数。</p><h5 id="2）使用索引ICP"><a href="#2）使用索引ICP" class="headerlink" title="2）使用索引ICP"></a>2）使用索引ICP</h5><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252733.png"></p><p>使用ICP时，具体步骤如下：</p><ol><li>执行器使用索引(a,b,c)，筛选条件a&#x3D;13 and b&gt;&#x3D;15 and c&#x3D;5，调用存储引擎”下一行”接口。根据最左前缀原则联合索引检索定位到索引项（13,16,4,id&#x3D;1），然后使用ICP下推条件c&#x3D;5判断，不满足条件，直接丢弃。</li><li>向后遍历判断索引项（13,16,5,id&#x3D;3），满足筛选条件a&#x3D;13 and b&gt;&#x3D;15 and c&#x3D;5，使用id&#x3D;3回表获得id&#x3D;3的行记录。返回给MySQL服务层，MySQL服务层使用剩余条件d&#x3D;’pdf’过滤，符合要求，缓存到结果集。</li><li>执行器调用”下一行”接口，存储引擎遍历向后找到索引项（13,16,5,id&#x3D;6）,满足筛选条件a&#x3D;13 andb&gt;&#x3D;15 and c&#x3D;5，使用id&#x3D;6回表获得id&#x3D;6的行记录。返回给MySQL服务层，MySQL服务层使用剩余条件d&#x3D;’pdf’过滤，不符合要求，直接丢弃。</li><li>执行器调用”下一行”接口，存储引擎遍历向后找到索引项（14,14,14,id&#x3D;8）不满足筛选条件，执行器终止查询。</li><li>最终获取一条记录，返回给客户端。</li></ol><p>可以看到，在使用ICP时，回表查询了2次，然后在服务层筛选后（筛选2次），最后返回客户端。</p><h5 id="3）小结"><a href="#3）小结" class="headerlink" title="3）小结"></a>3）小结</h5><ul><li><strong>不使用ICP，不满足最左前缀的索引条件的比较是在Server层进行的，非索引条件的比较是在Server层进行的。</strong></li><li><strong>使用ICP，所有的索引条件的比较是在存储引擎层进行的，非索引条件的比较是在Server层进行的。</strong></li><li>对比使用ICP和不使用ICP，可以看到使用ICP可以有效减少回表查询次数和返回给服务层的记录数，从而减少了磁盘IO次数和服务层与存储引擎的交互次数。</li></ul><h2 id="六、索引创建原则"><a href="#六、索引创建原则" class="headerlink" title="六、索引创建原则"></a>六、索引创建原则</h2><h3 id="6-1-哪些情况需要创建索引"><a href="#6-1-哪些情况需要创建索引" class="headerlink" title="6.1 哪些情况需要创建索引"></a>6.1 哪些情况需要创建索引</h3><ol><li>频繁出现在where 条件字段，order排序，group by分组字段</li><li>select 频繁查询的列，考虑是否需要创建联合索引（覆盖索引，不回表）</li><li>多表join关联查询，on字段两边的字段都要创建索引</li></ol><h3 id="6-2-索引优化建议"><a href="#6-2-索引优化建议" class="headerlink" title="6.2 索引优化建议"></a>6.2 索引优化建议</h3><ol><li><p><strong>表记录很少不需创建索引 ：</strong>索引是要有存储的开销</p></li><li><p><strong>一个表的索引个数不能过多：</strong></p></li></ol><p>  （1）空间：浪费空间。每个索引都是一个索引树，占据大量的磁盘空间。</p><p>  （2）时间：更新（插入&#x2F;Delete&#x2F;Update）变慢。需要更新所有的索引树。太多的索引也会增加优化器的选择时间。</p><p>  所以索引虽然能够提高查询效率，索引并不是越多越好，应该只为需要的列创建索引。</p><ol start="3"><li><p><strong>频繁更新的字段不建议作为索引：</strong>频繁更新的字段引发频繁的页分裂和页合并，性能消耗比较高。</p></li><li><p><strong>区分度低的字段，不建议建索引：</strong></p></li></ol><p>  比如性别，男，女；比如状态。区分度太低时，会导致扫描行数过多，再加上回表查询的消耗。如果使用索引，比全表扫描的性能还要差。这些字段一般会用在组合索引中。</p><p>  姓名，手机号就非常适合建索引。</p><ol start="5"><li><strong>在InnoDB存储引擎中，主键索引建议使用自增的长整型，避免使用很长的字段：</strong></li></ol><p>  主键索引树一个页节点是16K，主键字段越长，一个页可存储的数据量就会越少，比较臃肿，查询时尤其是区间查询时磁盘IO次数会增多。辅助索引树上叶子节点存储的数据是主键值，主键值越长，一个页可存储的数据量就会越少，查询时磁盘IO次数会增多，查询效率会降低。</p><ol start="6"><li><p><strong>不建议用无序的值作为索引：</strong>例如身份证、UUID。更新数据时会发生频繁的页分裂，页内数据不紧凑，浪费磁盘空间。</p></li><li><p><strong>尽量创建组合索引，而不是单列索引：</strong></p></li></ol><p>  优点：</p><p>  （1）1个组合索引等同于多个索引效果，节省空间。</p><p>  （2）可以使用覆盖索引</p><p>  <strong>创建原则：组合索引应该把频繁用到的列、区分度高的值放在前面。频繁使用代表索引的利用率高，区分度高代表筛选粒度大，这样做可最大限度利用索引价值，缩小筛选范围</strong></p><h2 id="案例：索引失效分析"><a href="#案例：索引失效分析" class="headerlink" title="案例：索引失效分析"></a>案例：索引失效分析</h2><p><strong>组合索引心法口诀：</strong></p><ul><li>全值匹配我最爱，最左前缀要遵守；</li><li>带头大哥不能死，中间兄弟不能断；</li><li>索引列上不计算，范围之后全失效；</li><li>Like百分写最右，覆盖索引不写星；</li><li>不等空值还有OR，索引失效要少用。</li></ul><h3 id="1、案例环境"><a href="#1、案例环境" class="headerlink" title="1、案例环境"></a>1、案例环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_user_index_analyse` (<br>`id` int(11) NOT NULL AUTO_INCREMENT,<br>`name` varchar(255) DEFAULT NULL,<br>`age` int(11) DEFAULT NULL,<br>`pos` varchar(10) DEFAULT NULL,<br>`pay_time` datetime DEFAULT NULL,<br>PRIMARY KEY (`id`) USING BTREE,<br>KEY `idx_user_nameAgePos` (`name`,`age`,`pos`)<br>) ENGINE=InnoDB;<br>insert into t_user_index_analyse (id,name,age,pos,pay_time) values(1 ,&#x27;z3&#x27;,22,&#x27;manager&#x27;,&#x27;2022-03-13 09:31:34&#x27;);<br>insert into t_user_index_analyse (id,name,age,pos,pay_time) values(2 ,&#x27;July&#x27;,23,&#x27;dev&#x27;,&#x27;2022-03-13 09:31:34&#x27;);<br>insert into t_user_index_analyse (id,name,age,pos,pay_time) values(3 ,&#x27;2000&#x27;,23,&#x27;dev&#x27;,&#x27;2022-03-13 09:31:34&#x27;);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show index from t_user_index_analyse;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251885.png"></p><h3 id="2、案例演示"><a href="#2、案例演示" class="headerlink" title="2、案例演示"></a>2、案例演示</h3><ol><li>全值匹配我最爱</li><li>最左前缀匹配原则</li><li>不在索引列上做任何操作【计算、函数、类型转换】，会导致索引失效，转而使用全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引【只访问索引的查询，索引列和查询列一致】，减少使用select *</li><li>不等于【!&#x3D; 或 &lt;&gt;】，索引会失效</li><li>is null，is not null，索引会失效</li><li>like以通配符开头，索引会失效</li><li>字符串不加单引号，索引会失效</li><li>少用or，用它来连接时，索引会失效</li></ol><h4 id="1）全值匹配我最爱"><a href="#1）全值匹配我最爱" class="headerlink" title="1）全值匹配我最爱"></a>1）全值匹配我最爱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t_user_index_analyse where name=&#x27;July&#x27;;<br>explain select * from t_user_index_analyse where name=&#x27;July&#x27; and age=25;<br>explain select * from t_user_index_analyse where name=&#x27;July&#x27; and age=25 and pos=&#x27;dev&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251877.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251306.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251194.png"></p><h4 id="2）最左前缀法则"><a href="#2）最左前缀法则" class="headerlink" title="2）最左前缀法则"></a>2）最左前缀法则</h4><blockquote><p>带头索引不能死，中间索引不能断</p></blockquote><p>如果索引有多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且不跳过索引中的列。 正确的示例参考上图。</p><p><strong>错误的示例：</strong></p><p>带头索引死：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t_user_index_analyse where age=23 and pos=&#x27;dev&#x27;;<br>explain select * from t_user_index_analyse where pos=&#x27;dev&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251886.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251461.png"></p><p>中间索引断（带头索引生效，其他索引失效)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t_user_index_analyse where name=&#x27;July&#x27; and pos=&#x27;dev&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240251412.png"></p><h4 id="3）不要在索引上做计算"><a href="#3）不要在索引上做计算" class="headerlink" title="3）不要在索引上做计算"></a>3）不要在索引上做计算</h4><p>不要进行这些操作：计算、函数、自动&#x2F;手动类型转换，不然会导致索引失效而转向全表扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t_user_index_analyse where name=&#x27;July&#x27;;<br>explain select * from t_user_index_analyse where left(name,4)=&#x27;July&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252199.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252556.png"></p><h4 id="4）范围条件右边的列失效"><a href="#4）范围条件右边的列失效" class="headerlink" title="4）范围条件右边的列失效"></a>4）范围条件右边的列失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列<br>explain select * from t_user_index_analyse where name=&#x27;July&#x27; and age=25 and pos=&#x27;manager&#x27;;<br>explain select * from t_user_index_analyse where name=&#x27;July&#x27; and age&gt;25 and pos=&#x27;manager&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252124.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252108.png"></p><h4 id="5）尽量使用覆盖索引"><a href="#5）尽量使用覆盖索引" class="headerlink" title="5）尽量使用覆盖索引"></a>5）尽量使用覆盖索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 尽量使用覆盖索引（只查询索引的列），也就是索引列和查询列一致，减少select *<br>explain select * from t_user_index_analyse where name=&#x27;July&#x27; and age=25 and pos=&#x27;manager&#x27;;<br>explain select name,age,pos from t_user_index_analyse where name=&#x27;July&#x27; and age=25 and pos=&#x27;manager&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252326.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252358.png"></p><h4 id="6）索引字段上不要使用不等"><a href="#6）索引字段上不要使用不等" class="headerlink" title="6）索引字段上不要使用不等"></a>6）索引字段上不要使用不等</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描<br>explain select * from t_user_index_analyse where name = &#x27;July&#x27;;<br>explain select * from t_user_index_analyse where name != &#x27;July&#x27;;<br>explain select * from t_user_index_analyse where name &lt;&gt; &#x27;July&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252578.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252410.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252610.png"></p><h4 id="7）索引字段上不要判断null"><a href="#7）索引字段上不要判断null" class="headerlink" title="7）索引字段上不要判断null"></a>7）索引字段上不要判断null</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 索引字段上使用 is not null 判断时，会导致索引失效而转向全表扫描<br>explain select * from t_user_index_analyse where name is not null;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252971.png"></p><h4 id="8）索引字段使用like不以通配符开头"><a href="#8）索引字段使用like不以通配符开头" class="headerlink" title="8）索引字段使用like不以通配符开头"></a>8）索引字段使用like不以通配符开头</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描<br>explain select * from t_user_index_analyse where name like &#x27;%July%&#x27;;<br>explain select * from t_user_index_analyse where name like &#x27;%July&#x27;;<br>explain select * from t_user_index_analyse where name like &#x27;July%&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252957.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252536.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252287.png"></p><p>由结果可知，like以通配符结束相当于范围查找，索引不会失效。与范围条件（bettween、&lt;、&gt;、in等)不同的是<strong>不会导致右边的索引失效。</strong></p><h4 id="9）索引字段字符串要加单引号"><a href="#9）索引字段字符串要加单引号" class="headerlink" title="9）索引字段字符串要加单引号"></a>9）索引字段字符串要加单引号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描<br>explain select * from t_user_index_analyse where name = &#x27;2000&#x27;;<br>explain select * from t_user_index_analyse where name = 2000;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252690.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252598.png"></p><h4 id="10）索引字段不要使用or"><a href="#10）索引字段不要使用or" class="headerlink" title="10）索引字段不要使用or"></a>10）索引字段不要使用or</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 索引字段使用 or 时，会导致索引失效而转向全表扫描<br>explain select * from t_user_index_analyse where name = &#x27;July&#x27; or name=&#x27;z3&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240252033.png"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MySQL</category>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL锁篇</title>
    <link href="/2022/05/27/MySQL%E9%94%81%E7%AF%87/"/>
    <url>/2022/05/27/MySQL%E9%94%81%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL锁篇"><a href="#MySQL锁篇" class="headerlink" title="MySQL锁篇"></a><strong>MySQL锁篇</strong></h1><h2 id="1-一条update语句"><a href="#1-一条update语句" class="headerlink" title="1. 一条update语句"></a>1. 一条update语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update tab_user set name=&#x27;曹操&#x27; where id = 1;<br></code></pre></td></tr></table></figure><p>执行流程：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249289.jpeg"></p><h2 id="2-MySQL锁介绍"><a href="#2-MySQL锁介绍" class="headerlink" title="2. MySQL锁介绍"></a>2. MySQL锁介绍</h2><p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改一部分数据时，MySQL会通过锁定防止其他用户读取同一数据。</p><p>在处理并发读或者写时，通过实现一个由两种类型的锁组成的锁系统来解决问题。两种锁通常被称为**共享锁(shared lock)<strong>和</strong>排他锁(exclusive lock)<strong>，也叫</strong>读锁(read lock)<strong>和</strong>写锁(write lock)**。</p><p>读锁是共享的，是互相不阻塞的。多个客户端在同一时刻可以同时读取同一个资源，而不互相干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。</p><h3 id="2-1-锁分类"><a href="#2-1-锁分类" class="headerlink" title="2.1 锁分类"></a>2.1 锁分类</h3><p><strong>按锁粒度分：</strong></p><ul><li>全局锁：锁整Database，由MySQL的SQL layer层实现</li><li>表级锁：锁某Table，由MySQL的SQL layer层实现</li><li>行级锁：锁某Row的索引，也可锁定行索引之间的间隙，由存储引擎实现【InnoDB】</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249062.jpeg"></p><p><strong>按锁功能分：</strong></p><ul><li><strong>共享锁Shared Locks（S锁，也叫读锁）</strong>： 为了方便理解，下文我们全部使用<strong>读锁</strong>来称呼<ul><li>加了读锁的记录，允许其他事务再加读锁</li><li>加锁方式：select…lock in share mode</li></ul></li><li><strong>排他锁Exclusive Locks（X锁，也叫写锁）</strong>：为了方便理解，下文我们全部使用<strong>写锁</strong>来称呼<ul><li>加了写锁的记录，不允许其他事务再加读锁或者写锁</li><li>加锁方式：select…for update</li></ul></li></ul><h3 id="2-2-什么是全局锁？"><a href="#2-2-什么是全局锁？" class="headerlink" title="2.2 什么是全局锁？"></a>2.2 什么是全局锁？</h3><p>全局锁是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>加全局锁的命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush tables with read lock;<br></code></pre></td></tr></table></figure><p>释放全局锁的命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables;<br></code></pre></td></tr></table></figure><p>或者断开加锁session的连接，自动释放全局锁。</p><p>说到全局锁用于备份这个事情，还是很危险的。因为如果在主库上加全局锁，则整个数据库将不能写入，备份期间影响业务运行，如果在从库上加全局锁，则会导致不能执行主库同步过来的操作，造成主从延迟。</p><p>对于innodb这种支持事务的引擎，使用mysqldump备份时可以使用–single-transaction参数，利用mvcc提供一致性视图，而不使用全局锁，不会影响业务的正常运行。而对于有MyISAM这种不支持事务的表，就只能通过全局锁获得一致性视图，对应的mysqldump参数为–lock-all-tables。</p><p>举个栗子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">提交请求锁定所有数据库中的所有表，以保证数据的一致性，全局读锁</span><br>mysqldump -uroot -p --host=localhost --all-databases --lock-all-tables &gt; /root/db.sql<br><span class="hljs-meta prompt_"># </span><span class="language-bash">一致性视图</span><br>mysqldump -uroot -p --host=localhost --all-databases --single-transaction &gt; /root/db.sql<br></code></pre></td></tr></table></figure><h2 id="3-表级锁"><a href="#3-表级锁" class="headerlink" title="3. 表级锁"></a>3. 表级锁</h2><h3 id="3-1-什么是表级锁？"><a href="#3-1-什么是表级锁？" class="headerlink" title="3.1 什么是表级锁？"></a>3.1 什么是表级锁？</h3><p>MySQL的表级锁有四种：</p><ul><li>表读锁（Table Read Lock）</li><li>表写锁（Table Write Lock）</li><li>元数据锁（meta data lock，MDL)</li><li>自增锁(AUTO-INC Locks)</li></ul><h3 id="3-2-表读锁、写锁"><a href="#3-2-表读锁、写锁" class="headerlink" title="3.2 表读锁、写锁"></a>3.2 表读锁、写锁</h3><h4 id="1）表锁相关命令"><a href="#1）表锁相关命令" class="headerlink" title="1）表锁相关命令"></a>1）表锁相关命令</h4><p>MySQL 实现的表级锁定的争用状态变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看表锁定状态<br>mysql&gt; show status like &#x27;table%&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249659.jpeg"></p><ul><li>table_locks_immediate：产生表级锁定的次数；</li><li>table_locks_waited：出现表级锁定争用而发生等待的次数；</li></ul><p>表锁有两种表现形式：</p><ul><li><p>表读锁（Table Read Lock）</p></li><li><p>表写锁（Table Write Lock）</p></li></ul><p>手动增加表锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">lock table 表名称 read(write),表名称2 read(write)，其他;<br># 举例：<br>lock table t read; #为表t加读锁<br>lock table t write; #为表t加写锁<br></code></pre></td></tr></table></figure><p>查看表锁情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show open tables;<br></code></pre></td></tr></table></figure><p>删除表锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables;<br></code></pre></td></tr></table></figure><h4 id="2）表锁演示"><a href="#2）表锁演示" class="headerlink" title="2）表锁演示"></a>2）表锁演示</h4><h5 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE mylock (<br>id int(11) NOT NULL AUTO_INCREMENT,<br>NAME varchar(20) DEFAULT NULL,<br>PRIMARY KEY (id)<br>);<br>INSERT INTO mylock (id,NAME) VALUES (1, &#x27;a&#x27;);<br>INSERT INTO mylock (id,NAME) VALUES (2, &#x27;b&#x27;);<br>INSERT INTO mylock (id,NAME) VALUES (3, &#x27;c&#x27;);<br>INSERT INTO mylock (id,NAME) VALUES (4, &#x27;d&#x27;);<br></code></pre></td></tr></table></figure><h5 id="2-读锁演示：mylock表加read锁【读阻塞写】"><a href="#2-读锁演示：mylock表加read锁【读阻塞写】" class="headerlink" title="2. 读锁演示：mylock表加read锁【读阻塞写】"></a>2. 读锁演示：mylock表加read锁【读阻塞写】</h5><table><thead><tr><th>时间</th><th><strong>session01</strong></th><th><strong>session02</strong></th></tr></thead><tbody><tr><td>T1</td><td>连接MySQL</td><td></td></tr><tr><td>T2</td><td>获得表mylock的Read Lock锁定：<br/>lock table mylock read;</td><td>连接MySQL</td></tr><tr><td>T3</td><td>当前Session可以查询该表记录：<br/>select * from mylock;</td><td>其他Session也可以查询该表的记录：<br/>select * from mylock;</td></tr><tr><td>T4</td><td>当前Session不能查询其他没有锁定的表：<br />select * from t;</td><td>其他Session可以查询或更新未锁定的表：<br />update t set c&#x3D;’张飞’ where id&#x3D;1</td></tr><tr><td>T5</td><td>当前Session插入或更新锁定的表会提示错误：<br />insert into mylock (name) values(‘e’)；</td><td>其他Session插入或更新锁定表<strong>会一直等待</strong>获取锁：<br />insert into mylock (name) values(‘e’)；</td></tr><tr><td>T6</td><td>释放锁： unlock tables;</td><td>插入成功：</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- Session01<br># 获得表mylock的Read Lock锁定：<br>lock table mylock read;<br># 当前Session可以查询该表记录：<br>select * from mylock;<br># 当前Session不能查询其他没有锁定的表：<br>select * from t;<br># 当前Session插入或更新锁定的表会提示错误：<br>insert into mylock (name) values(&#x27;e&#x27;);<br># 释放锁：<br>unlock tables;<br><br>-- Session02<br># 其他Session也可以查询该表的记录：<br>select * from mylock;<br># 其他Session可以查询或更新未锁定的表：<br>update t set c=&#x27;张飞&#x27; where id=1;<br># 其他Session插入或更新锁定表会一直等待获取锁：<br>insert into mylock (name) values(&#x27;e&#x27;)<br></code></pre></td></tr></table></figure><h5 id="3-写锁演示：mylock表加write锁【写阻塞读】"><a href="#3-写锁演示：mylock表加write锁【写阻塞读】" class="headerlink" title="3. 写锁演示：mylock表加write锁【写阻塞读】"></a>3. 写锁演示：mylock表加write锁【写阻塞读】</h5><table><thead><tr><th>时间</th><th><strong>session01</strong></th><th><strong>session02</strong></th></tr></thead><tbody><tr><td>T1</td><td>连接MySQL</td><td>待session1开启锁后，session2再获取连接</td></tr><tr><td>T2</td><td>获得表mylock的write锁：<br/>lock table mylock write；</td><td></td></tr><tr><td>T3</td><td>当前session对锁定表的查询+更新+插入操作都可以执行：<br/>select * from mylock where id&#x3D;1;<br/>insert into mylock (name) values(‘e’);</td><td>连接MySQL</td></tr><tr><td>T4</td><td></td><td>其他session对锁定表的查询被阻塞，需要等待锁被释放<br/>select * from mylock where id&#x3D;1;</td></tr><tr><td>T5</td><td>释放锁： unlock tables;</td><td>获得锁，返回查询结果：</td></tr></tbody></table><blockquote><p>注意：MySQL有缓存，如果在查询过程中没有被阻塞说明查询到的是缓存数据。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- Session01<br># 获得表mylock的write锁：<br>lock table mylock write;<br># 当前session对锁定表的查询+更新+插入操作都可以执行：<br>select * from mylock where id=1;<br>insert into mylock (name) values(&#x27;e&#x27;);<br># 释放锁：<br>unlock tables;<br><br>-- Session02<br># 注意：待session1开启锁后，session2再获取连接<br># 其他session对锁定表的查询被阻塞，需要等待锁被释放<br>select * from mylock where id=1;<br># 获得锁，返回查询结果：<br></code></pre></td></tr></table></figure><h3 id="3-3-元数据锁"><a href="#3-3-元数据锁" class="headerlink" title="3.3 元数据锁"></a>3.3 元数据锁</h3><h4 id="1）元数据锁介绍"><a href="#1）元数据锁介绍" class="headerlink" title="1）元数据锁介绍"></a>1）元数据锁介绍</h4><p>元数据锁不需要显式指定，在访问一个表的时候会被自动加上，锁的作用是保证读写的正确性。</p><p>可以想象一下：如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>在</strong> <strong>MySQL 5.5</strong> <strong>版本中引入了元数据锁</strong>，当对一个表做增删改查操作的时候，<strong>加 元数据 读锁</strong>；当要对表做结构变更操作的时候，<strong>加 元数据 写锁</strong>。</p><ul><li><strong>读锁是共享的，是互相不阻塞的</strong>：因此你可以有多个线程同时对一张表加读锁，保证数据在读取的过程中不会被其他线程修改。</li><li><strong>写锁则是排他的：</strong>也就是说一个写锁会阻塞其他的写锁和读锁，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><h4 id="2）元数据锁演示"><a href="#2）元数据锁演示" class="headerlink" title="2）元数据锁演示"></a>2）元数据锁演示</h4><table><thead><tr><th>时间</th><th><strong>session01</strong></th><th><strong>session02</strong></th></tr></thead><tbody><tr><td>T1</td><td>开启事务：begin</td><td></td></tr><tr><td>T2</td><td>加元数据读锁： select * from mylock;</td><td>修改表结构： alter table mylock add f int;</td></tr><tr><td>T3</td><td>提交&#x2F;回滚事务： commit&#x2F;rollback 释放锁</td><td></td></tr><tr><td>T4</td><td></td><td>获取锁，修改完成</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- Session01<br># 开启事务：<br>begin<br># 加元数据读锁：<br>select * from mylock;<br># 提交/回滚事务：<br>commit<br># 释放锁<br><br>-- Session02<br># 修改表结构：<br>alter table mylock add f int;<br># 获取锁，修改完成<br></code></pre></td></tr></table></figure><h3 id="3-4-自增锁-AUTO-INC-Locks"><a href="#3-4-自增锁-AUTO-INC-Locks" class="headerlink" title="3.4 自增锁(AUTO-INC Locks)"></a>3.4 自增锁(AUTO-INC Locks)</h3><p>AUTO-INC锁是一种特殊的表级锁，发生涉及AUTO_INCREMENT列的事务性插入操作时产生。</p><h2 id="4-行级锁"><a href="#4-行级锁" class="headerlink" title="4. 行级锁"></a>4. 行级锁</h2><h3 id="4-1-什么是行级锁？"><a href="#4-1-什么是行级锁？" class="headerlink" title="4.1 什么是行级锁？"></a>4.1 什么是行级锁？</h3><p>MySQL的<strong>行级锁</strong>，是由<strong>存储引擎</strong>来实现的，这里我们主要讲解<strong>InnoDB</strong>的行级锁。<strong>InnoDB行锁</strong>是通过给索引上的<strong>索引项加锁来实现的</strong>，因此InnoDB这种行锁实现特点：<strong>只有通过索引条件检索的数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p><ul><li>InnoDB的行级锁，按照锁定范围来说，分为四种：<ul><li>记录锁（Record Locks）：锁定索引中一条记录。</li><li>间隙锁（Gap Locks）：要么锁住索引记录中间的值，要么锁住第一个索引记录前面的值或者最后一个索引记录后面的值。</li><li>临键锁（Next-Key Locks）：是索引记录上的记录锁和在索引记录之前的间隙锁的组合（间隙锁 + 记录锁）。</li><li>插入意向锁(Insert Intention Locks)：做insert操作时添加的对记录id的锁。</li></ul></li><li>InnoDB的行级锁，按照功能来说，分为两种：<ul><li>读锁：允许一个事务去读一行，阻止其他事务更新目标行数据。同时阻止其他事务加写锁，但不阻止其他事务加读锁。</li><li>写锁：允许获得排他锁的事务更新数据，阻止其他事务获取或修改数据。同时阻止其他事务加读锁和写锁。</li></ul></li></ul><h4 id="如何加行级锁？"><a href="#如何加行级锁？" class="headerlink" title="如何加行级锁？"></a>如何加行级锁？</h4><ul><li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加写锁；</li><li>对于普通SELECT语句，InnoDB不会加任何锁</li><li>事务可以通过以下语句手动给记录集加共享锁或排他锁。</li></ul><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t1_simple` (<br>`id` int(11) NOT NULL,<br>`pubtime` int(11) NULL DEFAULT NULL,<br>PRIMARY KEY (`id`) USING BTREE,<br>INDEX `idx_pu`(`pubtime`) USING BTREE<br>) ENGINE = InnoDB;<br>INSERT INTO `t1_simple` VALUES (1, 10);<br>INSERT INTO `t1_simple` VALUES (4, 3);<br>INSERT INTO `t1_simple` VALUES (6, 100);<br>INSERT INTO `t1_simple` VALUES (8, 5);<br>INSERT INTO `t1_simple` VALUES (10, 1);<br>INSERT INTO `t1_simple` VALUES (100, 20);<br></code></pre></td></tr></table></figure><p><strong>添加读锁：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t1_simple WHERE id=4 LOCK IN SHARE MODE; <br></code></pre></td></tr></table></figure><p><strong>添加写锁：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t1_simple WHERE id=4 FOR UPDATE;<br></code></pre></td></tr></table></figure><h3 id="4-2-行锁四兄弟：记录、间隙、临键和插入意向锁"><a href="#4-2-行锁四兄弟：记录、间隙、临键和插入意向锁" class="headerlink" title="4.2 行锁四兄弟：记录、间隙、临键和插入意向锁"></a>4.2 行锁四兄弟：记录、间隙、临键和插入意向锁</h3><h4 id="4-2-1-记录锁"><a href="#4-2-1-记录锁" class="headerlink" title="4.2.1 记录锁"></a>4.2.1 记录锁</h4><p>记录锁（Record Locks）仅仅锁住索引记录的一行，在单条索引记录上加锁。记录锁锁住的永远是索引，而非记录本身，即使该表上没有任何显示索引，那么innodb会在后台创建一个隐藏的聚簇索引索引，那么锁住的就是这个隐藏的聚簇索引索引。</p><p>举个栗子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 加记录读锁<br>select * from t1_simple where id = 1 lock in share mode;<br>-- 加记录写锁<br>select * from t1_simple where id = 1 for update;<br>-- 新增，修改，删除加记录写锁<br>insert into t1_simple values (2, 22);<br>update t1_simple set pubtime=33 where id =2;<br>delete from t1_simple where id =2<br></code></pre></td></tr></table></figure><h4 id="4-2-2-间隙锁"><a href="#4-2-2-间隙锁" class="headerlink" title="4.2.2 间隙锁"></a>4.2.2 间隙锁</h4><p>（1）间隙锁(Gap Locks)，仅仅锁住一个索引区间（开区间，不包括双端端点）。</p><p>（2）在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。</p><p>（3）间隙锁可用于防止幻读，保证索引间隙不会被插入数据</p><p><strong>主键id索引的行锁区间划分图：</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249338.jpeg"></p><p>session1执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">begin;<br>select * from t1_simple where id &gt; 4 for update;<br>commit;<br></code></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t1_simple values (7,100); -- 阻塞<br>insert into t1_simple values (3,100); -- 成功<br></code></pre></td></tr></table></figure><h4 id="4-2-3-临键锁"><a href="#4-2-3-临键锁" class="headerlink" title="4.2.3 临键锁"></a>4.2.3 临键锁</h4><p>（1）临键锁(Next-Key Locks)相当于记录锁 + 间隙锁【左开右闭区间】，例如（5,8]</p><p>（2）默认情况下，innodb使用临键锁来锁定记录，但在不同的场景中会退化</p><p>（3）当查询的索引含有唯一属性的时候，临键锁会进行优化，将其降级为记录锁，即仅锁住索引本身，不是范围。</p><p><strong>普通索引index(pubtime)行锁的区间划分图：</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249263.jpeg"></p><table><thead><tr><th><strong>场景</strong></th><th><strong>退化成的锁类型</strong></th></tr></thead><tbody><tr><td>使用Unique index 精确匹配【&#x3D;】，且记录存在</td><td>记录锁</td></tr><tr><td>使用Unique index 精确匹配【&#x3D;】，且记录不存在</td><td>间隙锁</td></tr><tr><td>使用Unique index 范围匹配【&lt;和&gt;】</td><td>临键锁</td></tr></tbody></table><p>当前数据库中的记录信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t1_simple;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249956.jpeg"></p><p>session1执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">begin;<br>select * from t1_simple where pubtime = 20 for update;<br>-- 临键锁区间(10,20],(20,100]<br></code></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t1_simple values (16, 19); -- 阻塞<br>select * from t1_simple where pubtime = 20 for update; -- 阻塞<br>insert into t1_simple values (16, 50); -- 阻塞<br>insert into t1_simple values (16, 101); -- 成功<br></code></pre></td></tr></table></figure><h4 id="4-2-4-插入意向锁"><a href="#4-2-4-插入意向锁" class="headerlink" title="4.2.4 插入意向锁"></a>4.2.4 插入意向锁</h4><p>（1）插入意向锁(Insert Intention Locks)是一种间隙锁，不是意向锁，在insert操作时产生。</p><p>（2）在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。</p><p>（3）假设有一个记录索引包含键值10和100，不同的事务分别插入60和70，每个事务都会产生一个加在10-100之间的插入意向锁，获取在插入行上的写锁，但是不会被互相锁住，因为数据行并不冲突。</p><p>（4）插入意向锁不会阻止任何锁，对于插入的记录会持有一个记录锁。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249334.jpeg"></p><h3 id="4-3-加锁规则【非常重要】"><a href="#4-3-加锁规则【非常重要】" class="headerlink" title="4.3 加锁规则【非常重要】"></a>4.3 加锁规则【非常重要】</h3><p><strong>主键索引</strong></p><ul><li>等值条件，命中，加记录锁</li><li>等值条件，未命中，加间隙锁</li><li>范围条件，命中，包含where条件的临键区间，加临键锁</li><li>范围条件，没有命中，加间隙锁</li></ul><p><strong>辅助索引</strong></p><ul><li>等值条件，命中，命中记录的辅助索引项 + 主键索引项加记录锁，辅助索引项两侧加间隙锁</li><li>等值条件，未命中，加间隙锁</li><li>范围条件，命中，包含where条件的临键区间加临键锁。命中记录的id索引项加记录锁</li><li>范围条件，没有命中，加间隙锁</li></ul><h3 id="4-4-意向锁"><a href="#4-4-意向锁" class="headerlink" title="4.4 意向锁"></a>4.4 意向锁</h3><h4 id="1）什么是意向锁？相当于存储引擎级别的表锁"><a href="#1）什么是意向锁？相当于存储引擎级别的表锁" class="headerlink" title="1）什么是意向锁？相当于存储引擎级别的表锁"></a>1）什么是意向锁？相当于存储引擎级别的表锁</h4><p>InnoDB也实现了表级锁，也就是意向锁【Intention Locks】。意向锁是MySQL内部使用的，不需要用户干预。<strong>意向锁和行锁可以共存</strong>，意向锁的主要作用是为了<strong>全表更新数据时的提升性能</strong>。否则在全表更新数据时，需要先检索该范是否某些记录上面有行锁。那么将是一件非常繁琐且耗时操作。</p><p><strong>举个栗子：</strong></p><p>事务A修改user表的记录r，会给记录r上一把行级的写锁，同时会给user表上一把意向写锁（IX），这时事务B要给user表上一个表级的写锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存，且满足事务隔离性的要求。</p><p>当我们需要加一个写锁时，需要根据意向锁去判断表中有没有数据行被锁定；</p><p>（1）如果行锁，则需要遍历每一行数据去确认；</p><p>（2）如果表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。</p><h4 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h4><ul><li>表明：“某个事务正在某些行持有了锁、或该事务准备去持有锁”</li><li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存</li></ul><h4 id="3）意向锁和读锁【S锁】、写锁【X锁】的兼容关系"><a href="#3）意向锁和读锁【S锁】、写锁【X锁】的兼容关系" class="headerlink" title="3）意向锁和读锁【S锁】、写锁【X锁】的兼容关系"></a>3）意向锁和读锁【S锁】、写锁【X锁】的兼容关系</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249554.jpeg"></p><ul><li>意向锁相互兼容：因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。</li><li>表级S锁和X、IX锁不兼容：因为上了表级S锁后，不允许其他事务再加X锁。</li><li>表级X锁和 IS、IX、S、X不兼容：因为上了表级X锁后，会修改数据。</li></ul><blockquote><p>注意：上了行级写锁后，行级写锁不会因为有别的事务上了意向写锁而堵塞，一个MySQL是允许多个行级写锁同时存在的，只要他们不是针对相同的数据行</p></blockquote><h3 id="4-5-锁相关参数"><a href="#4-5-锁相关参数" class="headerlink" title="4.5 锁相关参数"></a>4.5 锁相关参数</h3><p>InnoDB所使用的<strong>行级锁定</strong>争用状态查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249968.jpeg"></p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；</li><li>Innodb_row_lock_time_avg：每次等待所花平均时间；</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；</li></ul><p>对于这5个状态变量，比较重要的主要是：</p><ul><li>Innodb_row_lock_time_avg（等待平均时长）</li><li>Innodb_row_lock_waits（等待总次数）</li><li>Innodb_row_lock_time（等待总时长）这三项。</li></ul><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p><p>查看事务、锁的sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看锁的SQL<br>select * from information_schema.innodb_locks;<br>select * from information_schema.innodb_lock_waits;<br># 查看事务SQL<br>select * from information_schema.innodb_trx;<br># 查看未关闭的事务详情<br>SELECT<br>a.trx_id,a.trx_state,a.trx_started,a.trx_query,<br>b.ID,b.USER,b.DB,b.COMMAND,b.TIME,b.STATE,b.INFO,<br>c.PROCESSLIST_USER,c.PROCESSLIST_HOST,c.PROCESSLIST_DB,d.SQL_TEXT<br>FROM<br>information_schema.INNODB_TRX a<br>LEFT JOIN information_schema.PROCESSLIST b ON a.trx_mysql_thread_id = b.id<br>AND b.COMMAND = &#x27;Sleep&#x27;<br>LEFT JOIN PERFORMANCE_SCHEMA.threads c ON b.id = c.PROCESSLIST_ID<br>LEFT JOIN PERFORMANCE_SCHEMA.events_statements_current d ON d.THREAD_ID =<br>c.THREAD_ID;<br></code></pre></td></tr></table></figure><h2 id="5-行锁分析实战"><a href="#5-行锁分析实战" class="headerlink" title="5. 行锁分析实战"></a>5. 行锁分析实战</h2><p>在介绍完一些背景知识之后，接下来将选择几个有代表性的例子，来详细分析MySQL的加锁处理。从最简单的例子说起，下面两条简单的SQL，他们加的什么锁？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- SQL1：<br>select * from t1 where id = 10;<br>-- SQL2：<br>delete from t1 where id = 10;<br></code></pre></td></tr></table></figure><p>针对这个问题，该怎么回答？</p><p>能想象到的一个答案是：</p><ul><li>SQL1：不加锁。因为MySQL是使用多版本并发控制的，读不加锁。</li><li>SQL2：对id &#x3D; 10的记录加写锁 (走主键索引)</li></ul><p>这个答案对吗？</p><p>说不上来。即可能是正确的，也有可能是错误的，已知条件不足，这个问题没有答案。必须还要知道以下的一些前提，前提不同，能给出的答案也就不同。要回答这个问题，还缺少哪些前提条件？</p><ul><li><strong>前提一：</strong>id列是不是主键？</li><li><strong>前提二：</strong>当前系统的隔离级别是什么？</li><li><strong>前提三：</strong>id列如果不是主键，那么id列上有索引吗？</li><li><strong>前提四：</strong>id列上如果有二级索引，那么这个索引是唯一索引吗？</li><li><strong>前提五：</strong>两个SQL的执行计划是什么？索引扫描？全表扫描？</li></ul><p>没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我们将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？</p><blockquote><p>注：下面的这些组合，需要做一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准！！！</p></blockquote><p><strong>读已提交【RC】隔离级别</strong></p><ul><li>组合一：id列是主键，</li><li>组合二：id列是二级唯一索引</li><li>组合三：id列是二级非唯一索引</li><li>组合四：id列上没有索引</li></ul><p><strong>可重复读【RR】隔离级别</strong></p><ul><li>组合五：id列是主键</li><li>组合六：id列是二级唯一索引</li><li>组合七：id列是二级非唯一索引</li><li>组合八：id列上没有索引</li></ul><p><strong>Serializable隔离级别</strong></p><p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？</p><p>事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。</p><h3 id="5-1-读已提交RC"><a href="#5-1-读已提交RC" class="headerlink" title="5.1 读已提交RC"></a>5.1 读已提交RC</h3><p>注：在前面八种组合下，也就是RC，RR隔离级别下SQL1：<strong>select操作均不加锁，采用的是快照读</strong>，因此在下面的讨论中就忽略了，<strong>主要讨论SQL2：delete操作的加锁。</strong></p><h4 id="1）组合一：id主键"><a href="#1）组合一：id主键" class="headerlink" title="1）组合一：id主键"></a>1）组合一：id主键</h4><p>这个组合，是最简单，最容易分析的组合。<strong>id是主键，RC隔离级别</strong>，给定SQL： <code>delete from t1 where id = 10</code> ; 只需要将主键上id &#x3D; 10的记录加上写锁即可。如下图所示：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249139.jpeg"></p><p><strong>结论</strong>：id是主键时，此SQL只需要在id&#x3D;10这条记录上加写锁即可。</p><h4 id="2）组合二：id唯一索引"><a href="#2）组合二：id唯一索引" class="headerlink" title="2）组合二：id唯一索引"></a>2）组合二：id唯一索引</h4><p>这个组合，<strong>id不是主键，而是一个Unique的二级索引键值</strong>。那么在RC隔离级别下，<code>delete from t1where id = 10</code>; 需要加什么锁呢？</p><p>见下图：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249318.jpeg"></p><p>此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id&#x3D;10的记录后，首先会将unique索引上的id&#x3D;10索引记录加上<strong>写锁</strong>，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name &#x3D; ‘d’ 对应的主键索引项加<strong>写锁</strong>。</p><p><strong>为什么聚簇索引上的记录也要加锁？</strong></p><p>试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id &#x3D; 100 where name &#x3D; ‘a’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新&#x2F;删除需要串行执行的约束。</p><p><strong>结论</strong>：若id列是unique列，其上有unique索引。那么SQL需要加两个<strong>写锁</strong>，一个对应于id unique索引上的id &#x3D; 10的记录，另一把锁对应于聚簇索引上的【name&#x3D;’d’,id&#x3D;10】的记录。</p><h4 id="3）组合三：id非唯一索引"><a href="#3）组合三：id非唯一索引" class="headerlink" title="3）组合三：id非唯一索引"></a>3）组合三：id非唯一索引</h4><p>相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id &#x3D; 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？</p><p>同样见下图：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240249132.jpeg"></p><p>根据此图，可以看到，首先，id列索引上，满足id &#x3D; 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p><p><strong>结论</strong>：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p><h4 id="4）组合四：id无索引"><a href="#4）组合四：id无索引" class="headerlink" title="4）组合四：id无索引"></a>4）组合四：id无索引</h4><p>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id &#x3D; 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。</p><p>对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？</p><p>这个答案也有很多：有人说会在表上加<strong>写锁</strong>；有人说会将聚簇索引上，选择出来的id &#x3D; 10;的记录加上<strong>写锁</strong>。那么实际情况呢？</p><p>请看下图：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250399.jpeg"></p><p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了<strong>写锁</strong>。无论记录是否满足条件，全部被加上<strong>写锁</strong>。既不是加表锁，也不是在满足条件的记录上加行锁。</p><p>有人可能会问？为什么不是只在满足条件的记录上加锁呢？</p><p>这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。</p><blockquote><p>注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p></blockquote><p><strong>结论：</strong>若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上<strong>写锁</strong>。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁&#x2F;放锁动作不会省略。</p><p>上面的四个组合，都是在RC隔离级别下的加锁行为，接下来的四个组合，是在RR隔离级别下的加锁行为。</p><h3 id="5-2-可重复RR"><a href="#5-2-可重复RR" class="headerlink" title="5.2 可重复RR"></a>5.2 可重复RR</h3><h4 id="1）组合五：id主键"><a href="#1）组合五：id主键" class="headerlink" title="1）组合五：id主键"></a>1）组合五：id主键</h4><p>与组合一是一致的</p><h4 id="2）组合六：id唯一索引"><a href="#2）组合六：id唯一索引" class="headerlink" title="2）组合六：id唯一索引"></a>2）组合六：id唯一索引</h4><p>与组合二是一致的</p><h4 id="3）组合七：id非唯一索引"><a href="#3）组合七：id非唯一索引" class="headerlink" title="3）组合七：id非唯一索引"></a>3）组合七：id非唯一索引</h4><p><strong>还记得MySQL的四种隔离级别的区别吗？</strong></p><ul><li><strong>RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。</strong></li></ul><p><strong>那么RR隔离级别下，如何防止幻读呢？</strong></p><p>看下面这幅图：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250577.jpeg"></p><p>相对于组合三最大的区别在于，组合七中多了一个间隙锁。<strong>其实这个多出来的间隙锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。</strong></p><p>所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id &#x3D; 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。记录本身的一致性是可重复性，使用MVCC来解决。</p><p><strong>如何保证两次当前读返回一致的记录？</strong>那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，间隙锁应运而生。</p><p><strong>结论：</strong></p><p>RR隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id &#x3D; 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的写锁，加GAP上的间隙锁，然后加主键聚簇索引上的记录写锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录写锁，但是仍旧需要加间隙锁，最后返回结束。</p><h4 id="4）组合八：id无索引"><a href="#4）组合八：id无索引" class="headerlink" title="4）组合八：id无索引"></a>4）组合八：id无索引</h4><p>组合八，RR隔离级别下的最后一种情况，<strong>id列上没有索引</strong>。此时**SQL：delete from t1 where id &#x3D; 10;**没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250071.jpeg"></p><p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了<strong>写锁</strong>。其次，聚簇索引每条记录间的间隙，也同时被加上了间隙锁。这个示例表，只有6条记录，一共需要6个记录锁，7个间隙锁。试想，如果表上有1000万条记录呢？</p><p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p><p>当然，跟组合四类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semiconsistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加间隙锁。</p><p><strong>semi-consistent read</strong>如何触发？要么是RC隔离级别；要么是RR隔离级别，同时设置了<strong>innodb_locks_unsafe_for_binlog</strong> 参数。</p><p><strong>结论：</strong>在RR隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有间隙，杜绝所有的并发 更新&#x2F;删除&#x2F;插入 操作。当然，也可以通过触发semi-consistentread，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p><h3 id="5-3-串行化Serializable"><a href="#5-3-串行化Serializable" class="headerlink" title="5.3 串行化Serializable"></a>5.3 串行化Serializable</h3><p>对于SQL2来说，Serializable隔离级别与RR隔离级别组合八情况完全一致，因此不做介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from t1 where id = 10<br></code></pre></td></tr></table></figure><p>Serializable隔离级别，影响的是SQL1这条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t1 where id = 10<br></code></pre></td></tr></table></figure><p>在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，<strong>MVCC</strong>并发控制降级为<strong>LBCC</strong>。</p><p><strong>结论：</strong></p><p>在MySQL&#x2F;InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p><h3 id="5-4-复杂SQL加锁分析"><a href="#5-4-复杂SQL加锁分析" class="headerlink" title="5.4 复杂SQL加锁分析"></a>5.4 复杂SQL加锁分析</h3><p>再来看一个稍微复杂点的SQL，用于说明MySQL加锁的另外一个逻辑。</p><p>SQL用例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from t1 where pubtime &gt; 1 and pubtime &lt; 20 and userid=&#x27;hero&#x27; and commit is not null;<br></code></pre></td></tr></table></figure><p><strong>如图中的SQL，会加什么锁？</strong></p><p>假定在RR隔离级别下，同时，假设SQL走的是idx_t1_pu（pubtime，userid）索引</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250227.jpeg"></p><p>在详细分析这条SQL的加锁情况前，还需要有一个知识储备，那就是一个SQL中的where条件如何拆分？</p><p>在这里，我直接给出分析后的结果：</p><ul><li><strong>Index key</strong>：pubtime &gt; 1 and puptime &lt; 20。此条件，用于确定SQL在idx_t1_pu索引上的查询范围。</li><li><strong>Index Filter</strong>：userid &#x3D; ‘hero’ 。此条件，可以在idx_t1_pu索引上进行过滤，但不属于IndexKey。</li><li><strong>Table Filter</strong>：comment is not NULL。此条件，在idx_t1_pu索引上无法过滤，只能在SQL-Layer上过滤。</li></ul><p>在分析出SQL where条件的构成之后，再来看看这条SQL的加锁情况 （默认隔离级别RR）</p><p>如下图所示：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250630.jpeg"></p><p>从图中可以看出，在RR隔离级别下，由Index Key所确定的范围，被加上了间隙锁；Index Filter锁给定的条件视MySQL的版本而定【图中，用红色箭头标出的写锁是否要加，与ICP有关】</p><ul><li>不支持ICP，因此Index Filter在MySQL Server层过滤，不满足Index Filter的记录，也需要加上记录写锁；</li><li>支持了ICP，则在index上过滤，则不满足Index Filter的记录，无需加记录写锁；</li></ul><p>而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要写锁。最后，选取出了一条满足条件的记录 [8，hero,d,5,handsome] ，但是加锁的数量，要远远大于满足条件的记录数量。</p><p><strong>结论：</strong></p><p>在RR隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。</p><ul><li>Index Key确定的范围，需要加上间隙锁；</li><li>Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足Index Filter的记录，不加写锁，否则需要写锁；</li><li>Table Filter过滤条件，无论是否满足，都需要加写锁。</li></ul><h2 id="6-死锁原理"><a href="#6-死锁原理" class="headerlink" title="6. 死锁原理"></a>6. 死锁原理</h2><p>深入理解MySQL如何加锁，有两个比较重要的作用：</p><ul><li>可以根据MySQL的加锁规则，写出不会发生死锁的SQL；</li><li>可以根据MySQL的加锁规则，定位出线上产生死锁的原因；</li><li>可以根据MySQL的加锁规则，透过现象看本质，理解数据库层 面 阻塞执行的根本原因</li></ul><h3 id="6-1-什么是死锁？"><a href="#6-1-什么是死锁？" class="headerlink" title="6.1 什么是死锁？"></a>6.1 什么是死锁？</h3><h4 id="情况01"><a href="#情况01" class="headerlink" title="情况01"></a>情况01</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t1_deadlock` (<br>`id` int(11) NOT NULL,<br>`name` varchar(100) DEFAULT NULL,<br>`age` int(11) NOT NULL,<br>`address` varchar(255) DEFAULT NULL,<br>PRIMARY KEY (`id`),<br>KEY `idx_age` (`age`) USING BTREE,<br>KEY `idx_name` (`name`) USING BTREE<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;<br>Insert into t1_deadlock(id,name,age,address) values (1,&#x27;刘备&#x27;,18,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (2,&#x27;关羽&#x27;,17,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (3,&#x27;张飞&#x27;,16,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (4,&#x27;关羽&#x27;,16,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (5,&#x27;诸葛亮&#x27;,35,&#x27;蜀国&#x27;);<br>Insert into t1_deadlock(id,name,age,address) values (6,&#x27;曹孟德&#x27;,32,&#x27;魏国&#x27;);<br></code></pre></td></tr></table></figure><p>下面，来看看两个死锁的例子 <strong>一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁</strong>：</p><table><thead><tr><th>时间</th><th><strong>session01</strong></th><th><strong>session02</strong></th></tr></thead><tbody><tr><td>T1</td><td>begin;</td><td>begin;</td></tr><tr><td>T2</td><td>select * from t1_deadlock where id&#x3D;1 for<br/>update;</td><td></td></tr><tr><td>T3</td><td></td><td>delete from t1_deadlock where<br/>id&#x3D;5;</td></tr><tr><td>T4</td><td>update t1_deadlock set name&#x3D;’qqq’ where<br/>id&#x3D;5;</td><td></td></tr><tr><td>T5</td><td>死锁</td><td>delete from t1_deadlock where<br/>id&#x3D;1;</td></tr><tr><td>T6</td><td>commit;</td><td>commit;</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250569.jpeg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- Session01<br>begin;<br>select * from t1_deadlock where id=1 for update;<br>update t1_deadlock set name=&#x27;qqq&#x27; where id=5;<br>commit;<br>-- Session02<br>begin;<br>delete from t1_deadlock where id=5;<br>delete from t1_deadlock where id=1;<br>-- 死锁<br>commit;<br></code></pre></td></tr></table></figure><h4 id="情况02"><a href="#情况02" class="headerlink" title="情况02"></a>情况02</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240250050.jpeg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t1_deadlock03` (<br>`id` int(11) NOT NULL AUTO_INCREMENT,<br>`cnt` varchar(32) DEFAULT NULL,<br>PRIMARY KEY (`id`),<br>UNIQUE index `idx_cnt` (`cnt`) USING BTREE<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;<br>insert into t1_deadlock03(id,cnt) values (1,&#x27;abc-130-sz&#x27;);<br>select * from t1_deadlock03<br>-- Session01<br>begin;<br>delete from t1_deadlock03 where cnt=&#x27;abc-130-sz&#x27;;<br>insert into t1_deadlock03(cnt) values (&#x27;abc-130-sz&#x27;);<br>commit;<br>-- Session01<br>begin;<br>delete from t1_deadlock03 where cnt=&#x27;abc-130-sz&#x27;;<br>commit;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>死锁的发生与否，并不在于事务中有多少条SQL语句，【<strong>死锁的关键在于</strong>】：两个(或以上)的Session【加锁的顺序】不一致。</p><p>查询最近一次死锁日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW ENGINE INNODB STATUS;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs perl">------------------------<br>LATEST DETECTED DEADLOCK<br>------------------------<br><span class="hljs-number">2022</span>-<span class="hljs-number">10</span>-<span class="hljs-number">21</span> <span class="hljs-number">22</span>:<span class="hljs-number">31</span>:09 <span class="hljs-number">0x7ff508111700</span><br>*** (<span class="hljs-number">1</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">6083</span>, ACTIVE <span class="hljs-number">5</span> sec starting <span class="hljs-keyword">index</span> <span class="hljs-keyword">read</span><br>mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br>LOCK WAIT <span class="hljs-number">2</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">1</span> row lock(s)<br>MySQL thread id <span class="hljs-number">690</span>, OS thread handle <span class="hljs-number">140690379863808</span>, query id <span class="hljs-number">4831</span><br><span class="hljs-number">192.168</span>.<span class="hljs-number">200.1</span> root updating<br><span class="hljs-keyword">delete</span> from t1_deadlock03 where cnt =<span class="hljs-string">&#x27;abc-130-sz&#x27;</span><br>*** (<span class="hljs-number">1</span>) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">92</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> idx_cnt of table<br><span class="hljs-string">`hello`</span>.<span class="hljs-string">`t1_deadlock03`</span> trx id <span class="hljs-number">6083</span> lock_mode X waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> PHYSICAL RECORD: n_fields <span class="hljs-number">2</span>; compact <span class="hljs-keyword">format</span>; info<br>bits <span class="hljs-number">32</span><br><span class="hljs-number">0</span>: len <span class="hljs-number">10</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">6162632</span>d3133302d737a; asc abc-<span class="hljs-number">130</span>-sz;;<br><span class="hljs-number">1</span>: len <span class="hljs-number">4</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">80000002</span>; asc ;;<br>*** (<span class="hljs-number">2</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">6078</span>, ACTIVE <span class="hljs-number">8</span> sec inserting<br>mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br><span class="hljs-number">4</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">3</span> row lock(s), undo <span class="hljs-keyword">log</span> entries <span class="hljs-number">2</span><br>MySQL thread id <span class="hljs-number">696</span>, OS thread handle <span class="hljs-number">140690379052800</span>, query id <span class="hljs-number">4835</span><br><span class="hljs-number">192.168</span>.<span class="hljs-number">200.1</span> root update<br>insert into t1_deadlock03(cnt) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;abc-130-sz&#x27;</span>)<br>*** (<span class="hljs-number">2</span>) HOLDS THE LOCK(S):<br>RECORD LOCKS space id <span class="hljs-number">92</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> idx_cnt of table<br><span class="hljs-string">`hello`</span>.<span class="hljs-string">`t1_deadlock03`</span> trx id <span class="hljs-number">6078</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> PHYSICAL RECORD: n_fields <span class="hljs-number">2</span>; compact <span class="hljs-keyword">format</span>; info<br>bits <span class="hljs-number">32</span><br><span class="hljs-number">0</span>: len <span class="hljs-number">10</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">6162632</span>d3133302d737a; asc abc-<span class="hljs-number">130</span>-sz;;<br><span class="hljs-number">1</span>: len <span class="hljs-number">4</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">80000002</span>; asc ;;<br>*** (<span class="hljs-number">2</span>) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">92</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> idx_cnt of table<br><span class="hljs-string">`hello`</span>.<span class="hljs-string">`t1_deadlock03`</span> trx id <span class="hljs-number">6078</span> lock mode S waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> PHYSICAL RECORD: n_fields <span class="hljs-number">2</span>; compact <span class="hljs-keyword">format</span>; info<br>bits <span class="hljs-number">32</span><br><span class="hljs-number">0</span>: len <span class="hljs-number">10</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">6162632</span>d3133302d737a; asc abc-<span class="hljs-number">130</span>-sz;;<br><span class="hljs-number">1</span>: len <span class="hljs-number">4</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">80000002</span>; asc ;;<br>*** WE ROLL BACK TRANSACTION (<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="6-2-如何避免死锁呢？"><a href="#6-2-如何避免死锁呢？" class="headerlink" title="6.2 如何避免死锁呢？"></a>6.2 如何避免死锁呢？</h3><p>MySQL默认会主动探知死锁，并回滚某一个影响最小的事务。等另一事务执行完成之后，再重新执行该事务。</p><ol><li><p>注意程序的逻辑：根本的原因是程序逻辑的顺序交叠，最常见的是交差更新</p></li><li><p>保持事务的轻量：越是轻量的事务，占有越少的锁资源，这样发生死锁的几率就越小</p></li><li><p>提高运行的速度：避免使用子查询，尽量使用主键等等</p></li><li><p>尽量快提交事务，减少持有锁的时间：越早提交事务，锁就越早释放</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MySQL</category>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务篇</title>
    <link href="/2022/04/03/MySQL%E4%BA%8B%E5%8A%A1%E7%AF%87/"/>
    <url>/2022/04/03/MySQL%E4%BA%8B%E5%8A%A1%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL事务篇"><a href="#MySQL事务篇" class="headerlink" title="MySQL事务篇"></a><strong>MySQL事务篇</strong></h1><h2 id="一、一条Insert语句"><a href="#一、一条Insert语句" class="headerlink" title="一、一条Insert语句"></a>一、一条Insert语句</h2><p>为了故事的顺利发展，我们需要创建一个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tab_user` (<br>`id` int(11) NOT NULL,<br>`name` varchar(100) DEFAULT NULL,<br>`age` int(11) NOT NULL,<br>`address` varchar(255) DEFAULT NULL,<br>PRIMARY KEY (`id`)<br>) ENGINE=InnoDB;<br></code></pre></td></tr></table></figure><p>然后向这个表里插入一条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Insert into tab_user(id,name,age,address) values (1,&#x27;刘备&#x27;,18,&#x27;蜀国&#x27;);<br></code></pre></td></tr></table></figure><h2 id="二、Insert语句执行流程"><a href="#二、Insert语句执行流程" class="headerlink" title="二、Insert语句执行流程"></a>二、Insert语句执行流程</h2><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253782.png" alt="图片1"></p><h2 id="三、事务回顾"><a href="#三、事务回顾" class="headerlink" title="三、事务回顾"></a>三、事务回顾</h2><p><strong>事务指的是逻辑上的一组操作，组成这组操作的各个单元要么全都成功，要么全都失败。</strong></p><p><strong>事务作用：保证在一个事务中多次SQL操作要么全都成功，要么全都失败。</strong></p><p><code>MySQL</code> 是一个服务器／客户端架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（ Session ）。我们可以同时在不同的会话里输入各种语句，这些语句可以作为事务的一部分进行处理。不同的会话可以同时发送请求，也就是说服务器可能同时在处理多个事务，这样子就会导致不同的事务可能同时访问到相同的记录。</p><p>事务的<strong>隔离性</strong>在理论上是指，在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样子的话对性能影响太大，所以才会出现各种<strong>隔离</strong>级别，来最大限度的提升系统并发处理事务的能力，牺牲部分<strong>隔离性</strong>来提升性能。</p><p>事务是数据库最为重要的机制之一，凡是使用过数据库的人，都了解数据库的事务机制，也对ACID四个基本特性如数家珍。但是聊起事务或者ACID的底层实现原理，往往言之不详，不明所以。所以接下来我们深入分析事务的原理。</p><p>由于在<strong>MySQL</strong>中的事务是由存储引擎实现，而且MySQL只有InnoDB支持事务。因此我们讲解<strong>InnoDB</strong>的事务。</p><h3 id="3-1-事务四大特性ACID"><a href="#3-1-事务四大特性ACID" class="headerlink" title="3.1 事务四大特性ACID"></a>3.1 事务四大特性ACID</h3><p>数据库事务具有ACID四大特性。ACID是以下4个词的缩写：</p><ul><li><strong>原子性（Atomicity）</strong>：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li><strong>一致性（Consistency）</strong>：事务前后数据的完整性必须保持一致</li><li><strong>隔离性（Isolation</strong>）：多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。隔离性由隔离级别保障！</li><li><strong>持久性（Durability）</strong>： 一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h3 id="3-2-事务并发问题"><a href="#3-2-事务并发问题" class="headerlink" title="3.2 事务并发问题"></a>3.2 事务并发问题</h3><ol><li><p>脏读：一个事务读到了另一个事务<strong>未提交</strong>的数据</p></li><li><p>不可重复读：一个事务读到了另一个事务<strong>已经提交</strong>(update)的数据。引发事务中的多次查询结果不一致</p></li><li><p>虚读 &#x2F;幻读：一个事务读到了另一个事务已经**插入(insert)**的数据。导致事务中多次查询的结果不一致</p></li><li><p><strong>丢失更新的问题！</strong></p></li></ol><h3 id="3-3-隔离级别"><a href="#3-3-隔离级别" class="headerlink" title="3.3 隔离级别"></a>3.3 隔离级别</h3><ul><li><p><strong>read uncommitted</strong> 读未提交【RU】，一个事务读到另一个事务没有提交的数据</p><ul><li>存在：3个问题（脏读、不可重复读、幻读）。</li></ul></li><li><p><strong>read committed</strong> 读已提交【RC】，一个事务读到另一个事务已经提交的数据</p><ul><li>存在：2个问题（不可重复读、幻读）。</li><li>解决：1个问题（脏读）</li></ul></li><li><p><strong>repeatable read</strong>:可重复读【RR】，在一个事务中读到的数据始终保持一致，无论另一个事务是否提交</p><ul><li>解决：3个问题（脏读、不可重复读、幻读）</li></ul></li><li><p><strong>serializable</strong> <strong>串行化</strong>，同时只能执行一个事务，相当于事务中的单线程</p><ul><li>解决：3个问题（脏读、不可重复读、幻读）</li></ul></li></ul><p>安全和性能对比</p><ul><li>安全性： <code>serializable &gt; repeatable read &gt; read committed &gt; read uncommitted</code></li><li>性能 ： <code>serializable &lt; repeatable read &lt; read committed &lt; read uncommitted</code></li></ul><p>常见数据库的默认隔离级别：</p><ul><li>MySql： <code>repeatable read</code></li><li>Oracle：<code> read committed</code></li></ul><h2 id="四、事务底层原理详解"><a href="#四、事务底层原理详解" class="headerlink" title="四、事务底层原理详解"></a>四、事务底层原理详解</h2><h3 id="4-1-丢失更新问题"><a href="#4-1-丢失更新问题" class="headerlink" title="4.1 丢失更新问题"></a>4.1 丢失更新问题</h3><p>两个事务针对同一数据进行修改操作时会丢失更新，这个现象称之为丢失更新问题</p><p>举个栗子：管理者查询所有用户的存款总额，假设除了用户01和用户01之外，其他用户的存款都为0，用户01、02各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户01会向用户02进行转账操作。</p><p>转账和查询总额操作的时序图如下：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253576.png" alt="图片2"></p><h3 id="4-2-解决方案"><a href="#4-2-解决方案" class="headerlink" title="4.2 解决方案"></a>4.2 解决方案</h3><h4 id="4-2-1-解决方案一：基于锁并发控制LBCC"><a href="#4-2-1-解决方案一：基于锁并发控制LBCC" class="headerlink" title="4.2.1 解决方案一：基于锁并发控制LBCC"></a>4.2.1 解决方案一：基于锁并发控制LBCC</h4><p>使用基于锁的并发控制LBCC（Lock Based Concurrency Control）可以解决上述问题。</p><p>查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253246.png" alt="图片3"></p><p>这种方案比较简单粗暴，就是一个事务去读取一条数据的时候，就上锁，不允许其他事务来操作。假如当前事务只是加<strong>读锁</strong>，那么其他事务就不能有<strong>写锁</strong>，也就是不能修改数据；而假如当前事务需要加<strong>写</strong>锁，那么其他事务就不能持有任何锁。总而言之，能加锁成功，就确保了除了当前事务之外，其他事务不会对当前数据产生影响，所以自然而然的，当前事务读取到的数据就只能是<strong>最新</strong>的，而不会是<strong>快照</strong>数据。</p><blockquote><p>关于锁，会在锁篇详细讲解</p></blockquote><h4 id="4-2-2-解决方案二：基于版本并发控制MVCC"><a href="#4-2-2-解决方案二：基于版本并发控制MVCC" class="headerlink" title="4.2.2 解决方案二：基于版本并发控制MVCC"></a>4.2.2 解决方案二：基于版本并发控制MVCC</h4><p>当然使用版本的并发控制MVCC（Multi Version Concurrency Control）机制也可以解决这个问题。</p><p>查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的副本数据【快照数据】。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253691.png" alt="图片4"></p><p><strong>MVCC使得普通的SELECT请求不加锁，读写不冲突，显著提高了数据库的并发处理能力</strong>。MVCC保障了ACID中的隔离性，究竟怎么实现？接下来看</p><h3 id="4-3-MVCC实现原理【InnoDB】"><a href="#4-3-MVCC实现原理【InnoDB】" class="headerlink" title="4.3 MVCC实现原理【InnoDB】"></a>4.3 MVCC实现原理【InnoDB】</h3><p>首先来看一下MVCC的定义：</p><blockquote><p><strong>Multiversion concurrency control (MVCC)</strong> is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.</p></blockquote><p><strong>MVCC全称叫多版本并发控制，是RDBMS常用的一种并发控制方法，用来对数据库数据进行并发访问，实现事务。</strong>。核心思想是<strong>读不加锁，读写不冲突</strong>。在读多写少的OLTP应用中，读写不冲突非常重要，极大的增加了系统的并发性能，这也是为什么几乎所有的RDBMS，都支持MVCC的原因。</p><p>MVCC 实现原理是数据快照，不同的事务访问不同版本的数据快照，从而实现事务下对数据的隔离级别。虽然说具有多个版本的数据快照，但这并不意味着必须拷贝数据，保存多份数据文件（这样会浪费存储空间），InnoDB通过事务的Undo日志巧妙地实现了多版本的数据快照。</p><p>MVCC 的实现依赖与<strong>Undo日志</strong> 与 <strong>Read View</strong> 。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253477.png" alt="图片5"></p><p>InnoDB下的表有<strong>默认字段</strong>和<strong>可见字段</strong>，默认字段是实现MVCC的关键，默认字段是隐藏的列。默认字段最关键的两个列，<strong>一个保存了行的事务ID，一个保存了行的回滚指针</strong>。每开始新的事务，都会自动递增产生一个新的事务id。事务开始后，生成当前事务影响行的ReadView。当查询时，需要用当前查询的事务id与ReadView确定要查询的数据版本。</p><h4 id="4-3-1-Undo日志"><a href="#4-3-1-Undo日志" class="headerlink" title="4.3.1 Undo日志"></a>4.3.1 Undo日志</h4><p>Redo日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。但是事务有时还需要进行回滚操作，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生Redo，还会产生一定量的Undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条Rollback语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。在多事务读取数据时，有了Undo日志可以做到读不加锁，读写不冲突。</p><p>Undo存放在数据库内部的一个特殊段（segment）中，这个段称为Undo段（undo segment）。Undo段位于系统表空间内，也可以设置为Undo表空间。</p><p>Undo日志保存了记录修改前的快照。所以，对于更新和删除操作，InnoDB并不是真正的删除原来的记录，而是设置记录的delete mark为1。因此为了解决数据Page和Undo日志膨胀问题，则需要回收机制进行清理Undo日志。</p><p>根据行为的不同Undo日志分为两种： <code>Insert Undo Log</code> 和 <code>Update Undo Log</code></p><h5 id="1）Insert-Undo日志：是在Insert操作中产生的Undo日志"><a href="#1）Insert-Undo日志：是在Insert操作中产生的Undo日志" class="headerlink" title="1）Insert Undo日志：是在Insert操作中产生的Undo日志"></a>1）Insert Undo日志：是在Insert操作中产生的Undo日志</h5><p>Insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 Insert Undo Log 可以在事务提交后直接删除而不需要进行回收操作。</p><p>如下图所示（初始状态）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 事务1：<br>Insert into tab_user(id,name,age,address) values (10,&#x27;麦麦&#x27;,23,&#x27;beijing&#x27;)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253723.png" alt="图片6"></p><h5 id="2）Update-Undo日志：是Update或Delete操作中产生的Undo日志"><a href="#2）Update-Undo日志：是Update或Delete操作中产生的Undo日志" class="headerlink" title="2）Update Undo日志：是Update或Delete操作中产生的Undo日志"></a>2）Update Undo日志：是Update或Delete操作中产生的Undo日志</h5><p>Update操作会对已经存在的行记录产生影响，为了实现MVCC多版本并发控制机制，因此Update Undo日志不能在事务提交时就删除，而是在事务提交时将日志放入指定区域，等待 Purge 线程进行最后的删除操作。</p><p>如下图所示（第一次修改）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 事务2：<br>update tab_user set name=&#x27;雄雄&#x27;,age=18 where id=10;<br># 当事务2使用Update语句修改该行数据时，会首先使用写锁锁定目标行，将该行当前的值复制到Undo中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向Undo中修改前的行。<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253133.png" alt="图片7"></p><p><strong>当事务3进行修改与事务2的处理过程类似，如下图所示（第二次修改）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 事务3：<br>update tab_user set name=&#x27;迪迪&#x27;,age=16 where id=10;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253249.png" alt="图片8"></p><h4 id="4-3-2-ReadView日志"><a href="#4-3-2-ReadView日志" class="headerlink" title="4.3.2 ReadView日志"></a>4.3.2 ReadView日志</h4><p><strong>MVCC的核心问题就是：判断一下版本链中的哪个版本是当前事务可见的！</strong></p><ul><li>对于使用 <code>RU</code> 隔离级别的事务来说，直接读取记录的最新版本就好了，不需要Undo log。</li><li>对于使用 <code>串行化 </code>隔离级别的事务来说，使用加锁的方式来访问记录，不需要Undo log。</li><li>对于使用 <code>RC</code> 和 <code>RR</code> 隔离级别的事务来说，需要用到undo log的版本链。</li></ul><h5 id="1）什么是ReadView？"><a href="#1）什么是ReadView？" class="headerlink" title="1）什么是ReadView？"></a>1）什么是ReadView？</h5><p>ReadView是张存储事务id的表，主要包含当前系统中有哪些活跃的读写事务，把它们的事务id放到一个列表中。结合Undo日志的默认字段【事务trx_id】来控制那个版本的Undo日志可被其他事务看见。</p><p>四个列：</p><ul><li><strong>m_ids</strong>：表示在生成ReadView时，当前系统中<strong>活跃的读写事务id列表</strong></li><li><strong>m_low_limit_id</strong>：事务id下限，表示当前系统中活跃的读写事务中最小的事务id，m_ids事务列表中的最小事务id</li><li><strong>m_up_limit_id</strong>：事务id上限，表示生成ReadView时，系统中应该分配给下一个事务的id值</li><li><strong>m_creator_trx_id</strong>：表示生成该ReadView的事务的事务id</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253674.png" alt="image-20230423012445524"></p><h5 id="2）ReadView怎么产生，什么时候生成？"><a href="#2）ReadView怎么产生，什么时候生成？" class="headerlink" title="2）ReadView怎么产生，什么时候生成？"></a>2）ReadView怎么产生，什么时候生成？</h5><ul><li><p>开启事务之后，在第一次查询(select)时，生成ReadView</p></li><li><p><code>RC</code> 和 <code>RR</code> 隔离级别的差异本质是因为MVCC中ReadView的生成时机不同，详细生成时机在案例中分析</p></li></ul><h5 id="3）如何判断可见性？"><a href="#3）如何判断可见性？" class="headerlink" title="3）如何判断可见性？"></a>3）如何判断可见性？</h5><p>开启事务执行第一次查询时，首先生成ReadView，然后依据Undo日志和ReadView按照判断可见性，按照下边步骤判断记录的版本链的某个版本是否可见。</p><p><strong>循环判断规则如下：</strong></p><ul><li><p>如果被访问版本的 <code>trx_id</code> 属性值，小于ReadView中的<strong>事务下限id</strong>，表明生成该版本的事务在生成 <code>ReadView </code>前已经提交，所以该版本<strong>可以</strong>被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>属性值，等于ReadView中的 <code>m_creator_trx_id</code> ，<strong>可以</strong>被访问。</p></li><li><p>如果被访问版本的<code> trx_id</code> 属性值，大于等于ReadView中的<strong>事务上限id</strong>，在生成<code>ReadView</code>后才产生的数据，所以该版本<strong>不可以</strong>被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>属性值，在<strong>事务下限id</strong>和<strong>事务上限id</strong>之间，那就需要判断是不是在<code>m_ids </code>列表中。</p><ul><li><p>如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本<strong>不可以</strong>被访问；</p></li><li><p>如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本<strong>可以</strong>被访问。</p></li></ul></li></ul><p>循环判断Undo log中的版本链某一的版本是否对当前事务可见，如果循环到最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。</p><h4 id="4-3-3-ReadView案例分析"><a href="#4-3-3-ReadView案例分析" class="headerlink" title="4.3.3 ReadView案例分析"></a>4.3.3 ReadView案例分析</h4><h5 id="案例01-读已提交RC隔离级别下的可见性分析"><a href="#案例01-读已提交RC隔离级别下的可见性分析" class="headerlink" title="案例01-读已提交RC隔离级别下的可见性分析"></a>案例01-读已提交RC隔离级别下的可见性分析</h5><p>每次读取数据前都生成一个ReadView，默认tab_user表中只有一条数据，数据内容是刘备。</p><table><thead><tr><th>时<br/>间</th><th>事务01<br/>【db_trx_id&#x3D;100】</th><th>事务02<br/>【db_trx_id&#x3D;200】</th><th>事务03<br>【db_trx_id&#x3D;300】</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td>开启事务</td><td>开启事务</td></tr><tr><td>T2</td><td>更新为关羽</td><td>…</td><td>…</td></tr><tr><td>T3</td><td>更新为张飞</td><td>…</td><td>…</td></tr><tr><td>T4</td><td></td><td>更新为赵云</td><td></td></tr><tr><td>T5</td><td></td><td>更新为诸葛亮</td><td></td></tr><tr><td>T6</td><td></td><td></td><td>SELECT01，id&#x3D;1，name为刘备</td></tr><tr><td>T7</td><td>提交事务01</td><td></td><td></td></tr><tr><td>T8</td><td></td><td></td><td>SELECT02，id&#x3D;1，name为张飞</td></tr><tr><td>T9</td><td></td><td>提交事务02</td><td></td></tr><tr><td>T10</td><td></td><td></td><td>SELECT03，id&#x3D;1，name为诸葛亮</td></tr></tbody></table><blockquote><p>注意：事务id是递增的</p></blockquote><p>T3时刻，表 <code>tab_user</code> 中 <code>id</code> 为 <code>1 </code>的记录得到的版本链表如下所示：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253516.png" alt="image-20230423012527952"></p><p>这个 <code>SELECT01</code> 的执行过程如下：</p><ul><li><p>在执行<code>SELECT</code>语句时会先生成一个 <code>ReadView </code>， <code>m_ids</code> 列表的内容就是<code> [100, 200]</code> 。</p></li><li><p>然后从版本链中挑选可见的记录，从图中可以看出</p><ul><li><p>最新版本的列 <code>c </code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code> 100</code>，在 <code>m_ids</code> 列表内，所以不符合可见性要求，跳下一个版本。</p></li><li><p>下一个版本的列 <code>c</code> 的内容是 <code>&#39;关羽&#39;</code> ，该版本的 <code>trx_id</code> 值也为 <code>100</code> ，也在 <code>m_ids</code> 列表内，所以也不符合要求，跳下一个版本。</p></li><li><p>下一个版本的列 <code>c</code> 的内容是 <code>&#39;刘备&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>80</code> ，小于 <code>m_ids</code> 列表中最小的事务id <code>100</code> ，此版符合要求</p></li></ul></li><li><p>最后返回给用户的版本就是这条列 <code>c</code> 为 <code>&#39;刘备&#39;</code> 的记录。</p></li></ul><p>T5时刻，表 <code>tab_user</code> 中 <code>id</code> 为 <code>1</code> 的记录的版本链就长这样：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253075.png" alt="image-20230423012825070"></p><p>这个 <code>SELECT02</code> 的执行过程如下：</p><ul><li>在执行 <code>SELECT</code> 语句时会先生成一个 ReadView ， ReadView 的 <code>m_ids</code> 列表的内容就是 <code>[200]</code><ul><li>事务<code>id</code>为 <code>100</code> 的那个事务已经提交了，所以生成快照时就没有它了</li></ul></li><li>然后从版本链中挑选可见的记录，从图中可以看出<ul><li>最新版本的列 <code>c</code> 的内容是 <code>&#39;诸葛亮&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>200</code> ，在 <code>m_ids</code> 列表内，不符合可见性要求，跳下一个版本</li><li>下一个版本的列 <code>c</code> 的内容是 <code>&#39;赵云&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>200</code> ，也在 <code>m_ids</code> 列表内，不符合要求，跳下一个版本</li><li>下一个版本的列 <code>c</code> 的内容是 <code>&#39;张飞&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>100</code> ，比 <code>m_ids</code> 列表中最小的事务id <code>200</code> 还要小，此版符合要求</li></ul></li><li>最后返回给用户的版本就是这条列 <code>c</code> 为 <code>&#39;张飞&#39;</code> 的记录。</li></ul><p>以此类推，如果之后事务id为 <code>200</code> 的记录也提交了，再此在使用 <code>RC</code> 隔离级别的事务中查询表 <code>t</code> 中 <code>id</code> 值为 <code>1</code> 的记录时，得到的结果就是 <code>&#39;诸葛亮&#39;</code> 了，具体流程我们就不分析了。</p><p><strong>总结：使用RC隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tab_user` (<br>`id` int(11) NOT NULL,<br>`name` varchar(100) DEFAULT NULL,<br>`age` int(11) NOT NULL,<br>`address` varchar(255) DEFAULT NULL,<br>PRIMARY KEY (`id`)<br>) ENGINE=InnoDB;<br>Insert into tab_user(id,name,age,address) values (1,&#x27;刘备&#x27;,18,&#x27;蜀国&#x27;);<br></code></pre></td></tr></table></figure><p>案例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 事务01<br>-- 查询事务隔离级别：<br>select @@tx_isolation;<br>-- 设置数据库的隔离级别<br>set session transaction isolation level read committed;<br>SELECT * FROM tab_user; # 默认是刘备<br># Transaction 100<br>BEGIN;<br>UPDATE tab_user SET name = &#x27;关羽&#x27; WHERE id = 1;<br>UPDATE tab_user SET name = &#x27;张飞&#x27; WHERE id = 1;<br>COMMIT;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 事务02<br>-- 查询事务隔离级别：<br>select @@tx_isolation;<br>-- 设置数据库的隔离级别<br>set session transaction isolation level read committed;<br># Transaction 200<br>BEGIN;<br># 更新了一些别的表的记录<br>...<br>UPDATE tab_user SET name = &#x27;赵云&#x27; WHERE id = 1;<br>UPDATE tab_user SET name = &#x27;诸葛亮&#x27; WHERE id = 1;<br>COMMIT;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 事务03<br>-- 查询事务隔离级别：<br>select @@tx_isolation;<br>-- 设置数据库的隔离级别<br>set session transaction isolation level read committed;<br>BEGIN;<br># SELECT01：Transaction 100、200未提交<br>SELECT * FROM tab_user WHERE id = 1; # 得到的列c的值为&#x27;刘备&#x27;<br># SELECT02：Transaction 100提交，Transaction 200未提交<br>SELECT * FROM tab_user WHERE id = 1; # 得到的列c的值为&#x27;张飞&#x27;<br># SELECT03：Transaction 100、200提交<br>SELECT * FROM tab_user WHERE id = 1; # 得到的列c的值为&#x27;诸葛亮&#x27;<br>COMMIT;<br></code></pre></td></tr></table></figure><p>使用到的SQL小结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 开启事务：还有一种方式begin<br>start transaction<br>-- 提交事务：<br>commit<br>-- 回滚事务：<br>rollback<br>-- 查询事务隔离级别：<br>select @@tx_isolation;<br>-- 设置数据库的隔离级别<br>set session transaction isolation level read committed<br>-- 级别字符串：`read uncommitted`、`read committed`、`repeatable read【默认】`、`serializable`<br><br><br>-- 查看当前运行的事务<br>SELECT<br>    a.trx_id,a.trx_state,a.trx_started,a.trx_query,<br>    b.ID,b.USER,b.DB,b.COMMAND,b.TIME,b.STATE,b.INFO,<br>    c.PROCESSLIST_USER,c.PROCESSLIST_HOST,c.PROCESSLIST_DB, d.SQL_TEXT<br>FROM<br>    information_schema.INNODB_TRX a<br>LEFT JOIN information_schema.PROCESSLIST b ON a.trx_mysql_thread_id = b.id<br>AND b.COMMAND = &#x27;Sleep&#x27;<br>LEFT JOIN PERFORMANCE_SCHEMA.threads c ON b.id = c.PROCESSLIST_ID<br>LEFT JOIN PERFORMANCE_SCHEMA.events_statements_current d ON d.THREAD_ID = c.THREAD_ID;<br></code></pre></td></tr></table></figure><h5 id="案例02-可重复读RR隔离级别下的可见性分析"><a href="#案例02-可重复读RR隔离级别下的可见性分析" class="headerlink" title="案例02-可重复读RR隔离级别下的可见性分析"></a>案例02-可重复读RR隔离级别下的可见性分析</h5><p>在事务开始后第一次读取数据时生成一个ReadView。对于使用 <code>RR</code> 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 <code>ReadView</code> ，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。</p><p><strong>代码与执行流程与RC案例完全相同，唯一不同的是事务隔离级别。</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253073.png" alt="image-20230423012843570"></p><p>这个 <code>SELECT1</code> 的执行过程如下：</p><ul><li><p>在执行 <code>SELECT</code> 语句时会先生成一个 <code>ReadView</code> ， <code>ReadView</code> 的 <code>m_ids</code> 列表的内容就是 <code>[100,200]</code> 。</p></li><li><p>然后从版本链中挑选可见的记录，从图中可以看出，</p><ul><li>最新版本的列 <code>c</code> 的内容是 <code>&#39;张飞&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>100</code> ，在 <code>m_ids</code> 列表内，不符合可见性要求，跳下一个版本。</li><li>下一个版本的列 <code>c</code> 的内容是 <code>&#39;关羽&#39;</code> ，该版本的 <code>trx_id</code> 值也为 <code>100</code> ，也在 <code>m_ids</code> 列表内，不符合要求，跳下一个版本。</li><li>下一个版本的列 <code>c</code> 的内容是 <code>&#39;刘备&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>80</code> ，小于 <code>m_ids</code> 列表中最小的事务id <code>100</code> ，版本符合要求</li></ul></li><li><p>最后返回给用户的版本就是这条列 <code>c</code> 为 <code>&#39;刘备&#39;</code> 的记录。</p></li></ul><p>T5时刻，表 <code>t</code> 中 <code>id</code> 为 1 的记录的版本链就长这样：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253568.png" alt="image-20230423012902368"></p><p>这个 <code>SELECT2</code> 的执行过程如下：</p><ul><li><strong>因为之前已经生成过 <code>ReadView</code> 了，所以此时直接复用之前的 <code>ReadView</code> ，之前的 <code>ReadView</code> 中的<code>m_ids</code> 列表就是 <code>[100, 200]</code> 。</strong></li><li>然后从版本链中挑选可见的记录，从图中可以看出：<ul><li>最新版本的列 <code>c</code> 的内容是 <code>&#39;诸葛亮&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>200</code> ，在 <code>m_ids</code> 列表内，不符合可见性要求，跳下一个版本</li><li>下一个版本的列 <code>c</code> 的内容是 <code>&#39;赵云&#39;</code> ，该版本的 trx_id 值为 200 ，也在 m_ids 列表内，不符合要求，跳下一个版本</li><li>下一个版本的列 <code>c</code> 的内容是 <code>&#39;张飞&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>100</code> ，也在 <code>m_ids</code> 列表内，不符合要求，跳下一个版本</li><li>下一个版本的列 <code>c</code> 的内容是 <code>&#39;关羽&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>100</code> ，也在 <code>m_ids</code> 列表内，不符合要求，跳下一个版本</li><li>下一个版本的列 c 的内容是 <code>&#39;刘备&#39;</code> ，该版本的 <code>trx_id</code> 值为 <code>80</code> ， 80 小于 <code>m_ids</code> 列表中最小的事务id <code>100</code> ，<strong>版本符合要求</strong></li></ul></li><li>最后返回给用户的版本就是这条列 <code>c</code> 为 <code>&#39;刘备&#39;</code> 的记录。</li></ul><p>也就是说两次 <code>SELECT</code> 查询得到的结果是重复的，记录的列 <code>c</code> 值都是 <code>&#39;刘备&#39;</code> ，这就是 <code>可重复读</code> 的含义。</p><p>如果我们之后再把事务id为 <code>200</code> 的记录提交了，之后再到刚才使用 <code>REPEATABLE READ</code> 隔离级别的事务中继续查找这个<code>id</code>为 <code>1</code> 的记录，得到的结果还是 <code>&#39;刘备&#39;</code> ，具体执行过程大家可以自己分析一下。</p><p>注意：<strong>MVCC只在RR和RC两个隔离级别下工作。RU和串行化隔离级别不需要 MVCC，为什么？</strong></p><ul><li>因为RU总是读取最新的数据行，本身就没有隔离性，也不解决并发潜在问题，因此不需要！</li><li>而SERIALIZABLE则会对所有读取的行都加锁，相当于串行执行，线程之间绝对隔离，也不需要。</li></ul><h3 id="4-4-MVCC下的读操作"><a href="#4-4-MVCC下的读操作" class="headerlink" title="4.4 MVCC下的读操作"></a>4.4 MVCC下的读操作</h3><p>在MVCC并发控制中，读操作可以分成两类：<strong>快照读 (Snapshot Read)<strong>与</strong>当前读 (Current Read)</strong></p><ul><li><strong>快照读</strong>：读取的是记录的可见版本 (有可能是历史版本)，不用加锁。刚才案例中都是快照读</li><li><strong>当前读</strong>：读取的是记录的最新版本，并且当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</li></ul><h4 id="4-4-1-当前读与快照读"><a href="#4-4-1-当前读与快照读" class="headerlink" title="4.4.1 当前读与快照读"></a>4.4.1 当前读与快照读</h4><p><strong>快照读</strong>也就是一致性非锁定读(Consistent Nonlocking Read)是指InnoDB存储引擎通过多版本控制(MVCC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个最新可见快照。ReadView的读取操作就是快照读；</p><p>举例：</p><ul><li><strong>快照读：</strong>简单的select操作，属于快照读，不加锁。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where ?;<br></code></pre></td></tr></table></figure><ul><li><strong>当前读：</strong>特殊的读操作，插入&#x2F;更新&#x2F;删除操作，属于当前读，需要加锁。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where ? lock in share mode; # 加读锁<br>select * from table where ? for update;# 加写锁<br>insert into table values (…);# 加写锁<br>update table set ? where ?;# 加写锁<br>delete from table where ?;# 加写锁<br><br># 所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。<br># 其中，除了第一条语句，对读取记录加读锁外，其他的操作都加的是写锁。<br></code></pre></td></tr></table></figure><h4 id="4-4-2-案例：当前读"><a href="#4-4-2-案例：当前读" class="headerlink" title="4.4.2 案例：当前读"></a>4.4.2 案例：当前读</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN;<br># SELECT1：Transaction 100、200未提交<br>SELECT * FROM tab_user WHERE id = 1; # 得到的列name的值为&#x27;刘备&#x27;<br><br># SELECT2：Transaction 100提交，Transaction 200未提交<br>SELECT * FROM tab_user WHERE id = 1; # 得到的列name的值为&#x27;张飞&#x27;<br><br>select * from tab_user where id=1 lock in share mode; # 当前读<br>COMMIT;<br></code></pre></td></tr></table></figure><p><strong>注意：本案例是在之前的案例基础上进行的</strong></p><h4 id="4-4-3-一个CRUD的CUD操作的具体流程"><a href="#4-4-3-一个CRUD的CUD操作的具体流程" class="headerlink" title="4.4.3 一个CRUD的CUD操作的具体流程"></a>4.4.3 一个CRUD的CUD操作的具体流程</h4><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240253369.png" alt="图片17"></p><p>从图中可以看到：</p><p><strong>当Update SQL被发给MySQL后，</strong></p><ul><li>首先，<strong>MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。</strong></li><li>待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。</li><li>一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。</li></ul><p>同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发UniqueKey的冲突检查，也会进行一个当前读。</p><p><strong>注</strong>：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕。</p><h3 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h3><ul><li>MVCC指在使用RC、RR隔离级别下，使不同事务的 <code>读-写</code> 、 <code>写-读</code> 操作并发执行，提升系统性能</li><li>MVCC核心思想是<strong>读不加锁，读写不冲突。</strong></li><li>RC、RR这两个隔离级别的一个很大不同就是生成 <code>ReadView</code> 的时机不同<ul><li>RC在每一次进行普通 <code>SELECT</code> 操作前都会生成一个 <code>ReadView</code></li><li>RR在第一次进行普通 <code>SELECT</code> 操作前生成一个 <code>ReadView</code> ，之后的查询操作都重复这个<code>ReadView</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MySQL</category>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2022/03/02/HashMap/"/>
    <url>/2022/03/02/HashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><h4 id="一、核心常量"><a href="#一、核心常量" class="headerlink" title="一、核心常量"></a>一、核心常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认容量：即2的4次方，16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 最大容量：即2的30次方，1073741824</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 默认负载因子：0.75</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">// 链表树化的条件之一：达到8个节点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// 解树化的条件：节点退化为6时</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">// 链表树化的条件之一：数组容量达到64</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure><h4 id="二、构造方法"><a href="#二、构造方法" class="headerlink" title="二、构造方法"></a>二、构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 空构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span><br>    <br><span class="hljs-comment">// 可设置容量构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span><br>    <br><span class="hljs-comment">// 容量和负载因子构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span><br>    <br><span class="hljs-comment">// 可设置初始数据构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span><br></code></pre></td></tr></table></figure><h4 id="三、核心变量"><a href="#三、核心变量" class="headerlink" title="三、核心变量"></a>三、核心变量</h4><p><strong>loadFactor</strong>：负载因子变量</p><p><strong>threshold</strong>：调整大小的下一个大小值（容量负载因子）</p><p><strong>modCount</strong>：这个HashMap被结构修改的次数，结构修改是那些改变HashMap中的映射数量或以其他方式修改其内部结构（例如：rehash）的修改。该字段用于使用hashmap的集合视图上的迭代器快速失败。</p><p><strong>size</strong>：使用数</p><p>**Set&lt;Map.Entry&lt;K,V&gt;&gt;**：持有缓存的entrySet()。请注意：AbstactMap字段用于keySet()和values()。</p><p>**Node&lt;K,V&gt;[]**：HashMap最上层的数据结构</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="（1）为什么使用HashMap？"><a href="#（1）为什么使用HashMap？" class="headerlink" title="（1）为什么使用HashMap？"></a>（1）为什么使用HashMap？</h4><p>Hashmap是用来存放键值对的。同时因为它基于hash表的实现，它可以实现快速的增删查改。在理想情况下，可以达到O（1）的查询速度。当然这只是理想状况。</p><h4 id="（2）装载因子为什么是0-75？"><a href="#（2）装载因子为什么是0-75？" class="headerlink" title="（2）装载因子为什么是0.75？"></a>（2）装载因子为什么是0.75？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br></code></pre></td></tr></table></figure><ul><li><p>加载因子越大，填满的元素越多，空间利用率越高，但发生冲突的机会变大了；-&gt; <strong>底层红黑树复杂，时间成本高</strong></p></li><li><p>加载因子越小，填满的元素越少，冲突发生的机会减小，但空间浪费了更多了，而且还会提高扩容rehash操作的次数；-&gt; <strong>空间成本高。</strong></p></li></ul><p>总结：和泊松分布无关（泊松分布是链表树化计算出来的概率），千万不要被一些博客误解，就一句话：0.75是为了时间和空间上的权衡。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20220929135428498.png" alt="装载因子0.75与泊松分布没有关系"></p><h4 id="（3）为什么长度是2的次幂？"><a href="#（3）为什么长度是2的次幂？" class="headerlink" title="（3）为什么长度是2的次幂？"></a>（3）为什么长度是2的次幂？</h4><ul><li><h5 id="与“取余”等价的算法"><a href="#与“取余”等价的算法" class="headerlink" title="与“取余”等价的算法"></a>与“取余”等价的算法</h5><p>取余操作中如果除数是2的幂次则等价于与其除数减一的与操作 ，也就是说hash%length&#x3D;&#x3D;hash&amp;(length-1）的前提是length是2的 n 次方，并且采用二进制位操作 ,相对于取余操作能够提高运算效率。</p></li><li><h5 id="扩容时方便定位"><a href="#扩容时方便定位" class="headerlink" title="扩容时方便定位"></a>扩容时方便定位</h5><p>扩容时rehash步骤：</p></li></ul><p>举个例子：</p><p>  原数组长度为16，现需要将其扩容到32</p><p>  <strong>16-1的二进制：0000 1111</strong></p><p><strong>32-1的二进制：0001 1111</strong></p><hr><p>计算数组下标公式不变：hash(key) &amp; (table.length-1)</p><p>假设某一元素的hash为<strong>52</strong></p><p><strong>52的二进制：0011 0100</strong></p><hr><p>扩容前，该元素下标：</p><p><strong>52&amp;(16-1)：</strong></p><p>  ​<strong>0011 0100</strong></p><p>  <strong>&amp; 0000 1111</strong></p><p>  <strong>————————</strong></p><p>  ​<strong>0000 0100 &#x3D; 4</strong></p><hr><p>  扩容后，该元素下标：</p><p>  <strong>52&amp;(32-1)：</strong></p><p>  ​<strong>001<code>1</code> 0100</strong></p><p>  <strong>&amp; 000<code>1</code> 1111</strong></p><p>  <strong>————————</strong></p><p>  ​<strong>000<code>1</code> 0100 &#x3D; 20</strong></p><hr><p>  规律就是，16-1到32-1的变化，只发生在最高位上，每次扩容2倍，只需要在原容量的高位前面补1。</p><p>  key的hash值不变，长度每次在最高位变化1。</p><p>  也就是说，我们每次只需要对比扩容后key的hash和length-1对应的最高位上的数值就好了，与运算的逻辑为，<strong>同1得1，其他是0</strong>。</p><ul><li><p>如果这个位置是0，余数计算的结果将保持不变，意味着扩容后此元素还在这个槽中（槽编号没发生改变）</p></li><li><p>如果这个位置是1，余数计算结果就变成了<code>原槽索引 + 原array.length</code>。</p></li></ul><p>  <strong>总结：</strong></p><ol><li>能利用 &amp; 操作代替 % 操作，提升性能</li><li>数组扩容时，仅仅关注 “特殊位” 就可以重新定位元素</li></ol><h4 id="（4）如何解决哈希冲突？"><a href="#（4）如何解决哈希冲突？" class="headerlink" title="（4）如何解决哈希冲突？"></a>（4）如何解决哈希冲突？</h4><p>HashMap使用<strong>拉链法</strong>解决冲突：</p><p><strong>所谓“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240258236.png" alt="hashmap的结构示意图"></p><h4 id="（5）为什么阈值为8树化，6再退化，8和6怎么来的？"><a href="#（5）为什么阈值为8树化，6再退化，8和6怎么来的？" class="headerlink" title="（5）为什么阈值为8树化，6再退化，8和6怎么来的？"></a>（5）为什么阈值为8树化，6再退化，8和6怎么来的？</h4><ul><li>阈值&gt;&#x3D;8，链表转红黑树。</li></ul><p>这里就要用到泊松分布了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">* Because TreeNodes are about twice the size of regular node<br>* use them only when bins contain enough nodes to warrant us<br>* (see TREEIFY_THRESHOLD). And when they become too <span class="hljs-title function_">small</span> <span class="hljs-params">(d</span><br><span class="hljs-params">* removal or resizing)</span> they are converted back to plain bins<br>* usages with well-distributed user hashCodes, tree bins are<br>* rarely used.  Ideally, under random hashCodes, the frequen<br>* nodes in bins follows a Poisson distribution<br>* (http:<span class="hljs-comment">//en.wikipedia.org/wiki/Poisson_distribution) with a</span><br>* parameter of about <span class="hljs-number">0.5</span> on average <span class="hljs-keyword">for</span> the <span class="hljs-keyword">default</span> resizing<br>* threshold of <span class="hljs-number">0.75</span>, although with a large variance because <br>* resizing granularity. Ignoring variance, the expected<br>* occurrences of list size k <span class="hljs-title function_">are</span> <span class="hljs-params">(exp(-<span class="hljs-number">0.5</span>)</span> * pow(<span class="hljs-number">0.5</span>, k) /<br>* factorial(k)). The first values are:<br>*<br>* <span class="hljs-number">0</span>:    <span class="hljs-number">0.60653066</span><br>* <span class="hljs-number">1</span>:    <span class="hljs-number">0.30326533</span><br>* <span class="hljs-number">2</span>:    <span class="hljs-number">0.07581633</span><br>* <span class="hljs-number">3</span>:    <span class="hljs-number">0.01263606</span><br>* <span class="hljs-number">4</span>:    <span class="hljs-number">0.00157952</span><br>* <span class="hljs-number">5</span>:    <span class="hljs-number">0.00015795</span><br>* <span class="hljs-number">6</span>:    <span class="hljs-number">0.00001316</span><br>* <span class="hljs-number">7</span>:    <span class="hljs-number">0.00000094</span><br>* <span class="hljs-number">8</span>:    <span class="hljs-number">0.00000006</span><br>* more: less than <span class="hljs-number">1</span> in ten million<br></code></pre></td></tr></table></figure><p>上面这段话的意思是，如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，<strong>链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006</strong>。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p><ul><li>阈值&lt;&#x3D;6，红黑树转链表。</li></ul><p>红黑树和链表的转换也需要性能，如果等于8就树化，小于8就转链表，hashmap就会在这中间反复横跳，影响性能，预留了一个缓冲。</p><h4 id="（6）为什么使用红黑树而不用B树-？"><a href="#（6）为什么使用红黑树而不用B树-？" class="headerlink" title="（6）为什么使用红黑树而不用B树 ？"></a>（6）为什么使用红黑树而不用B树 ？</h4><p>如果用 B&#x2F;B+ 树 的话，在数据量不是很多的情况下，数据都会 “挤在” 一个结点里面，这个时候遍历效率就<strong>退化</strong>成了<strong>链表</strong>。</p><h4 id="（7）为什么数组容量要大于64才进行树形化操作呢？"><a href="#（7）为什么数组容量要大于64才进行树形化操作呢？" class="headerlink" title="（7）为什么数组容量要大于64才进行树形化操作呢？"></a>（7）<strong>为什么数组容量要大于64才进行树形化操作呢？</strong></h4><p> 假设数组容量是16初始容量，也发送了8次的哈希冲突，但是哈希冲突产生的原因是因为数组的容量太小，在进行数组运算时，将下标落在了一个位置上，也就是说并不是因为哈希冲突造成的链表长度过长，而是因为数组长度太小导致取余冲突问题，所以hashmap会优先进行容量扩容，直到达到64还是发生8次哈希冲突，就排除了由于数组长度太小造成的冲突问题。</p><h3 id="源码篇"><a href="#源码篇" class="headerlink" title="源码篇"></a>源码篇</h3><h4 id="一、hash-：计算在桶中的位置"><a href="#一、hash-：计算在桶中的位置" class="headerlink" title="一、hash()：计算在桶中的位置"></a>一、hash()：计算在桶中的位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">// 这里的 (n-1)&amp;hash 就是跟hash计算出来的值和size-1进行与运算</span><br><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 1. h = key.hashCode()取hashcode值</span><br><span class="hljs-comment">    2. h ^ (h &gt;&gt;&gt; 16)将hashcode右移16位，再和原结果进行异或运算：高位参与运算（异或：同为0，异为1）</span><br><span class="hljs-comment">    3. index = (n - 1) &amp; hash取模运算（按位与运算：同1得1，其他是0）</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240258841.png" alt="索引计算流程图"></p><p>总结：</p><ol><li><p>为什么要右移16位而不是直接返回hashcode的值？</p><p>目的是让高位参与运算</p><p>int有32位，h&gt;&gt;&gt;16再异或key.hashcode()，被称为扰动函数，让高16位也参与到hashcode的取值中，<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240258085.png" alt="索引计算样例"></p><p><em>Q：扰动为什么是异或，而不是别的呢？</em></p><p>A：因为异或的计算法则是，同为0，异为1，00 11 01 10，数字0和1的四种组合情况，结果为1和0的各占50%，结果最平均。</p></li><li><p>为什么使用按位与&amp;运算而不是取模运算？</p><p>因为按位与运算要比取模运算的效率高的多，取模运算要进行进制转换，转换成10进制，而位运算是直接进行二进制操作。</p></li><li><p>key是可以为null的，为null的key会被放在索引为0的槽位上。</p></li></ol><h4 id="二、put-：放入元素"><a href="#二、put-：放入元素" class="headerlink" title="二、put()：放入元素"></a>二、put()：放入元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 新建一个hashmap，并向map里放入key为字符串“k”，value为字符串“v”的一个键值对。</span><br>    HashMap&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 进入put()方法</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// 这里hash(key)把已经计算好的hashcode带入</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">// put核心方法（重要）</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// 让tab指向该hashmap的底层数组，n指向该hashmap的容量</span><br>    <span class="hljs-comment">// 如果数组空或者容量是0，说明map是刚刚创建，要先进行一次初始化操作。</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 第一次进行初始化操作，也就是扩容操作，并返回长度赋值给n。</span><br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 初始化好以后，i = (n - 1) &amp; hash，是关键，这一步就是确定数组索引位置i。</span><br>    <span class="hljs-comment">// 如果发现这个槽位空了</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 新建一个节点，next指向null，并赋值到当前下标位置。</span><br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 如果这个不空，说明冲突了，下面就是拉链法解决冲突，或者树化，或者覆盖值的操作。</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// e代表当前节点，k代表key值</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 如果tab[i]是一个Node节点，</span><br>        <span class="hljs-comment">// 并且key的hash和我们要插入的hash一样，并且key也一样。</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-comment">// 直接覆盖即可，当前节点e直接指向该位置。</span><br>            e = p;<br>        <span class="hljs-comment">// 如果tab[i]是一颗树</span><br>        <span class="hljs-comment">// 这里完全可以用instanceof判断，因为TreeNode是Node的子类。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 就按照树的方式，插入节点或覆盖值。</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 上面两种都不是，那就剩链表了。</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这里用了遍历，一直遍历到链表的尾部，进行尾插。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 如果被碰撞节点tab[i]节点的下一个节点空了，说明到尾部了。</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 直接尾插。</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 如果遍历发现，长度&gt;=8了，说明到达了链表树化的阈值。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-comment">// 要树化链表，转为红黑树</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 如果一直到最后e还是空，说明没有相同的key，这是一个插入操作，直接跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 如果key相同，直接break，当前节点e直接指向当前位置就好了，跳出循环。</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 注意，一直到这里，发生冲突时，还没有真正的覆盖value，只是改变了指针的指向</span><br>        <span class="hljs-comment">// 下面才是真正覆盖值，并且返回老值的操作，因为，put方法的返回值就是返回旧值。</span><br>        <span class="hljs-comment">// 如果e不空，说明，要覆盖；否则走下面 return null;</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-comment">// 老值赋给oldValue</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent默认false，!onlyIfAbsent就是true，继续走。</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">// 把新值赋给该节点，把老元素覆盖掉。</span><br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果走到这里，说明上面 return oldValue; 没走</span><br>    <span class="hljs-comment">// 也就说明，这一次put不是覆盖，而是新增</span><br>    <span class="hljs-comment">// 所以要计算修改的次数，并判断是不是需要扩容</span><br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        <span class="hljs-comment">// 如果到达阈值要进行扩容</span><br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240258768.png" alt="put流程图"></p><h4 id="三、get-：获取元素"><a href="#三、get-：获取元素" class="headerlink" title="三、get()：获取元素"></a>三、get()：获取元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 新建一个hashmap，并向map里放入key为字符串“k”，value为字符串“v”的一个键值对。</span><br>    HashMap&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>);<br>    map.get(<span class="hljs-string">&quot;k&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 进入get()方法</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 这里hash(key)把已经计算好的hashcode带入</span><br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-comment">// get核心方法（重要）</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-comment">// 如果数组不空，并且容量&gt;0，并且计算出来的桶索引位置上的元素不空，进行取值</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果hash值相同，并且key也是一样的，直接返回。</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 如果到这一步，说明首节点判断完了，接下来该是链表或者红黑树的了。</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果是树形结构，进入树的取值流程</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 如果是链表，则遍历链表即可。</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="四、resize-：扩容"><a href="#四、resize-：扩容" class="headerlink" title="四、resize()：扩容"></a>四、resize()：扩容</h4><blockquote><p>这段代码比较难理解，要认真反复的看。</p><p>resize()的有两个作用：</p><ol><li>初始化</li><li>扩容</li></ol><p>这里有几个概念：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240258887.png" alt="resize时的一些局部变量介绍"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    <span class="hljs-comment">// 原数组</span><br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-comment">// oldCap：原容量</span><br>    <span class="hljs-comment">// 如果tab压根不存在，说明是第一次创建，原容量默认为0，否则就是原容量。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-comment">// oldThr用来存储当前阈值，也就是原阈值。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-comment">// 创建了新容量，和新阈值，默认都为0</span><br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果原容量大于0，说明这是初始化完毕的hashmap，准备扩容。</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        &lt;极限的扩容流程&gt;</span><br><span class="hljs-comment">        例：</span><br><span class="hljs-comment">        容量：2^30 -&gt; 2^30</span><br><span class="hljs-comment">        阈值：2^29 -&gt; Integer.MAX_VALUE</span><br><span class="hljs-comment">       **/</span><br>        <br>        <span class="hljs-comment">// 容量到达最大值了吗？到了就不能再扩容了，直接返回。</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-comment">// 把int的最大值赋给阈值，这样，永远都达不到这个数，就永远不会扩容了。</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        &lt;通常正常的扩容流程&gt;</span><br><span class="hljs-comment">        该分支正常扩容，例：</span><br><span class="hljs-comment">        容量：16 -&gt; 32</span><br><span class="hljs-comment">        阈值：12 -&gt; 24</span><br><span class="hljs-comment">       **/</span><br>        <br>        <span class="hljs-comment">// oldCap &lt;&lt; 1：相当于乘以2，也就是我们说的扩容2倍</span><br>        <span class="hljs-comment">// 扩容2倍赋值给newCap并且看看容量有没有超过最大阈值 并且 旧容量是否大于默认容量16</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-comment">// 如果都满足，新阈值变为原来的2倍</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 走到这一步，说明map还没被初始化，因为上面才是初始化之后的扩容流程。</span><br>    <span class="hljs-comment">// 没初始化，为什么原阈值还会大于0呢？</span><br>    <span class="hljs-comment">// 那只有三种情况，就是使用了hashmap的有参构造方法：</span><br>    <span class="hljs-comment">// public HashMap(int initialCapacity, float loadFactor)</span><br>    <span class="hljs-comment">// public HashMap(int initialCapacity)</span><br>    <span class="hljs-comment">// public HashMap(Map m)</span><br>    <span class="hljs-comment">// 说明，初始化hashmap的时候，使用了构造方法指定了容量大小，构造方法里的tableSizeFor()方法，设定了阈值的大小，但因为数组还没有创建，所以容量是0，阈值则为自修正的2的整数倍。</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        &lt;初始化流程&gt;</span><br><span class="hljs-comment">        该分支走了有参构造，例：</span><br><span class="hljs-comment">        新阈值：空缺</span><br><span class="hljs-comment">        原阈值：16 -&gt; 新容量：16</span><br><span class="hljs-comment">       **/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">// 把原阈值赋值给新容量。</span><br>        newCap = oldThr;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        &lt;初始化流程&gt;</span><br><span class="hljs-comment">        该分支走了无参构造，例：</span><br><span class="hljs-comment">        新容量：默认16</span><br><span class="hljs-comment">        新阈值：默认16*0.75=12</span><br><span class="hljs-comment">       **/</span><br>    <span class="hljs-comment">// 如果到了这一步，说明原容量&lt;=0。</span><br>    <span class="hljs-comment">// 也就是调用了无参构造方法，没真正的初始化hashmap，</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        <span class="hljs-comment">// 默认容量 16</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-comment">// 默认阈值 12。</span><br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        &lt;初始化流程&gt;</span><br><span class="hljs-comment">        填补上面的新阈值空缺</span><br><span class="hljs-comment">        新阈值：新容量16*0.75=12</span><br><span class="hljs-comment">        新容量：16</span><br><span class="hljs-comment">       **/</span><br>    <br>    <span class="hljs-comment">// 如果新阈值=0，</span><br>   <span class="hljs-comment">// 说明走了上面的 else if (oldThr &gt; 0) </span><br>    <span class="hljs-comment">// 因为只有这个分支里 没设置newThr</span><br>    <span class="hljs-comment">// 那就是说hashmap使用了有参构造方法初始化了</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 计算新阈值。这就填补上上面的新阈值空缺的情况了</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        <span class="hljs-comment">// 这里也要判断容量是否大于容量上限</span><br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 至此，扩容之前的所有准备工作已经完毕</span><br>    <span class="hljs-comment">// 无论这次是扩容操作，还是初始化操作。</span><br>    <span class="hljs-comment">// 新阈值和新容量都已经被设置好。</span><br>    <span class="hljs-comment">// 接下来就是要进行rehash，将旧数组的元素移交到新数组。</span><br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    <span class="hljs-comment">// 创建一个新数组，容量为新容量</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    <span class="hljs-comment">// 再赋值给当前全局变量</span><br>    table = newTab;<br>    <br>    <span class="hljs-comment">// 下面就是扩容的核心流程</span><br>    <span class="hljs-comment">// 说到这里，必须知道一个前置知识，就是jdk8中扩容的hash计算方式</span><br>    <span class="hljs-comment">// 在上文《常见问题》中《为什么长度是2的次幂》有讲到，一定要看完再回来。</span><br>    <span class="hljs-comment">// 如果旧数组 == null，则不涉及数组迁移等操作，在最后直接返回即可。</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历整个旧数组，把数组上面的节点取出一个一个处理</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            <span class="hljs-comment">// 创建一个临时变量e，后续都是把旧数组位置上的node指向e</span><br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-comment">// 如果这个位置上的元素空了，就不进行处理。有数据则处理。</span><br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 把旧数组的当前位置设为null</span><br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 如果e的next为空，说明该槽位并没有链表或者树，只有一个节点</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 直接rehash，重新计算下标位置，并赋值到新元素的位置上即可。</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">// 如果是树节点</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">// 调用树节点的方法处理</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-comment">// 最后是链表结构的情况</span><br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    <span class="hljs-comment">// lo：low的缩写，低位</span><br>                    <span class="hljs-comment">// hi：high的缩写，高位</span><br>                    <span class="hljs-comment">// 暂时不用知道他们什么意思，看下面。</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">/** 遍历链表</span><br><span class="hljs-comment">                     上文《为什么长度是2的次幂》读完，下面读起来就会很顺畅</span><br><span class="hljs-comment">                     扩容后，</span><br><span class="hljs-comment">                     如果与运算结果=1，槽位变化。</span><br><span class="hljs-comment">                     如果与运算结果=0，槽位不变。</span><br><span class="hljs-comment">                     那么上面的4个参数中的loHead，loTail代表，所有槽位不变的node节点的指针，hiHead和hiTail代表所有槽位变化的node节点的指针。</span><br><span class="hljs-comment">                     这样，就可以在这一个链表里，把所有变化的，和没变化的拆分成两条链。所有没发生变化的自然就在原槽位呆着不动，所有变化的再拿出来做处理。下文有图。</span><br><span class="hljs-comment">                     或者可以看看这篇文章https://www.codenong.com/jsa0e02fce06d2/</span><br><span class="hljs-comment">                    **/</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 与运算结果=0，槽位不变。</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-comment">// 看当前节点是不是第一个节点</span><br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                <span class="hljs-comment">// 如果是，则把该节点放到头部</span><br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                <span class="hljs-comment">// 如果不是，把该节点链接到尾部</span><br>                                loTail.next = e;<br>                            <span class="hljs-comment">// 最后当前节点指向尾部</span><br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 与运算结果=1，槽位变化。</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <br>                    <span class="hljs-comment">// 不用变动槽位的，把lo这条链取出来，放在原槽位即可</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <br>                    <span class="hljs-comment">// 需要变动槽位的，把hi这条链取出来，放在（原槽索引 + 原capSize）的位置即可。</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 完成扩容</span><br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240258597.jpeg" alt="loHead，loTail，在遍历链表时的流程，hiHead，hiTail同理"></p><h3 id="文章引用"><a href="#文章引用" class="headerlink" title="文章引用"></a><strong>文章引用</strong></h3><p><a href="https://segmentfault.com/a/1190000017509668">【源】终于明白JDK8 HashMap底层数组长度，取值2次幂的原因</a></p><p><a href="https://blog.csdn.net/kyle_wu_/article/details/113578055">面试官：Hashmap链表长度为8时转换成红黑树，你知道为什么是8吗</a></p><p><a href="https://www.codenong.com/jsa0e02fce06d2/">带你搞清楚HashMap扩容中的loTail.next &#x3D; e和loTail &#x3D; e</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2021/12/28/MySQL/"/>
    <url>/2021/12/28/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h1 id="一、索引的概述"><a href="#一、索引的概述" class="headerlink" title="一、索引的概述"></a>一、索引的概述</h1><h3 id="1、索引"><a href="#1、索引" class="headerlink" title="1、索引"></a>1、索引</h3><p>索引：MYSQL中的索引，相当于是给数据创建了一个目录。该目录的作用，是当有查询该目录时，可以快速定位数据所在的磁盘位置而进行快速查询。</p><p>没有加索引相当于对磁盘多次IO，进行全表扫描，性能是非常差的。</p><h3 id="2、索引存储在哪里？"><a href="#2、索引存储在哪里？" class="headerlink" title="2、索引存储在哪里？"></a>2、索引存储在哪里？</h3><ul><li><p>InnoDB引擎：</p><p>索引和数据存放在一个文件里。后缀 idb。</p></li><li><p>MyISAM引擎：</p><p>索引和数据分开两个文件来存储。后缀 MYD 存放数据，MYI 存放索引。</p></li></ul><h3 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h3><ol><li><h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><p>一张表的主键，是自带索引的效果。所以在创建表的时候建议一定要带主键，因为有主键就有主键索引。用主键来查询数据是走索引的，速度非常快。</p></li><li><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>为普通的列创建索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 格式 <br><span class="hljs-keyword">CREATE</span> INDEX 索引名称 <span class="hljs-keyword">ON</span> 表名(列名)<br># 示例<br><span class="hljs-keyword">CREATE</span> INDEX idx_title <span class="hljs-keyword">ON</span> weixin_article_weixiao(title)<br></code></pre></td></tr></table></figure></li><li><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>在普通索引的基础上，列的值是唯一的。唯一索引的性能要优于普通索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_unique_title <span class="hljs-keyword">ON</span> weixin_article_weixiao(title)<br></code></pre></td></tr></table></figure></li><li><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><p>在一个索引中包含了表中的多个列。联合索引有很多的细节，比如最左前缀法则，及如何使用该法则来命中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 格式 <br><span class="hljs-keyword">CREATE</span> INDEX 索引名称 <span class="hljs-keyword">ON</span> 表名(列名<span class="hljs-number">1</span>,列名<span class="hljs-number">2</span>)<br># 示例<br><span class="hljs-keyword">CREATE</span> INDEX idx_book_author <span class="hljs-keyword">ON</span> book_author(book_id,author_id)<br></code></pre></td></tr></table></figure></li><li><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>搜索引擎使用的就是全文索引的概念，我们不会用MySQL做全文检索，所以这个索引了解即可。</p><p>MySQL里只有MyISAM引擎支持全文索引。</p></li></ol><h1 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h1><blockquote><p>数据结构可视化：</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p></blockquote><h3 id="1、线性表"><a href="#1、线性表" class="headerlink" title="1、线性表"></a>1、线性表</h3><h4 id="1-顺序存储的线性表"><a href="#1-顺序存储的线性表" class="headerlink" title="1. 顺序存储的线性表"></a>1. 顺序存储的线性表</h4><p>存放数据的位置是连续的。</p><h4 id="2-链式存储的线性表"><a href="#2-链式存储的线性表" class="headerlink" title="2. 链式存储的线性表"></a>2. 链式存储的线性表</h4><p>存储数据的位置本身是不连续的，通过一条链来维护数据的先后关系。</p><ul><li>单向链表</li><li>双向链表</li></ul><h3 id="2、栈和队列"><a href="#2、栈和队列" class="headerlink" title="2、栈和队列"></a>2、栈和队列</h3><p>栈和队列底层都可以使用顺序结构或链式结构来维护数据</p><ul><li>栈：数据是按照先进后出的特点进行管理</li><li>队列：数据是按照先进先出的特点进行管理</li></ul><h3 id="3、数组和广义表"><a href="#3、数组和广义表" class="headerlink" title="3、数组和广义表"></a>3、数组和广义表</h3><ul><li><p>数组：一维数组，多维数组</p></li><li><p>广义表：表中可以放具体的元素，也可以放另外一张表。</p><p>广义表也可以理解成是多维数组，但是广义表比多维数据在空间上要更节约一些。</p></li></ul><h3 id="4、树"><a href="#4、树" class="headerlink" title="4、树"></a>4、树</h3><ul><li><p>二叉树：每个节点最多只能有两个子节点</p></li><li><p>满二叉树：除叶子节点外其它的节点都有两个子节点，而且叶子节点的深度相同。</p></li><li><p>完全二叉树：除叶子节点外，所有节点的子节点必须有左子节点。</p></li><li><p>二叉排序树：二叉树的节点的左子节点比自己小，右子节点比自己大。</p></li><li><p>平衡二叉树（AVL树）：在二叉排序树的基础上遵循两个原则</p><p>（1）每颗子树中的左子树和右子树的深度差不能超过1。</p><p>（2）二叉树中每颗子树要求都是平衡二叉树。</p></li><li><p>红黑树：</p><p>在平衡二叉树的基础上，对于插入和删除操作做了自己的优化，目的是保证插入和删除造成的自旋次数，和查找的性能之间做了均衡，就可以保证查找的性能和造成的开销都是较为均衡的。</p><h5 id="为什么索引不用红黑树这种结构，当红黑树中的数据量较大时，树的深度也会很大，于是查找性能就不ok了。"><a href="#为什么索引不用红黑树这种结构，当红黑树中的数据量较大时，树的深度也会很大，于是查找性能就不ok了。" class="headerlink" title="为什么索引不用红黑树这种结构，当红黑树中的数据量较大时，树的深度也会很大，于是查找性能就不ok了。"></a>为什么索引不用红黑树这种结构，当红黑树中的数据量较大时，树的深度也会很大，于是查找性能就不ok了。</h5></li><li><p>B树：</p><p>B树，屏蔽了红黑树上的每个节点存放数据过少的弊端。也就是说B树中一个节点可以存放多个数据。</p><p>此时，这棵树的深度由节点的度（一个节点中可以存放多少个数据节点）来决定。</p><p>如果节点的度比较大，那么节点中存放的数据节点的个数就比较多。那么整棵树的深度就比较浅，那么整棵树的查询性能就更好。</p><p>MYSQL中一个节点中可以存放多少个数据是怎么规划的。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20211215233004931.png" alt="image-20211215233004931"></p><blockquote><ol><li>根节点也可以存放数据。</li><li>MySQL对于一个物理节点的规划默认是<strong>16KB</strong>。</li><li>数据节点：包含，索引列的值最大<strong>8B</strong>，数据最大<strong>1KB</strong>，总和<strong>1023B</strong>。</li><li>第一层最多能存放<strong>15</strong>个数据节点。</li><li>第二层最多能存放<strong>15*15&#x3D;225</strong>个数据节点。</li></ol></blockquote><p>B树虽然在红黑树的基础上提高了节点的度，提升了查询的性能，但是由于节点中度过小。性能提升还没达到预期。</p></li><li><p>B+树：</p><blockquote><ol><li>只有叶子节点能存放数据</li><li>非叶子节点会冗余叶子节点的键。<ol><li>非叶子节点（第一层）存放：数据本身索引列的值（<strong>8B</strong>），和定位到下一层的位置（<strong>6B</strong>）。</li><li>在第一层，可以存放1<strong>6KB&#x2F;(8+6)B&#x3D;1170</strong>个数据节点。</li><li>第二层，存放<strong>1170*1170&#x3D;136</strong>万个数据节点。</li><li>第三层，索引值+数据 <strong>1032B</strong>，每个节点最多存放<strong>15</strong>个数据节点。<strong>136万*15&#x3D;2053万</strong>个数据。</li></ol></li><li>叶子节点会带有指针，提高区间访问的效率。</li><li>叶子节点中的元素，是从小到大，以从左往右的方向进行排列。</li></ol></blockquote><p>B+树在B树的基础上进行了改善，提高了节点的度，节点存放的数据节点的个数，极大的降低了树的深度。B+树的叶子节点从小到大排列，具备区间访问的性能。 – 索引会使用这种数据结构。</p></li></ul><h3 id="5、hash表"><a href="#5、hash表" class="headerlink" title="5、hash表"></a>5、hash表</h3><p>Hash表的查找性能是比B+树要好的，但是Hash表不支持区间访问，因此MySQL不支持这种数据结构。</p><h3 id="6、图"><a href="#6、图" class="headerlink" title="6、图"></a>6、图</h3><p>对于数据的分析和研究层面，图的数据结构是非常重要的，也涉及到非常多的算法。这里只做了解。</p><h1 id="三、MySQL和MyISAM的区别"><a href="#三、MySQL和MyISAM的区别" class="headerlink" title="三、MySQL和MyISAM的区别"></a>三、MySQL和MyISAM的区别</h1><p>之前已经看到，InnoDB把数据和索引存放在一个文件里，MyISAM把数据和文件分开存储。</p><blockquote><p>因为MyISAM把索引和数据分开两个文件来存储。因此，在查找索引后，索引的叶子节点存放的是该条记录在另一个文件中对应的磁盘地址。所以，MyISAM的查找性能是没有InnoDB强的。</p></blockquote><h2 id="1、MyISAM–非聚集索引"><a href="#1、MyISAM–非聚集索引" class="headerlink" title="1、MyISAM–非聚集索引"></a>1、MyISAM–非聚集索引</h2><ul><li>MyISAM支持全文检索，支持表锁。在互联网应用里，因为追求查询性能，且全文检索会使用比较主流的全文检索中间件（es&#x2F;solr）来做，所以MyISAM存储引擎用得比较少。</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20211216001617342.png" alt="image-20211216001617342"></p><h2 id="2、InnoDB–聚集索引"><a href="#2、InnoDB–聚集索引" class="headerlink" title="2、InnoDB–聚集索引"></a>2、InnoDB–聚集索引</h2><p>InnoDB会把索引和数据绑定在一起，那么通过找到索引后，就能快速的找到数据，所以查询性能是比MyISAM强很多。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20211216002628770.png" alt="image-20211216002628770"></p><blockquote><p>非聚集索引：就是MyISAM。</p><p>聚集索引：索引和数据在一起，也就是InnoDB的索引。</p></blockquote><h1 id="四、索引的面试题"><a href="#四、索引的面试题" class="headerlink" title="四、索引的面试题"></a>四、索引的面试题</h1><ul><li><h3 id="问题1：为什么非主键索引的叶子节点存放的是数据是主键值？"><a href="#问题1：为什么非主键索引的叶子节点存放的是数据是主键值？" class="headerlink" title="问题1：为什么非主键索引的叶子节点存放的是数据是主键值？"></a>问题1：为什么非主键索引的叶子节点存放的是数据是主键值？</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20211216004518942.png" alt="image-20211216004518942"></p><p>两个原因：</p><ul><li>节约空间：冗余存放相同的数据在多个索引树会造成空间的浪费</li><li>简化修改数据时的操作：如果冗余放相同数据到多个索引树上，那么在数据进行修改时，所有的相关的每个索引树都要修改数据，而不是只改一份。</li></ul></li><li><h3 id="问题2：为什么InnoDB表必须创建主键？"><a href="#问题2：为什么InnoDB表必须创建主键？" class="headerlink" title="问题2：为什么InnoDB表必须创建主键？"></a>问题2：为什么InnoDB表必须创建主键？</h3><p>因为表中的辅助（普通）索引是需要存放主键数据的，即使我们在建表的时候，忘记了创建主键，MySQL也会自动的创建一个临时主键索引，用来定位数据。</p></li><li><h3 id="问题3：为什么使用主键时推荐使用整型的自增主键？"><a href="#问题3：为什么使用主键时推荐使用整型的自增主键？" class="headerlink" title="问题3：为什么使用主键时推荐使用整型的自增主键？"></a>问题3：为什么使用主键时推荐使用整型的自增主键？</h3><p> 使用整型，而不是字符串，这样在索引这一颗排序树上比较大小性能更好。</p><p>如果不使用自增主键，那么索引叶子节点是从小到大排列，不规律的主键会造成更多索引树的自旋。从而影响了性能。</p></li></ul><h1 id="五、联合索引"><a href="#五、联合索引" class="headerlink" title="五、联合索引"></a>五、联合索引</h1><h2 id="1、联合索引在底层是如何存储的"><a href="#1、联合索引在底层是如何存储的" class="headerlink" title="1、联合索引在底层是如何存储的"></a>1、联合索引在底层是如何存储的</h2><p>一张表中的多个列，组合成一个索引。换句话说，一个索引，包含了一张表中的多个列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_book_author <span class="hljs-keyword">ON</span> tb_book_author(book_id,author_id)<br></code></pre></td></tr></table></figure><p>在联合索引树上，节点中的数据存放的是联合索引每个列的内容。</p><h2 id="2、最左前缀法则"><a href="#2、最左前缀法则" class="headerlink" title="2、最左前缀法则"></a>2、最左前缀法则</h2><p>创建了联合索引以后，在使用sql查询时，能否命中索引，就看查询条件是否遵循了最左前缀法则。如果遵循了最左前缀法则，就能命中索引，而不会全表扫描。</p><p>更为复杂的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_a_b_c <span class="hljs-keyword">on</span> tb_tmp(a,b,c)<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_tmp <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>;# 可以<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_tmp <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-number">2</span>;# 可以<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_tmp <span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>; # 不可以<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_tmp <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>; # 只命中了a的索引，随后在a的下面进行全表扫描<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_tmp <span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span>;# 可以，mysql会自动优化顺序。<br></code></pre></td></tr></table></figure><h1 id="六、SQL优化"><a href="#六、SQL优化" class="headerlink" title="六、SQL优化"></a>六、SQL优化</h1><p>即使我们在创建数据库表时为表创建了索引。但是在实际使用的sql语句却没有命中索引而造成了慢查询，从而导致整个接口的性能是非常差的。</p><h2 id="1-为什么要做SQL优化"><a href="#1-为什么要做SQL优化" class="headerlink" title="1.为什么要做SQL优化"></a>1.为什么要做SQL优化</h2><ul><li>防止慢查询，导致接口性能较差。接口性能1s以内，甚至200ms以内。</li><li>数据库的名称不规范，表的结构不规范，导致使用时出现了问题，对生产环境造成了影响。</li></ul><h2 id="2-如何做SQL优化"><a href="#2-如何做SQL优化" class="headerlink" title="2.如何做SQL优化"></a>2.如何做SQL优化</h2><h3 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h3><ul><li>表存储引擎必须使用InnoDB</li><li>表字符集默认使用utf8，必要时候使用utf8mb4</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">解读：<br><br>（1）通用，无乱码风险，汉字3字节，英文1字节<br><br>（2）utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它<br></code></pre></td></tr></table></figure><ul><li>禁止使用存储过程，视图，触发器，Event</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">解读：<br><br>（1）对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层<br><br>（2）调试，排错，迁移都比较困难，扩展性较差<br></code></pre></td></tr></table></figure><ul><li>禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径</li><li>禁止在线上环境做数据库压力测试</li><li>测试，开发，线上数据库环境必须隔离</li></ul><h3 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h3><ul><li>库名，表名，列名必须用小写，采用下划线分隔</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">解读：<span class="hljs-keyword">abc</span>，Abc，ABC都是给自己埋坑<br></code></pre></td></tr></table></figure><ul><li>库名，表名，列名必须见名知义，长度不要超过32字符</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">解读：tmp，wushan谁TM知道这些库是干嘛的<br></code></pre></td></tr></table></figure><ul><li>库备份必须以bak为前缀，以日期为后缀</li><li>从库必须以-s为后缀</li><li>备库必须以-ss为后缀</li></ul><h3 id="三、表设计规范"><a href="#三、表设计规范" class="headerlink" title="三、表设计规范"></a>三、表设计规范</h3><ul><li>单实例表个数必须控制在2000个以内</li><li>单表分表个数必须控制在1024个以内</li><li>表必须有主键，推荐使用UNSIGNED整数为主键</li><li>潜在坑：删除无主键的表，如果是row模式的主从架构，从库会挂住</li><li>禁止使用外键，如果要保证完整性，应由应用程式实现</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">解读：外键使得表之间相互耦合，影响<span class="hljs-keyword">update</span><span class="hljs-operator">/</span><span class="hljs-keyword">delete</span>等<span class="hljs-keyword">SQL</span>性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈<br></code></pre></td></tr></table></figure><ul><li>建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">解读：具体参加《如何实施数据库垂直拆分》<br></code></pre></td></tr></table></figure><h3 id="四、列设计规范"><a href="#四、列设计规范" class="headerlink" title="四、列设计规范"></a>四、列设计规范</h3><ul><li>根据业务区分使用tinyint&#x2F;int&#x2F;bigint，分别会占用1&#x2F;4&#x2F;8字节</li><li>根据业务区分使用char&#x2F;varchar</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">解读：<br><br>（<span class="hljs-number">1</span>）字段长度固定，或者长度近似的业务场景，适合使用<span class="hljs-type">char</span>，能够减少碎片，查询性能高<br><br>（<span class="hljs-number">2</span>）字段长度相差较大，或者更新较少的业务场景，适合使用<span class="hljs-type">varchar</span>，能够减少空间<br></code></pre></td></tr></table></figure><ul><li>根据业务区分使用datetime&#x2F;timestamp</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">解读：前者占用<span class="hljs-number">5</span>个字节，后者占用<span class="hljs-number">4</span>个字节，存储年使用<span class="hljs-built_in">YEAR</span>，存储日期使用<span class="hljs-built_in">DATE</span>，存储时间使用datetime<br></code></pre></td></tr></table></figure><ul><li>必须把字段定义为NOT NULL并设默认值</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">解读：<br><br>（<span class="hljs-number">1</span>）<span class="hljs-literal">NULL</span>的列使用索引，索引统计，值都更加复杂，MySQL更难优化<br><br>（<span class="hljs-number">2</span>）<span class="hljs-literal">NULL</span>需要更多的存储空间<br><br>（<span class="hljs-number">3</span>）<span class="hljs-literal">NULL</span>只能采用IS <span class="hljs-literal">NULL</span>或者IS NOT <span class="hljs-literal">NULL</span>，而在=<span class="hljs-regexp">/!=/i</span>n/not in时有大坑<br></code></pre></td></tr></table></figure><ul><li>使用INT UNSIGNED存储IPv4，不要用char(15)</li><li>使用varchar(20)存储手机号，不要使用整数</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">解读：<br><br>（<span class="hljs-number">1</span>）牵扯到国家代号，可能出现+<span class="hljs-regexp">/-/</span>()等字符，例如+<span class="hljs-number">86</span><br><br>（<span class="hljs-number">2</span>）手机号不会用来做数学运算<br><br>（<span class="hljs-number">3</span>）varchar可以模糊查询，例如like ‘<span class="hljs-number">138</span>%’<br></code></pre></td></tr></table></figure><ul><li>使用TINYINT来代替ENUM</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">解读：<span class="hljs-keyword">ENUM</span>增加新值要进行DDL操作<br></code></pre></td></tr></table></figure><h3 id="五、索引规范"><a href="#五、索引规范" class="headerlink" title="五、索引规范"></a>五、索引规范</h3><ul><li>唯一索引使用uniq_[字段名]来命名</li><li>非唯一索引使用idx_[字段名]来命名</li><li>单张表索引数量建议控制在5个以内</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">解读：<br><br>（<span class="hljs-number">1</span>）互联网高并发业务，太多索引会影响写性能<br><br>（<span class="hljs-number">2</span>）生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引<br><br>（<span class="hljs-number">3</span>）异常复杂的查询需求，可以选择<span class="hljs-built_in">ES</span>等更为适合的方式存储<br></code></pre></td></tr></table></figure><ul><li>组合索引字段数不建议超过5个</li></ul><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">解读：如果<span class="hljs-number">5</span>个字段还不能极大缩小<span class="hljs-built_in">row</span>范围，八成是设计有问题<br></code></pre></td></tr></table></figure><ul><li>不建议在频繁更新的字段上建立索引</li><li>非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">解读：踩过因为<span class="hljs-keyword">JOIN</span>字段类型不一致，而导致全表扫描的坑么？<br></code></pre></td></tr></table></figure><ul><li>理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)</li></ul><h3 id="六、SQL规范"><a href="#六、SQL规范" class="headerlink" title="六、SQL规范"></a>六、SQL规范</h3><ul><li>禁止使用select *，只获取必要字段</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">解读：<br><br>（<span class="hljs-number">1</span>）select *会增加cpu<span class="hljs-regexp">/io/</span>内存/带宽的消耗<br><br>（<span class="hljs-number">2</span>）指定字段能有效利用索引覆盖<br><br>（<span class="hljs-number">3</span>）指定字段查询，在表结构变更时，能保证对应用程序无影响<br></code></pre></td></tr></table></figure><ul><li>insert必须指定字段，禁止使用insert into T values()</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">解读：指定字段插入，在表结构变更时，能保证对应用程序无影响<br></code></pre></td></tr></table></figure><ul><li>隐式类型转换会使索引失效，导致全表扫描</li><li>禁止在where条件列使用函数或者表达式</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">解读：导致不能命中索引，全表扫描<br></code></pre></td></tr></table></figure><ul><li>禁止负向查询以及%开头的模糊查询</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">解读：导致不能命中索引，全表扫描<br></code></pre></td></tr></table></figure><ul><li>禁止大表JOIN和子查询</li><li>同一个字段上的OR必须改写问IN，IN的值必须少于50个</li><li>应用程序必须捕获SQL异常</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">解读：方便定位线上问题<br></code></pre></td></tr></table></figure><p><strong>重点：</strong></p><ul><li>创建表时必须使用InnoDB引擎</li><li>创建表一定要创建主键，主键用无符号的整数自增主键</li><li>如果查询的列是普通列。又想要提高查询性能，那么给这一列加上索引。</li><li>一张表中最多5个索引列</li><li>索引的应用场景是读多写少</li><li>在完成建库建表遵守各种规范后，sql的性能是否ok，就需要关心sql语句能否命中索引。</li></ul><h1 id="七、Explain-——-SQL优化神器"><a href="#七、Explain-——-SQL优化神器" class="headerlink" title="七、Explain —— SQL优化神器"></a>七、Explain —— SQL优化神器</h1><h2 id="1-Explain的介绍"><a href="#1-Explain的介绍" class="headerlink" title="1. Explain的介绍"></a>1. Explain的介绍</h2><p>阿里云rds提供了慢sql的查询功能</p><p>在完成工程结构的优化之后，数据库、表、表中的字段以及表的索引都能够支持海量数据的快速查找。但是查找依然需要通过SQL语句来实现，因此性能优秀的SQL语句是能够走索引，快速查找到数据的，性能不OK的语句，就不会走索引，导致全表扫描。</p><p>找到慢SQL后，如何做优化，以及如何查询一条SQL语句是否是慢SQL，那就可以通过Explain工具。</p><p>通过在SQL语句前面加上Explain关键字来执行，于是就能看出当前SQL语句的执行性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> weixin_article_weixiao <span class="hljs-keyword">where</span> title <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;医%&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20211222230315179.png" alt="image-20211222230315179"></p><h2 id="2-MySQL的内部优化器"><a href="#2-MySQL的内部优化器" class="headerlink" title="2. MySQL的内部优化器"></a>2. MySQL的内部优化器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">show</span> warnings;<br></code></pre></td></tr></table></figure><p>在执行上面这条SQL语句的时候，MySQL内部优化器会把语句转换成下面这条SQL，因为这样性能更好（直接通过索引里获取数据）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">*</span> <span class="hljs-keyword">select</span>#<span class="hljs-number">1</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span> <span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">AS</span> `id`,<span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">AS</span> `name` <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;db_mysql_pro&#x27;</span>.`tb_book` <span class="hljs-keyword">where</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="3-Explain中各个列的细节"><a href="#3-Explain中各个列的细节" class="headerlink" title="3. Explain中各个列的细节"></a>3. Explain中各个列的细节</h2><h5 id="1-select-type列"><a href="#1-select-type列" class="headerlink" title="1. select_type列"></a>1. select_type列</h5><p>该列描述了查询的类型：</p><ul><li>simple：简单查询</li><li>primary：外部的主查询</li><li>derived：在from后面进行的子查询，会产生衍生表</li><li>subquery：在from前面进行的子查询</li><li>union：进行的联合查询</li></ul><p>来自于简单的查询：simple</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>来自于复杂的查询：除simple外的其它类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> tb_author <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) der;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20211222233206508.png" alt="image-20211222233206508"></p><h5 id="2-table列"><a href="#2-table列" class="headerlink" title="2. table列"></a>2. table列</h5><p>这一列表示该sql正在访问哪一张表。也可以看出正在访问的衍生表<derivedN></p><h5 id="3-type列"><a href="#3-type列" class="headerlink" title="3. type列"></a>3. type列</h5><p>通过type列，可以直接的看出SQL语句的查询性能，性能从大到小的排列：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">null</span>&gt;<span class="hljs-keyword">system</span>&gt;const&gt;eq_ref&gt;<span class="hljs-keyword">ref</span>&gt;range&gt;<span class="hljs-keyword">index</span>&gt;<span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>不同的级别的情况：</p><ul><li>null：</li></ul><p>一般在查询时使用了聚合函数，于是直接从索引树里获取数据，而不用查询表中的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id) <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><ul><li>const：</li></ul><p>在进行查询时，查询的条件，使用了主键列或者唯一索引键的列与常量进行比较，这种性能是非常快的。</p><ul><li>system：</li></ul><p>是const的特殊情况，一般在衍生表里，直接匹配一条记录，就是system。</p><ul><li>eq_ref：</li></ul><p>在进行连接查询时，连接查询的条件中使用了本表的主键进行关联，因此这种类型的sql就是eq_ref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book_author <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> tb_book <span class="hljs-keyword">on</span> tb_book_author.book_id <span class="hljs-operator">=</span> tb_book.id;<br></code></pre></td></tr></table></figure><ul><li>ref：</li></ul><p>简单查询：</p><p>使用普通列作为查询条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;book1&#x27;</span><br></code></pre></td></tr></table></figure><p>复杂查询里：</p><p>在进行连接查询时，连接查询的条件中使用了本表的联合索引列，所以这种类型的sql就是ref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> book_id <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> tb_book_author <span class="hljs-keyword">on</span> tb_book.id <span class="hljs-operator">=</span> tb_book_auhtor.book_id<br></code></pre></td></tr></table></figure><ul><li>range：</li></ul><p>在索引列上使用了范围查找，性能是OK的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_author <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>index：</li></ul><p>在查询表中的所有的记录，但是所有的记录可以直接从索引树上获取，因此这种sql的查询就是index</p><p>tb_book中的所有列：id和name都是索引列</p><ul><li>ALL</li></ul><p>全表扫描。就是要从头到尾对表中的数据扫描一遍。这种查询性能一定是要做优化的。</p><h5 id="4-id列"><a href="#4-id列" class="headerlink" title="4. id列"></a>4. id列</h5><p>在复杂查询中，多条sql语句，谁的id大，谁先执行。如果多条sql语句的id一样大，那么谁在上面，谁先执行。</p><h5 id="5-possible-keys列"><a href="#5-possible-keys列" class="headerlink" title="5.possible_keys列"></a>5.possible_keys列</h5><p>这一次查询可能使用到的索引（名称）。为什么要设计这一列呢？因为在实际MySQL内部优化器做优化选择时，虽然我们写的sql语句是使用了索引列，但是MySQL内部优化器发现，使用索引列查找的性能并没有比全表扫描的性能要好，于是MySQL内部优化器选择使用全表扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;customer%&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="6-key列"><a href="#6-key列" class="headerlink" title="6. key列"></a>6. key列</h5><p>MySQL内部优化器最终选择是否使用索引来进行查找。</p><h5 id="7-key-len列"><a href="#7-key-len列" class="headerlink" title="7. key_len列"></a>7. key_len列</h5><p>这一列的主要作用，通过查看这一列的数值，推断出本sql选择了联合索引中的哪几列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- idx_name_age_position (`name`,`age`,`position`)</span><br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;customer100&#x27;</span>;# key_len <span class="hljs-operator">=</span> <span class="hljs-number">74</span><br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;customer100&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;# key_len <span class="hljs-operator">=</span> <span class="hljs-number">78</span><br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;customer100&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> position <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;dev&#x27;</span>;# key_len <span class="hljs-operator">=</span> <span class="hljs-number">140</span><br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;customer100&#x27;</span> <span class="hljs-keyword">and</span> position <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;dev&#x27;</span>;# key_len <span class="hljs-operator">=</span> <span class="hljs-number">74</span> 能看出此<span class="hljs-keyword">sql</span>只走了name列的索引<br></code></pre></td></tr></table></figure><h5 id="8-extra列"><a href="#8-extra列" class="headerlink" title="8. extra列"></a>8. extra列</h5><p>这一列展示了这条sql的一些其他信息</p><ul><li>using index</li></ul><p>使用了覆盖索引</p><ul><li>using where</li></ul><p>where的条件没有使用索引列。这种性能是不ok的，我们如果条件 允许可以给列设置索引，也同样尽可能的使用覆盖索引。</p><ul><li>using index condition</li></ul><p>查询的列没有完全被索引覆盖，并且where条件中使用了普通索引</p><h1 id="十、锁的定义及分类"><a href="#十、锁的定义及分类" class="headerlink" title="十、锁的定义及分类"></a>十、锁的定义及分类</h1><h2 id="1-锁的定义"><a href="#1-锁的定义" class="headerlink" title="1. 锁的定义"></a>1. 锁的定义</h2><p>锁是用来协调在多个线程并发访问同一共享资源时带来的安全问题。如果我们频繁的使用锁，在并发非常大的时候会带来性能问题。频繁用锁必然会造成性能问题，但不用锁，又会造成安全问题，MySQL在安全问题和性能方面是如何做权衡的。</p><h2 id="2-锁的分类"><a href="#2-锁的分类" class="headerlink" title="2. 锁的分类"></a>2. 锁的分类</h2><h3 id="1-从性能上划分：乐观锁和悲观锁"><a href="#1-从性能上划分：乐观锁和悲观锁" class="headerlink" title="1. 从性能上划分：乐观锁和悲观锁"></a>1. 从性能上划分：乐观锁和悲观锁</h3><ul><li>乐观锁（并发性能是比较好的）：CAS自旋锁，是非常典型的乐观锁。乐观的认为，当前系统环境下的并发量并不是很大，当真的有并发发生的时候，才会去上锁。</li><li>悲观锁：悲观的认为当前系统情况下并发情况是非常严重的，所有的任务在执行时都要上锁。保证了安全性，牺牲了并发性。</li></ul><h3 id="2-从数据操作的类型上划分：读锁和写锁"><a href="#2-从数据操作的类型上划分：读锁和写锁" class="headerlink" title="2. 从数据操作的类型上划分：读锁和写锁"></a>2. 从数据操作的类型上划分：读锁和写锁</h3><p>这两种所都属于悲观锁。</p><ul><li><p><strong>读锁（共享锁&#x2F;S锁）</strong>：对于的读取同一行数据的并发来说，是可以同时进行的，但是写不行。</p></li><li><p><strong>写锁（排它锁&#x2F;X锁）</strong>：在上了写锁之后及释放写锁之前，所有的其他并发操作（包括读和写），都不能进行。</p><table><thead><tr><th>兼容性</th><th>S</th><th>X</th></tr></thead><tbody><tr><td>S</td><td>兼容</td><td>不兼容</td></tr><tr><td>X</td><td>不兼容</td><td>不兼容</td></tr></tbody></table></li></ul><h3 id="3-从数据的操作粒度上来划分：表锁和行锁"><a href="#3-从数据的操作粒度上来划分：表锁和行锁" class="headerlink" title="3. 从数据的操作粒度上来划分：表锁和行锁"></a>3. 从数据的操作粒度上来划分：表锁和行锁</h3><ul><li>表锁：对整张表进行上锁。</li><li>行锁：对表中的某一行记录进行上锁。</li></ul><h3 id="4-表锁"><a href="#4-表锁" class="headerlink" title="4. 表锁"></a>4. 表锁</h3><p>MyISAM默认是支持表锁的，也就是说在默认情况下多个并发操作时，一个线程操作MyISAM表后，相当于是获取了该表的表锁，其他所有的操作都不能进行。</p><p>InnoDB怎么上表锁：</p><ul><li>手动上锁：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 格式<br>lock <span class="hljs-keyword">table</span> 表<span class="hljs-number">1</span> read<span class="hljs-operator">/</span>write,表<span class="hljs-number">2</span> read<span class="hljs-operator">/</span>write;<br># 示例<br>lock <span class="hljs-keyword">table</span> tb_book read;<br></code></pre></td></tr></table></figure><p>读锁：当前会话能读能写，其它会话只能读不能写。</p><ul><li>查看当前会话获取的所有锁：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">open</span> tables;<br></code></pre></td></tr></table></figure><ul><li>释放当前会话的所有锁，不会把其它会话持有的锁释放掉。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables;<br></code></pre></td></tr></table></figure><h3 id="5-行锁"><a href="#5-行锁" class="headerlink" title="5. 行锁"></a>5. 行锁</h3><p>InnoDB支持行锁，在并发事务里，每个事务的读写删的操作，相当于是上了行锁。也可以通过”for update” 为 select 上行锁。</p><p>行锁的特点：上锁的开销大，加锁速度慢，但是细粒度更细，并发性更好。这也是InnoDB和MyISAM的区别。</p><p>上行锁的两种方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> tb_author <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;m&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_author <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><h3 id="6-事务的特性"><a href="#6-事务的特性" class="headerlink" title="6. 事务的特性"></a>6. 事务的特性</h3><ul><li>原子性：一个事务是一给最小（原子）的操作单位，一个事务中的多条sql语句要么同时成功，要么同时失败。</li><li>一致性：事务提交之前和回滚之后的数据是一致性的。</li><li>持久性：一旦事务被提交，对数据的影响是持久的。</li><li>隔离性：多个事务在并发操作下提供了一套隔离机制，通过设置不同的隔离级别会有不同的并发效果。</li></ul><h3 id="7-事务的隔离级别"><a href="#7-事务的隔离级别" class="headerlink" title="7. 事务的隔离级别"></a>7. 事务的隔离级别</h3><ul><li><p><strong>read uncommitted</strong>: 读未提交，一个事务读到另一个事务没有提交的数据，这种情况称为脏读。</p></li><li><p><strong>Read committed</strong>: 读已提交。一个事务中能读到另一个事务已经提交的数据，那么就出现了不可重复读，也就是说多次读到的数据有可能是不一致的。</p></li><li><p><strong>repeatable read</strong>（mysql默认隔离级别）: 可重复读，就是为了解决不可重复读的问题。会出现幻读（虚读）的情况。</p><p>幻读：在事务A中3插入数据时，该条数据已经被事务B插入了，那么在事务A中就不能进行插入，但事务A的查询依然是查不到该事务的。</p><p>解决：通过上行锁，或者设置隔离级别为Serializable。</p></li><li><p><strong>Serializable</strong>: 序列化，相当于是上了表锁。性能非常差，所以不要考虑。</p></li></ul><h3 id="8-MVCC思想"><a href="#8-MVCC思想" class="headerlink" title="8. MVCC思想"></a>8. MVCC思想</h3><h4 id="8-1-什么是MVCC"><a href="#8-1-什么是MVCC" class="headerlink" title="8.1 什么是MVCC"></a>8.1 什么是MVCC</h4><p><strong>多版本控制</strong>: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，<strong>只有写写之间相互阻塞</strong>，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。</p><p>在内部实现中，InnoDB通过undo log保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。</p><p>MVCC只在<code>已提交读</code>（Read Committed）和<code>可重复读</code>（Repeatable Read）两个隔离级别下工作，其他两个隔离级别和MVCC是不兼容的。因为未提交读，总数读取最新的数据行，而不是读取符合当前事务版本的数据行。而串行化（Serializable）则会对读的所有数据多加锁。</p><p>MVCC的实现原理主要是依赖<strong>每一行记录中两个隐藏字段，undo log，ReadView</strong></p><h4 id="8-2-MVCC相关的一些概念"><a href="#8-2-MVCC相关的一些概念" class="headerlink" title="8.2 MVCC相关的一些概念"></a>8.2 MVCC相关的一些概念</h4><p>这里我们先来理解下有关MVCC相关的一些概念，这些概念都理解后，我们会通过实际例子来演示MVCC的具体工作流程是怎么样的。</p><h5 id="1、事务版本号"><a href="#1、事务版本号" class="headerlink" title="1、事务版本号"></a>1、事务版本号</h5><blockquote><p>事务每次开启时，都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。</p></blockquote><p>也就是每当begin的时候,首选要做的就是从数据库获得一个自增长的事务ID,它也就是当前事务的事务ID。</p><h5 id="2、隐藏字段"><a href="#2、隐藏字段" class="headerlink" title="2、隐藏字段"></a>2、隐藏字段</h5><p>对于InnoDB存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>,如果数据表中存在主键或者非NULL的UNIQUE键时不会创建row_id,否则InnoDB会自动生成单调递增的隐藏主键row_id。</p><table><thead><tr><th align="left">列名</th><th align="left">是否必须</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">row_id</td><td align="left">否</td><td align="left">单调递增的行ID，不是必需的，占用6个字节。 这个跟MVCC关系不大</td></tr><tr><td align="left">trx_id</td><td align="left">是</td><td align="left">记录操作该行数据事务的事务ID</td></tr><tr><td align="left">roll_pointer</td><td align="left">是</td><td align="left">回滚指针，指向当前记录行的undo log信息</td></tr></tbody></table><p>这里的记录操作，指的是insert|update|delete。对于delete操作而已，InnoDB认为是一个update操作，不过会更新一个另外的删除位，将行表示为deleted,并非真正删除。</p><h5 id="3、undo-log"><a href="#3、undo-log" class="headerlink" title="3、undo log"></a>3、undo log</h5><p><strong>undo log可以理解成回滚日志,它存储的是老版本数据</strong>。在表记录修改之前，会先把原始数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。或者如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本。</p><p>在insert&#x2F;update&#x2F;delete(本质也是做更新，只是更新一个特殊的删除位字段)操作时，都会产生undo log。</p><p>在InnoDB里，undo log分为如下两类：</p><p>1）<strong>insert undo log</strong> : 事务对insert新记录时产生的undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</p><p>2）<strong>update undo log</strong> : 事务对记录进行delete和update操作时产生的undo log，不仅在事务回滚时需要，快照读也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被删除。</p><p>undo log有什么用途呢？</p><blockquote><p>1、事务回滚时，保证原子性和一致性。<br>2、如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本(用于MVCC快照读)。</p></blockquote><h5 id="4、版本链"><a href="#4、版本链" class="headerlink" title="4、版本链"></a>4、版本链</h5><p>多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为<strong>版本链</strong>。如下：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240256260.jpeg" alt="img"></p><h5 id="5、快照读和当前读"><a href="#5、快照读和当前读" class="headerlink" title="5、快照读和当前读"></a>5、快照读和当前读</h5><p><strong>快照读</strong>： 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读,如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>当前读</strong>：读取的是记录数据的最新版本，显式加锁的都是当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> lock <span class="hljs-keyword">in</span> share mode;<br></code></pre></td></tr></table></figure><h5 id="6、ReadView"><a href="#6、ReadView" class="headerlink" title="6、ReadView"></a>6、ReadView</h5><blockquote><p>ReadView是事务在进行快照读的时候生成的记录快照, 可以帮助我们解决可见性问题的</p></blockquote><p>如果一个事务要查询行记录，需要读取哪个版本的行记录呢？ ReadView 就是来解决这个问题的。 ReadView 保存了<strong>当前事务开启时所有活跃的事务列表</strong>。换个角度，可以理解为: <strong>ReadView 保存了不应该让这个事务看到的其他事务 ID 列表。</strong></p><p>ReadView是如何保证可见性判断的呢？我们先看看 ReadView 的几个重要属性</p><ul><li><strong>trx_ids</strong>: 当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。(<code>重点注意</code>:这里的trx_ids中的活跃事务，<strong>不包括当前事务自己</strong>和已提交的事务，这点非常重要)</li><li><strong>low_limit_id</strong>: 目前出现过的最大的事务ID+1，即下一个将被分配的事务ID。</li><li><strong>up_limit_id</strong>: 活跃事务列表trx_ids中最小的事务ID，如果trx_ids为空，则up_limit_id 为 low_limit_id。</li><li><strong>creator_trx_id</strong>: 表示生成该 ReadView 的事务的 事务id</li></ul><p>访问某条记录的时候如何判断该记录是否可见,具体规则如下：</p><ul><li>如果被访问版本的 <code>事务ID = creator_trx_id</code>，那么表示当前事务访问的是自己修改过的记录，那么该版本对当前事务可见；</li><li>如果被访问版本的 <code>事务ID &lt; up_limit_id</code>，那么表示生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 <code>事务ID &gt; low_limit_id</code> 值，那么表示生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的 <code>事务ID在 up_limit_id和m_low_limit_id</code> 之间，那就需要判断一下版本的事务ID是不是在 trx_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；<br>如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>画张图来理解下</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240256514.jpeg" alt="img"></p><p>这里需要思考的一个问题就是 <code>何时创建ReadView？</code></p><p>上面说过,ReadView是来解决一个事务需要读取哪个版本的行记录的问题的。那么说明什么？只有在select的时候才会创建ReadView。但在不同的隔离级别是有区别的:</p><blockquote><p>在RC隔离级别下，是每个select都会创建最新的ReadView；而在RR隔离级别下，则是当事务中的第一个select请求才创建ReadView(下面会详细举例说明)。</p></blockquote><p>那insert&#x2F;update&#x2F;delete操作呢？</p><p>这样操作不会创建ReadView。但是这些操作在事务开启(begin)且其未提交的时候，那么它的事务ID,会存在在其它存在查询事务的ReadView记录中，也就是trx_ids中。</p><h4 id="8-3-MVCC实现原理分析"><a href="#8-3-MVCC实现原理分析" class="headerlink" title="8.3 MVCC实现原理分析"></a>8.3 MVCC实现原理分析</h4><h5 id="1、如何查询一条记录"><a href="#1、如何查询一条记录" class="headerlink" title="1、如何查询一条记录"></a>1、如何查询一条记录</h5><ol><li>获取事务自己事务ID,即trx_id。(这个也不是select的时候获取的，而是这个事务开启的时候获取的 也就是begin的时候)</li><li>获取ReadView(这个才是select的时候才会生成的)</li><li>数据库表中如果查询到数据，那就到ReadView中的事务版本号进行比较。</li><li>如果不符合ReadView的可见性规则， 即就需要Undo log中历史快照,直到返回符合规则的数据;</li></ol><p>InnoDB 实现MVCC，是通过<code>ReadView + Undo Log</code> 实现的，Undo Log 保存了历史快照，ReadView可见性规则帮助判断当前版本的数据是否可见。</p><h5 id="2、MVCC是如何实现读已提交和可重复读的呢？"><a href="#2、MVCC是如何实现读已提交和可重复读的呢？" class="headerlink" title="2、MVCC是如何实现读已提交和可重复读的呢？"></a>2、MVCC是如何实现读已提交和可重复读的呢？</h5><p>其实其它流程都是一样的，读已提交和可重复读唯一的区别在于：在RC隔离级别下，是每个select都会创建最新的ReadView；而在RR隔离级别下，则是当事务中的第一个select请求才创建ReadView。</p><p>看完下面这个例子你应该就明白了。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240256604.jpeg" alt="img"></p><h4 id="8-4-经典面试题-MVCC能否解决了幻读问题呢？"><a href="#8-4-经典面试题-MVCC能否解决了幻读问题呢？" class="headerlink" title="8.4 经典面试题:MVCC能否解决了幻读问题呢？"></a>8.4 经典面试题:MVCC能否解决了幻读问题呢？</h4><p>有关这个问题查了很多资料,有的说能解决，有的说不能解决，也有人说能解决部分幻读场景。这里部分解决指的是能解决快照读的幻读问题，不能解决当前读的幻读问题。</p><p>具体可以看下面这篇文章</p><p>面试题之：MVCC能否解决幻读？<a href="https://blog.csdn.net/qq_35590091/article/details/107734005">https://blog.csdn.net/qq_35590091/article/details/107734005</a></p><p>先说我的结论:</p><blockquote><p>MVCC能解决不可重复读问题,但是不能解决幻读问题，不论是快照读和当前读都不能解决。RR级别解决幻读靠的是锁机制,而不是MVCC机制。</p></blockquote><p>既然网上那么多人说，MVCC解决能解决快照读下的幻读问题， 那这里通过举示例来说明,MVCC解决不了快照读的幻读问题。</p><p>假设有张用户表,这张表的 id 是主键。表中一开始有4条数据。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240256040.jpeg" alt="img"></p><p>这里是在RR级别下研究(可重复读)。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240256564.jpeg" alt="img"></p><p>1、事务A,查询是否存在 id&#x3D;5 的记录，没有则插入，这是我们期望的正常业务逻辑。</p><p>2、这个时候 事务B 新增的一条 id&#x3D;5 的记录，并提交事务。</p><p>3、事务A,再去查询 id&#x3D;5 的时候,发现还是没有记录。</p><p>上面的文章是这样来举例说明,事务A第一次和第二次读到的是一样的，所以认为解决了幻读。我不认为这个是解决了幻读，而是解决了不可能重复读。它保证了第一次和第二次所读到的结果是一样的。</p><p>解决幻读了吗？显然没有，因为这个时候如果事务A执行一条插入操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>` (`id`, `name`, `pwd`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;田七&#x27;</span>, <span class="hljs-string">&#x27;fff&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240256986.jpeg" alt="img"></p><p>最终 事务A 提交事务，发现报错了。这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是幻读问题。</p><p>所以说MVCC是不能解决的，要想解决还是需要锁。</p><p>这里事务A能正常的插入的前提就是其它事务不能插入id&#x3D;5并提交成功。要解决这个问题也很简单，就是事务A先获得id&#x3D;5这个排它锁。</p><p>我们可以在事务A第一次查询的时候加一个排他锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>  <span class="hljs-keyword">from</span> `<span class="hljs-keyword">user</span>` <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>那么事务B的插入动作永远属于堵塞状态，直到事务A插入成功，并提交。那么最终是事务B报主键冲突而回滚。但事务A不会因为查询的时候没有这条记录，插入失败。也就解决了幻读问题。</p><p>所以说 RR级别下解决幻读问题靠的是锁机制，而不是MVCC机制。</p><h3 id="9-死锁"><a href="#9-死锁" class="headerlink" title="9. 死锁"></a>9. 死锁</h3><p>所谓的死锁就是在多个并发中，事务A和事务B都持有对方需要的锁，且双方都没办法释放手中的锁。</p><h3 id="10-间隙锁"><a href="#10-间隙锁" class="headerlink" title="10. 间隙锁"></a>10. 间隙锁</h3><p>所谓的间隙锁，就是通过范围来上锁，对满足范围的区间实现上锁的效果。</p><h3 id="11-临键锁"><a href="#11-临键锁" class="headerlink" title="11. 临键锁"></a>11. 临键锁</h3><h3 id="12-意向锁"><a href="#12-意向锁" class="headerlink" title="12. 意向锁"></a>12. 意向锁</h3><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/qdhxhz/p/15750866.html">看一遍就懂：MVCC原理详解 </a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MySQL</category>
      
      <category>MySQL基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL架构篇</title>
    <link href="/2021/12/25/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/"/>
    <url>/2021/12/25/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL架构篇"><a href="#MySQL架构篇" class="headerlink" title="MySQL架构篇"></a><strong>MySQL架构篇</strong></h1><h2 id="一、MySQL服务器环境"><a href="#一、MySQL服务器环境" class="headerlink" title="一、MySQL服务器环境"></a><strong>一、MySQL服务器环境</strong></h2><ul><li><p>OS：CentOS 7.6</p></li><li><p>MySQL：MySQL 5.7.30</p></li></ul><h2 id="二、MySQL架构图"><a href="#二、MySQL架构图" class="headerlink" title="二、MySQL架构图"></a><strong>二、MySQL架构图</strong></h2><h3 id="2-1-逻辑架构图"><a href="#2-1-逻辑架构图" class="headerlink" title="2.1 逻辑架构图"></a><strong>2.1 逻辑架构图</strong></h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254857.png" alt="逻辑架构图"></p><ul><li><strong>Connectors连接器：</strong>负责跟客户端建立连接</li><li><strong>Management Serveices &amp; Utilities系统管理和控制工具</strong></li><li><strong>Connection Pool连接池：</strong>管理用户连接，监听并接收连接的请求，转发所有连接的请求到线程管理模块</li><li><strong>SQL Interface SQL接口：</strong>接受用户的SQL命令，并且返回SQL执行结果</li><li><strong>Parser解析器：</strong>SQL传递到解析器的时候会被解析器验证和解析</li><li><strong>Optimizer查询优化器：</strong>SQL语句在查询之前会使用查询优化器对查询进行优化</li><li><strong>Cache和Buffer查询缓存：</strong>在MySQL5.7中包含缓存组件。在MySQL8中移除了</li><li><strong>Pluggable Storage Engines存储引擎：</strong>存储引擎就是存取数据、建立与更新索引、查询数据等技术的实现方法</li></ul><h3 id="2-2-MySQL日志文件"><a href="#2-2-MySQL日志文件" class="headerlink" title="2.2 MySQL日志文件"></a><strong>2.2 MySQL日志文件</strong></h3><p>MySQL是通过文件系统对数据索引后进行存储的，MySQL从物理结构上可以分为<strong>日志文件</strong>和<strong>数据及索引文件</strong>。MySQL在Linux中的数据索引文件和日志文件通常放在&#x2F;var&#x2F;lib&#x2F;mysql目录下。MySQL通过日志记录了数据库操作信息和错误信息。</p><p><strong>常用日志文件如下：</strong></p><ol><li><p>错误日志：&#x2F;var&#x2F;log&#x2F;mysql-error.log</p></li><li><p>二进制日志：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql-bin</p></li><li><p>查询日志：</p></li><li><p>慢查询日志：slow_query_log.log</p></li><li><p>事务重做日志：redo log</p></li><li><p>中继日志：relay log</p></li><li><p>…</p></li></ol><p>可以通过命令查看当前数据库中的日志使用信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;log_%&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254751.png" alt="日志信息"></p><h4 id="错误日志：error-log"><a href="#错误日志：error-log" class="headerlink" title="错误日志：error log"></a><strong>错误日志：error log</strong></h4><p>默认开启，错误日志记录了运行过程中<strong>遇到的所有严重的错误信息</strong>，以及 MySQL<strong>每次启动和关闭的详细信息</strong>。错误日志所记录的信息是可以通过<strong>log_error和log_warnings配置</strong>来定义的。从5.5.7以后无法关闭错误日志。</p><ul><li><p>log_error：指定错误日志存储位置</p></li><li><p>log-warnings：是否将警告信息输出到错误日志中。</p><ul><li><p>log_warnings 为0， 表示不记录告警信息。</p></li><li><p>log_warnings 为1， 表示告警信息写入错误日志。</p></li><li><p>log_warnings 大于1， 表示各类告警信息，例如：有关网络故障的信息和重新连接信息写入错误日志。</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">log_error=/var/log/mysql-error.log<br>log_warnings=2<br></code></pre></td></tr></table></figure><h4 id="二进制日志：bin-log"><a href="#二进制日志：bin-log" class="headerlink" title="二进制日志：bin log"></a><strong>二进制日志：bin log</strong></h4><p>默认关闭，需要通过以下配置进行开启。binlog记录了数据库所有的ddl语句和dml语句，但不包括select语句内容，语句以事件的形式保存，描述了数据的变更顺序，binlog还包括了每个更新语句的执行时间信息。如果是DDL语句，则直接记录到binlog日志，而DML语句，必须通过事务提交才能记录到binlog日志中。</p><p>binlog主要用于实现mysql<strong>主从复制、数据备份、数据恢复。</strong></p><p>配置中mysql-bin是binlog日志文件的basename，binlog日志文件的完整名称：mysql-bin.000001。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">server_id=42<br>log-bin=mysql-bin<br></code></pre></td></tr></table></figure><blockquote><p>数据定义语言：简称DDL(Data Definition Language)</p><ul><li><p>作用：用来定义数据库对象：数据库，表，列等。</p></li><li><p>关键字：create，alter，drop等</p></li></ul><p>数据操作语言：简称DML(Data Manipulation Language)，</p><ul><li>作用：用来对数据库中表的记录进行更新。</li><li>关键字：insert，delete，update等</li></ul><p>数据查询语言：简称DQL(Data Query Language)</p><ul><li>作用：用来查询数据库中表的记录。</li><li>关键字：select，from，where等</li></ul><p>数据控制语言：简称DCL(Data Control Language)</p><ul><li>作用：用来定义数据库的访问权限和安全级别，及创建用户。</li></ul></blockquote><h4 id="通用查询日志：general-query-log"><a href="#通用查询日志：general-query-log" class="headerlink" title="通用查询日志：general query log"></a><strong>通用查询日志：general query log</strong></h4><p><strong>默认关闭，</strong>由于通用查询日志会记录用户的所有操作，其中还包含增删查改等信息，在并发操作大的环境下会产生大量的信息从而导致不必要的磁盘IO，会影响mysql的性能的。</p><p>如果不是为了调试数据库，不建议开启查询日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询通用查询日志变量信息<br>mysql&gt; show global variables like &#x27;%general_log%&#x27;;<br></code></pre></td></tr></table></figure><p>开启方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 启动开关<br>general_log=&#123;ON\|OFF&#125;<br># 日志文件变量，而general_log_file如果没有指定，默认名是host_name.log<br>general_log_file=/var/lib/mysql/host_name.log<br></code></pre></td></tr></table></figure><h4 id="慢查询日志：slow-query-log"><a href="#慢查询日志：slow-query-log" class="headerlink" title="慢查询日志：slow query log"></a><strong>慢查询日志：slow query log</strong></h4><p><strong>默认关闭，</strong>通过以下设置开启。记录执行时间超过<strong>long_query_time</strong>秒的所有查询，便于收集查询时间比较长的SQL语句。</p><p>查看阈值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show global status like &#x27;%Slow_queries%&#x27;;<br>show variables like &#x27;%slow_query%&#x27;;<br>show variables like &#x27;long_query_time%&#x27;;<br></code></pre></td></tr></table></figure><p>配置慢查询开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 开启慢查询日志<br>slow_query_log=ON<br># 慢查询的阈值，单位秒<br>long_query_time=10<br># 日志记录文件<br># 如果没有给出file_name值，默认为主机名，后缀为-slow.log。<br># 如果给出了文件名，但不是绝对路径名，文件则写入数据目录。<br>slow_query_log_file=slow_query_log.log<br></code></pre></td></tr></table></figure><h3 id="2-3-MySQL数据文件"><a href="#2-3-MySQL数据文件" class="headerlink" title="2.3 MySQL数据文件"></a><strong>2.3 MySQL数据文件</strong></h3><p>查看MySQL数据文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%datadir%&#x27;;<br></code></pre></td></tr></table></figure><p><strong>ibdata文件：</strong>使用<strong>系统表空间</strong>存储表数据和索引信息，所有表共同使用一个或者多个ibdata文件。</p><p><strong>InnoDB存储引擎的数据文件：</strong></p><ul><li><strong>.frm文件：</strong>主要存放与表相关的数据信息，主要包括<strong>表结构的定义信息</strong></li><li><strong>.ibd：</strong>使用独享表空间存储表<strong>数据和索引</strong>信息，一张表对应一个ibd文件。</li></ul><p><strong>MyISAM存储引擎的数据文件：</strong></p><ul><li><p><strong>.frm文件：</strong>主要存放与表相关的数据信息，主要包括表结构的定义信息</p></li><li><p><strong>.myd文件：</strong>主要用来存储表数据信息。</p></li><li><p><strong>.myi文件：</strong>主要用来存储表数据文件中任何索引的数据树。</p></li></ul><h3 id="2-4-案例：一条SQL语句的完整执行流程"><a href="#2-4-案例：一条SQL语句的完整执行流程" class="headerlink" title="2.4 案例：一条SQL语句的完整执行流程"></a><strong>2.4 案例：一条SQL语句的完整执行流程</strong></h3><h4 id="Sql语句执行流程"><a href="#Sql语句执行流程" class="headerlink" title="Sql语句执行流程"></a><strong>Sql语句执行流程</strong></h4><p>分析SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select c_id,first_name,last_name from customer where c_id=14;<br></code></pre></td></tr></table></figure><p>大体来说，MySQL 可以分为 <strong>Server层</strong>和<strong>存储引擎层</strong>两部分：</p><ol><li><p><strong>Server层</strong></p><ul><li><p>包括：连接器、查询缓存、分析器、优化器、执行器等</p><ul><li><p>涵盖 MySQL的大多数核心服务功能</p></li><li><p>所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现</p><ul><li>比如：存储过程、触发器、视图等</li></ul></li></ul></li></ul></li><li><p><strong>存储引擎层：</strong></p><ul><li><p>负责数据的存储和提取</p></li><li><p>可插拔式存储引擎：InnoDB、MyISAM、Memory 等</p></li><li><p>最常用存储引擎是InnoDB</p></li><li><p>从MySQL 5.5版本开始，默认是InnoDB</p></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254732.png" alt="执行流程"></p><h4 id="第一步：连接到数据库"><a href="#第一步：连接到数据库" class="headerlink" title="第一步：连接到数据库"></a><strong>第一步：连接到数据库</strong></h4><p><strong>首先会连接到这个数据库上，这时候接待你的就是连接器。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-- 连接命令<br>mysql -h127.0.0.1 -P3306 -uroot -p<br></code></pre></td></tr></table></figure><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的默认值是 8 小时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show processlist;<br># 其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254103.png" alt="show processlist"></p><h4 id="第二步：查缓存"><a href="#第二步：查缓存" class="headerlink" title="第二步：查缓存"></a><strong>第二步：查缓存</strong></h4><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句hash之后的值，value是查询的结果。</p><ul><li><p>如果你的查询语句在缓存中，会被直接返回给客户端。</p></li><li><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。</p></li></ul><p>如果查询命中缓存，MySQL 不需要执行后面的复杂操作就可以直接返回结果，效率会很高！但是不建议使用MySQL的内置缓存功能</p><h5 id="1）案例：查询缓存"><a href="#1）案例：查询缓存" class="headerlink" title="1）案例：查询缓存"></a><strong>1）案例：查询缓存</strong></h5><p> 查询缓存默认是关闭的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1）查看是否开启缓存<br>mysql&gt; show variables like &#x27;query_cache_type&#x27;;<br># 2）查看缓存的命中次数：<br>mysql&gt; show status like &#x27;qcache_hits&#x27;;<br># 3）开启缓存<br>在/etc/my.cnf文件中修改“query_cache_type”参数<br>值为`0或OFF`会禁止使用缓存。<br>值为`1或ON`将启用缓存，但以`SELECT SQL_NO_CACHE`开头的语句除外。<br>值为`2或DEMAND`时，只缓存以`SELECT SQL_CACHE`开头的语句。<br></code></pre></td></tr></table></figure><p>修改配置文件 my.cnf ，在文件中增加如下内容开启缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">query_cache_type=2<br></code></pre></td></tr></table></figure><p>查询SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from city where city_id = 1;<br></code></pre></td></tr></table></figure><p><strong>清空查询缓存</strong></p><p>可以使用下面三个SQL来清理查询缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FLUSH QUERY CACHE; # 清理查询缓存内存碎片。<br>RESET QUERY CACHE; # 从查询缓存中移出所有查询。<br>FLUSH TABLES; # 关闭所有打开的表，同时该操作将会清空查询缓存中的内容。<br></code></pre></td></tr></table></figure><h5 id="2）为什么不建议使用MySQL的查询缓存？"><a href="#2）为什么不建议使用MySQL的查询缓存？" class="headerlink" title="2）为什么不建议使用MySQL的查询缓存？"></a><strong>2）为什么不建议使用MySQL的查询缓存？</strong></h5><p>因为查询缓存往往弊大于利</p><ul><li><strong>成本高：</strong>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。</li><li><strong>命中率不高：</strong>对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</li><li><strong>功能并不如专业的缓存工具更好：</strong>redis、memcache、ehcache...</li></ul><p>好在 MySQL 也提供了这种<strong>按需使用</strong>的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select sql_cache * from city where city_id = 1;<br></code></pre></td></tr></table></figure><blockquote><p>注意：MySQL 8.0 版本直接将查询缓存的整块功能删掉了</p></blockquote><h4 id="第三步：分析SQL语句"><a href="#第三步：分析SQL语句" class="headerlink" title="第三步：分析SQL语句"></a><strong>第三步：分析SQL语句</strong></h4><p>如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。客户端程序发送过来的请求，实际上只是一个字符串而已，所以MySQL服务器程序首先需要对这个字符串做分析，判断请求的语法是否正确，然后从字符串中将要查询的表、列和各种查询条件都提取出来，本质上是对一个SQL语句编译的过程，涉及<strong>词法解析</strong>、<strong>语法分析</strong>、<strong>预处理器</strong>等。</p><ul><li><strong>词法分析：</strong>词法分析就是把一个完整的 SQL 语句分割成一个个的字符串</li><li><strong>语法分析：</strong>语法分析器根据词法分析的结果做语法检查，判断你输入的SQL 语句是否满足 MySQL语法。</li><li><strong>预处理器：</strong>预处理器则会进一步去检查解析树是否合法，比如表名是否存在，语句中表的列是否存在等等，在这一步MySQL会检验用户是否有表的操作权限。</li></ul><h5 id="1）词法分析："><a href="#1）词法分析：" class="headerlink" title="1）词法分析："></a><strong>1）词法分析：</strong></h5><p>比如：这条简单的SQL语句，会被分割成10个字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 分隔前<br>select c_id,first_name,last_name from customer where c_id=14;<br># 分隔后<br>select，c_id,first_name,last_name，from，customer，where，c_id，=，14<br></code></pre></td></tr></table></figure><p>MySQL 同时需要识别出这个SQL语句中的字符串<strong>分别是什么，代表什么</strong>。</p><ul><li>把”select”这个关键字识别出来，这是一个查询语句</li><li>把“customer”识别成“表名 customer”</li><li>把“c_id识别成“列 c_id”。</li></ul><h5 id="2）语法分析："><a href="#2）语法分析：" class="headerlink" title="2）语法分析："></a><strong>2）语法分析：</strong></h5><p>如果语法正确就会根据 MySQL语法规则与SQL 语句生成一个数据结构，这个数据结构我们把它叫做<strong>解析树</strong>。</p><blockquote><p>“You have an error in your SQL syntax”错误提醒就是在这个位置出现的。</p></blockquote><p>比如：下面这个语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select c_id,first_name,last_name form customer where c_id=14;<br><br>[Err] 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;customer where c_id=14&#x27; at line 1<br># 错误原因：from 写为 form<br></code></pre></td></tr></table></figure><p>解析树举例：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254514.png" alt="解析树"></p><h5 id="3）预处理器："><a href="#3）预处理器：" class="headerlink" title="3）预处理器："></a><strong>3）预处理器：</strong></h5><p>预处理器则会进一步去检查<strong>解析树</strong>是否合法，比如表名是否存在，语句中表的列是否存在等等，在这一步MySQL会检验用户是否有表的操作权限。</p><p>预处理之后会得到一个新的解析树，然后调用对应执行模块</p><h4 id="第四步：优化SQL语句"><a href="#第四步：优化SQL语句" class="headerlink" title="第四步：优化SQL语句"></a><strong>第四步：优化SQL语句</strong></h4><p><strong>优化器顾名思义就是对查询进行优化。作用是根据解析树生成不同的执行计划，然后选择最优的执行计划。</strong></p><p>MySQL 里面使用的是基于成本模型的优化器，哪种<strong>执行计划Explain</strong>执行时成本最小就用哪种。而且它是io_cost和cpu_cost的开销总和，它通常也是我们评价一个查询的执行效率的一个常用指标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看上次查询成本开销，默认值是0<br>show status like &#x27;Last_query_cost&#x27;;<br></code></pre></td></tr></table></figure><p>优化器可以做哪些优化呢？</p><ol><li><p>当有多个索引可用的时候，决定使用哪个索引；</p></li><li><p>在一个语句有多表关联（join）的时候，决定各个表的连接顺序，以哪个表为基准表。</p></li></ol><p><strong>举个栗子：</strong></p><p>（1）比如hello数据库中表customer上执行下面的语句，这个语句用到了两个索引 last_name 和 address_id 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># hello数据库中表customer<br>explain select * from customer where last_name=&#x27;刘皇叔&#x27; and address_id=11;<br></code></pre></td></tr></table></figure><ul><li>既可以使用last_name索引查询，然后过滤列address_id</li><li>也可以使用address_id索引查询，然后过滤列last_name。</li></ul><p>两种执行计划的结果是一样的，但是执行效率会有所不同，<strong>而优化器的作用就是决定选择使用哪一个方案</strong>。</p><p>使用explain工具可以查看优化器的执行计划</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254396.png" alt="explain"></p><p>注意：优化器最多就是辅助，作用很有限，我们的SQL语句不能依赖于MySQL的优化器去调优！如果SQL语句垃圾，则没有可优化的空间。优化SQL的根本在于掌握MySQL分析与调优知识。</p><h4 id="第五步：执行SQL语句"><a href="#第五步：执行SQL语句" class="headerlink" title="第五步：执行SQL语句"></a><strong>第五步：执行SQL语句</strong></h4><h5 id="1）判断执行权限"><a href="#1）判断执行权限" class="headerlink" title="1）判断执行权限"></a><strong>1）判断执行权限</strong></h5><p>开始执行的时候，要先判断一下你对这个表customer有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p><h5 id="2）调用存储引擎接口查询"><a href="#2）调用存储引擎接口查询" class="headerlink" title="2）调用存储引擎接口查询"></a><strong>2）调用存储引擎接口查询</strong></h5><p>如果有权限，就使用指定的存储引擎打开表开始查询。执行器会根据表的引擎定义，去使用这个引擎提供的查询接口提取数据。</p><ul><li><p><strong>c_id</strong>是主键执行流程：</p><ul><li>调用 InnoDB 引擎接口，从主键索引中检索c_id&#x3D;14的记录。</li><li>主键索引等值查询只会查询出一条记录，直接将该记录返回客户端。</li><li>至此，这个语句就执行完成了。</li></ul></li><li><p><strong>c_id</strong>不是主键执行流程：全表扫描</p><ul><li><p>调用 InnoDB 引擎接口取这个表的第一行，判断c_id 值是不是 14，如果不是则跳过，如果是</p></li><li><p>则将这行缓存在结果集中；</p></li><li><p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p></li><li><p>执行器将上述遍历过程中所有满足条件的行组成的结果集返回给客户端。</p></li><li><p>至此，这个语句就执行完成了。</p></li></ul></li></ul><p><strong>举个栗子：</strong></p><p>比如：我们新建一个用户mysql_user，只有表actor的查询权限，没有表customer的查询权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER `mysql_user`@`localhost` IDENTIFIED BY &#x27;123456@heroA&#x27;;<br>GRANT Select ON TABLE `hello`.`test` TO `mysql_user`@`localhost`;<br></code></pre></td></tr></table></figure><p>使用这个用户mysql_user连接mysql，执行下面的查询语句，就会返回没有权限的错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -umysql_user -p123456@heroA<br>mysql&gt; select * from customer where c_id=14;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254034.png" alt="无权限错误"></p><h5 id="3）案例：存储引擎查看与设置"><a href="#3）案例：存储引擎查看与设置" class="headerlink" title="3）案例：存储引擎查看与设置"></a><strong>3）案例：存储引擎查看与设置</strong></h5><p>在MySQL中可以使用不同的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看支持的存储引擎<br>&gt; show engines<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254735.png" alt="show engines"></p><p>只有InnoDB引擎支持事务、行锁、外键。</p><p>在选择引擎时尽可能使用InnoDB引擎。</p><ul><li>MyISAM：早期版本默认的引擎。</li><li>Memory：所有的数据都是保存在内存中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 使用其他引擎，在mysql中默认使用InnoDB引擎，一个数据库中不同的表可以使用不同的引擎。<br>create table t_myisam(a int primary key, b int) engine=myisam;<br></code></pre></td></tr></table></figure><h2 id="三、MySQL的存储引擎之InnoDB"><a href="#三、MySQL的存储引擎之InnoDB" class="headerlink" title="三、MySQL的存储引擎之InnoDB"></a>三、<strong>MySQL的存储引擎之InnoDB</strong></h2><h3 id="3-1-存储引擎种类"><a href="#3-1-存储引擎种类" class="headerlink" title="3.1 存储引擎种类"></a><strong>3.1 存储引擎种类</strong></h3><table><thead><tr><th><strong>存储引擎</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>MyISAM</strong></td><td>高速引擎，拥有较高的插入，查询速度，<strong>但不支持事务</strong></td></tr><tr><td><strong>InnoDB</strong></td><td><strong>5.5版本后MySQL的默认数据库存储引擎，支持事务和行级锁</strong>，比MyISAM处理速度稍慢</td></tr><tr><td>ISAM</td><td>MyISAM的前身，MySQL5.0以后不再默认安装</td></tr><tr><td>MRG_MyISAM</td><td>将多个表联合成一个表使用，在超大规模数据存储时很有用</td></tr><tr><td><strong>Memory</strong></td><td><strong>内存存储引擎，拥有极高的插入，更新和查询效率。</strong>但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失。</td></tr><tr><td>Falcon</td><td>一种新的存储引擎，支持事务</td></tr><tr><td>Archive</td><td>将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作</td></tr><tr><td>CSV</td><td>CSV 存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换)</td></tr></tbody></table><p><strong>引擎怎么选择？</strong></p><p>归纳为一句话：<strong>除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该选择InnoDB引擎。</strong>也就是说，大部分情况下都选择InnoDB。</p><p><strong>InnoDB和MyISAM存储引擎区别：</strong></p><table><thead><tr><th align="left"><strong>比较项</strong></th><th align="left"><strong>Innodb</strong></th><th><strong>Myisam</strong></th></tr></thead><tbody><tr><td align="left"><strong>存储文件</strong></td><td align="left">.frm 表定义文件<br />.ibd 数据文件和索引文件</td><td>.frm 表定义文件<br />.myd 数据文件<br />.myi 索引文件</td></tr><tr><td align="left"><strong>锁</strong></td><td align="left">表锁、行锁</td><td>表锁</td></tr><tr><td align="left"><strong>事务</strong></td><td align="left">支持</td><td>不支持</td></tr><tr><td align="left"><strong>CRDU</strong></td><td align="left">读、写</td><td>读多</td></tr><tr><td align="left"><strong>索引结构</strong></td><td align="left">B+ Tree</td><td>B+ Tree</td></tr></tbody></table><h3 id="3-2-InnoDB架构图"><a href="#3-2-InnoDB架构图" class="headerlink" title="3.2 InnoDB架构图"></a><strong>3.2 InnoDB架构图</strong></h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254661.jpeg" alt="innoDb架构图"></p><p>上图详细展示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由<strong>内存结构、磁盘结构</strong>两部分组成。</p><h3 id="3-3-内存结构"><a href="#3-3-内存结构" class="headerlink" title="3.3 内存结构"></a><strong>3.3 内存结构</strong></h3><p>InnoDB 内存结构主要分为如下四个区域：</p><ol><li><p>Buffer Pool 缓冲池</p></li><li><p>Change Buffer 修改缓冲</p></li><li><p>Adaptive Hash Index 自适应索引</p></li><li><p>Log Buffer 日志缓冲</p></li></ol><h4 id="1）缓冲池-Buffer-Pool"><a href="#1）缓冲池-Buffer-Pool" class="headerlink" title="1）缓冲池(Buffer Pool)"></a><strong>1）缓冲池(Buffer Pool)</strong></h4><p>缓冲池Buffer Pool 用于加速数据的访问和修改，通过将热点数据缓存在内存的方法，最大限度地减少磁盘 IO，加速热点数据读写。</p><ul><li><p>默认大小为128M，Buffer Pool 中数据<strong>以页为存储单位</strong>，其实现的数据结构是<strong>以页为单位的单链表</strong>。</p></li><li><p>由于内存的空间限制，Buffer Pool 仅能容纳最热点的数据。</p></li><li><p>Buffer Pool 使用LRU算法（Least Recently Used 最近最少使用）淘汰非热点数据页。</p></li><li><p>对于 Buffer Pool 中数据的查询，InnoDB 直接读取返回；</p></li><li><p>对于 Buffer Pool 中数据的修改，InnoDB 直接在 Buffer Pool 中修改，并将修改写入 redo Log 中，当数据页被 LRU 算法淘汰时写入磁盘，若持久化前系统崩溃，则在重启后使用 redo Log 进行恢复。</p></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254407.jpeg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看innodb存储引擎状态，包含缓冲池、修改缓冲、自适应哈希状态信息、日志缓冲等信息...<br>mysql&gt; show engine innodb status;<br># 查看InnoDB的Buffer Pool大小<br>mysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254394.jpeg"></p><h4 id="2）修改缓冲-Change-Buffer"><a href="#2）修改缓冲-Change-Buffer" class="headerlink" title="2）修改缓冲(Change Buffer)"></a><strong>2）修改缓冲(Change Buffer)</strong></h4><p>Change Buffer（在 MySQL 5.6 之前叫 insert buffer，简称 ibuf ）是 InnoDB 5.5 引入的一种优化策略。<strong>Change Buffer 用于加速非热点数据中二级索引的写入操作。</strong>由于二级索引数据的不连续性，导致修改二级索引时需要进行频繁的磁盘 IO 消耗大量性能，Change Buffer 缓冲对二级索引的修改操作，同时将写操作录入 redo log 中，在缓冲到一定量或系统较空闲时进行<code>merge</code>操作将修改写入磁盘中。 Change Buffer 在系统表空间中有相应的持久化区域。</p><p>Change Buffer 大小默认占 Buffer Pool 的 25%，最大50%，在引擎启动时便初始化完成。<strong>其物理结构为一棵名为</strong><code>ibuf</code><strong>的 B Tree。</strong></p><blockquote><p><strong>二级索引</strong>就是辅助索引，除了聚簇索引之外的所有索引都是二级索引。</p><p><strong>聚簇索引</strong>也叫聚集索引，索引组织表，指的<strong>是一种数据存储方式，指数据与索引的数据结构存储在一起</strong>。如 InnoDB 的主键索引中所有叶子节点都存储了对应行的数据。因为数据肯定只是存储在一个地方，所以一个表只能有一个聚集索引。</p></blockquote><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254060.jpeg"></p><ul><li><p>周期性合并二级索引页</p></li><li><p>周期性净化磁盘中二级索引页</p></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254523.jpeg"></p><h4 id="3）自适应哈希索引-AHI"><a href="#3）自适应哈希索引-AHI" class="headerlink" title="3）自适应哈希索引(AHI)"></a><strong>3）自适应哈希索引(AHI)</strong></h4><p><strong>自适应哈希索引</strong>（Adaptive Hash Index，<strong>AHI</strong>）<strong>用于实现对于热数据页的一次查询。</strong>是建立在索引之上的索引！使用聚簇索引进行数据页定位的时候需要根据索引树的高度从根节点走到叶子节点，通常需要 3 到 4 次查询才能定位到数据。InnoDB 根据对索引使用情况的分析和索引字段的分析，通过自调优Self-tuning的方式为索引页建立或者删除哈希索引。</p><p>AHI 的大小为 Buffer Pool 的 1&#x2F;64，在 MySql 5.7 之后支持分区，以减少对于全局 AHI 锁的竞争，默认分区数为 8。</p><p>AHI 所作用的目标是频繁查询的数据页和索引页，而由于数据页是聚簇索引的一部分，因此 AHI 是建立在索引之上的索引，<strong>对于二级索引，若命中 AHI，则将直接从 AHI 获取二级索引页的记录指针，再根据主键沿着聚簇索引查找数据；若聚簇索引查询同样命中 AHI，则直接返回目标数据页的记录指针，此时就可以根据记录指针直接定位数据页</strong>。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254594.jpeg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看innodb存储引擎状态，包含自适应哈希状态信息<br>mysql&gt; show engine innodb status;<br># 查看是否开启自适应哈希配置，默认是开启的<br>mysql&gt; show variables like &#x27;innodb_adaptive_hash_index&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254248.png"></p><h4 id="4）日志缓冲-Log-Buffer"><a href="#4）日志缓冲-Log-Buffer" class="headerlink" title="4）日志缓冲(Log Buffer)"></a><strong>4）日志缓冲(Log Buffer)</strong></h4><p><strong>InnoDB 使用 Log Buffer 来缓冲日志文件的写入操作。</strong>内存写入加上日志文件顺序写的特点，使得 InnoDB 日志写入性能极高。</p><p>对于任何修改操作，都将录入诸如 redo log 与 undo log 这样的日志文件中，因此日志文件的写入操作非常频繁，却又十分零散。这些文件都存储在磁盘中，因此日志记录将引发大量的磁盘 IO。Log Buffer 将分散的写入操作放在内存中，通过定期批量写入磁盘的方式提高日志写入效率和减少磁盘 IO。</p><p> 注意：这种将分散操作 改为 批量操作的优化方式将增加数据丢失的风险！</p><h3 id="3-4-磁盘文件之表空间"><a href="#3-4-磁盘文件之表空间" class="headerlink" title="3.4 磁盘文件之表空间"></a><strong>3.4 磁盘文件之表空间</strong></h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254519.png"></p><p><strong>在磁盘中，InnoDB 将所有数据都逻辑地存放在一个空间中，称为表空间（Tablespace）。表空间由段（Segment）、区（extent）、页（Page）组成。</strong></p><ul><li>开启独立表空间innodb_file_per_table&#x3D;1，每张表的数据都会存储到一个<strong>独立表空间</strong>，即 表名.ibd 文件</li><li>关闭独占表空间innodb_file_per_table&#x3D;0，则所有基于InnoDB存储引擎的表数据都会记录到<strong>系统表空间</strong>，即 ibdata1 文件</li></ul><p>表空间是 InnoDB 物理存储中的最高层，目前的表空间类别包括：</p><ul><li><p>系统表空间（System Tablespace）</p></li><li><p>独立表空间（File-per-table Tablespace）</p></li><li><p>通用表空间（General Tablespace）</p></li><li><p>回滚表空间（Undo Tablespace）</p></li><li><p>临时表空间（The Temporary Tablespace）</p></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254003.png"></p><h4 id="1）系统表空间"><a href="#1）系统表空间" class="headerlink" title="1）系统表空间"></a><strong>1）系统表空间</strong></h4><p><strong>系统表空间是 InnoDB 数据字典、双写缓冲、修改缓冲和回滚日志的存储位置</strong>，如果关闭独立表空间，它也将存储所有表数据和索引。</p><p>它默认下是一个初始大小 12MB、名为 ibdata1 的文件，系统表空间所对应的文件由<code>innodb_data_file_path</code>定义。</p><p><strong>指定系统表空间文件自动增长后，其增长大小由</strong><code>innodb_autoextend_increment</code><strong>设置（默认为64MB）且不可缩减，即使删除系统表空间中存储的表和索引，此过程释放的空间仅仅是在表空间文件中标记为已释放而已，并不会缩减其在磁盘中的大小</strong>。</p><ul><li><strong>数据字典（Data Dictionary）</strong>： 数据字典是由<strong>各种表对象的元数据信息</strong>（表结构，索引，列信息等）组成的内部表</li><li><strong>双写缓冲（Doublewrite Buffer）</strong>：双写缓冲用于保证写入磁盘时页数据的完整性，防止发生<strong>部分写失效问题</strong>。非常重要，在3.6小节重点介绍</li><li><strong>修改缓冲（Change Buffer）</strong>： 内存中 Change Buffer 对应的持久化区域</li><li><strong>回滚日志（Undo Log）</strong>：实现事务进行 <strong>回滚</strong> 操作时对数据的恢复。是实现<strong>多版本并发控制（MVCC）</strong>重要组成。在事务篇详细讲解</li></ul><h4 id="2）独立表空间"><a href="#2）独立表空间" class="headerlink" title="2）独立表空间"></a><strong>2）独立表空间</strong></h4><p><strong>独立表空间用于存放每个表的数据、索引和插入缓冲 Bitmap 页。</strong>其他类型的信息，如：回滚信息、插入缓冲索引页、系统事务信息、二次写缓冲等仍存放于系统表空间内。因此即使用了独立表空间，系统表空间也会不断增长。</p><p>开启独立表空间（File-per-table TableSpace）（ innodb_file_per_table&#x3D;ON ）之后，InnoDB 会为每个数据库单独创建子文件夹，数据库文件夹内为每个数据表单独建立一个表空间文件 table.ibd 。同时创建一个 table.frm 文件用于保存表结构信息。</p><p>每个独立表空间的初始大小是 96KB。</p><h4 id="3）其他"><a href="#3）其他" class="headerlink" title="3）其他"></a><strong>3）其他</strong></h4><h5 id="1-通用表空间"><a href="#1-通用表空间" class="headerlink" title="1. 通用表空间"></a>1. <strong>通用表空间</strong></h5><p>通用表空间（General Tablespace）是一个由 CREATE TABLESPACE 命令创建的共享表空间，创建时必须指定该表空间名称和 ibd 文件位置，ibd 文件可以放置于任何 MySQL 有权限的地方。该表空间内可以容纳多张数据表，同时在创建时可以指定该表空间所使用的默认引擎。</p><p><strong>通用表空间存在的目的是为了在系统表空间与独立表空间之间作出平衡</strong>。系统表空间与独立表空间中的表可以向通用表空间移动，反之亦可，但系统表空间中的表无法直接与独立表空间中的表相互转化。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254528.png"></p><h5 id="2-Undo-表空间"><a href="#2-Undo-表空间" class="headerlink" title="2. Undo 表空间"></a><strong>2. Undo 表空间</strong></h5><p>Undo TableSpace 用于存放一个或多个 undo log 文件。<strong>默认</strong> <strong>undo log</strong> <strong>存储与系统表空间中，MySql5.6 以后支持自定义 Undo log 表空间并存储所有 undo log</strong>。一旦用户定义了 Undo Tablespace，则系统表空间中的 Undo log 区域将失效。对于 Undo Tablespace 的启用必须在 MySQL 初始化前设置， Undo Tablespace 默认大小为 10MB。Undo Tablespace 中的 Undo log 表可以进行 truncate 操作。</p><h5 id="3-临时表空间"><a href="#3-临时表空间" class="headerlink" title="3. 临时表空间"></a><strong>3. 临时表空间</strong></h5><p>MySQL 5.7 之前临时表存储在系统表空间中，这样会导致 ibdata 在使用临时表的场景下疯狂增长。<strong>5.7版本之后 InnoDB 引擎从系统表空间中抽离出临时表空间（Temporary Tablespace），用于独立保存临时表数据及其回滚信息</strong>。该表空间文件路径由<code>innodb_temp_data_file_path</code> 指定，但必须继承<code>innodb_data_home_dir</code>。</p><h3 id="3-5-磁盘文件之存储结构"><a href="#3-5-磁盘文件之存储结构" class="headerlink" title="3.5 磁盘文件之存储结构"></a><strong>3.5 磁盘文件之存储结构</strong></h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240254539.png"></p><h4 id="1）段【Segment】"><a href="#1）段【Segment】" class="headerlink" title="1）段【Segment】"></a><strong>1）段【Segment】</strong></h4><p><strong>表空间由各个段（Segment）组成，创建的段类型分为数据段、索引段、回滚段等</strong>。由于 InnoDB 采用聚簇索引与 B+ 树的结构存储数据，所以事实上数据页和二级索引页仅仅只是 B+ 树的叶子节点，因此数据段称为 Leaf node segment，<strong>索引段其实指的是</strong> <strong>B+</strong> <strong>树的非叶子节点，称为</strong> <strong>Non-Leaf node segment</strong>。一个段会包含多个区，至少会有一个区，段扩展的最小单位是区。【在索引篇会详细讲解B+数据结构】</p><ul><li><p><strong>数据段</strong>称为 Leaf node segment</p></li><li><p><strong>索引段</strong>称为 Non-Leaf node segment</p></li></ul><h4 id="2）区【Extent】"><a href="#2）区【Extent】" class="headerlink" title="2）区【Extent】"></a><strong>2）区【Extent】</strong></h4><p> <strong>区（Extend）是由连续的页组成的空间，大小固定为 1MB</strong>，由于默认页大小为 16K，因此一个区默认存储 64 个连续的页。如果页大小调整为 4K，则 256 个连续页组成一个区。<strong>为了保证页的连续性，</strong> <strong>InnoDB 存储引擎会一次从磁盘申请 4 ~ 5 个区</strong>。</p><h4 id="3）页【Page】"><a href="#3）页【Page】" class="headerlink" title="3）页【Page】"></a><strong>3）页【Page】</strong></h4><p><strong>页（Page）是 InnoDB 的基本存储单位</strong>，每个页大小默认为 16K，从 InnoDB1.2.x 版本开始，可通过设置 innodb_page_size 修改为 4K、8K、16K。InnoDB 首次加载后便无法更改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看MySQL页大小<br>show variables like &#x27;innodb_page_size&#x27;;<br></code></pre></td></tr></table></figure><p>MySQL规定一个页上最少存储2个数据项。如果向一个页插入数据时，这个页已将满了，就会从区中分配一个新页。如果向索引树叶子节点中间的一个页中插入数据，如果这个页是满的，就会发生页分裂。</p><p>操作系统管理磁盘的最小单位也是页，是操作系统读写磁盘最小单位，Linux中页一般是4K，可以通过命令查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">默认 4096 4K</span><br>getconf PAGE_SIZE<br></code></pre></td></tr></table></figure><p>所以InnoDB从磁盘中读取一个数据页时，操作系统会分4次从磁盘文件中读取数据到内存。写入也是一样的，需要分4次从内存写入到磁盘中。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240255376.png"></p><h4 id="4）行【Row】"><a href="#4）行【Row】" class="headerlink" title="4）行【Row】"></a><strong>4）行【Row】</strong></h4><p>InnoDB的数据是以行为单位存储的，1个页中包含多个行。在MySQL5.7中，InnoDB提供了4种行格式：Compact、Redundant、Dynamic和Compressed行格式，Dynamic为MySQL5.7默认的行格式。</p><p>创建表时可以指定行格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t1 (c1 INT) ROW_FORMAT=DYNAMIC;<br>#修改表的行格式<br>ALTER TABLE tablename ROW_FORMAT=行格式名称;<br>#修改默认行格式<br>SET GLOBAL innodb_default_row_format=DYNAMIC;<br>#查看表行格式<br>SHOW TABLE STATUS LIKE &#x27;t1&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>InnoDB行格式官网：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html"><span class="underline">https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html</span></a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MySQL</category>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死锁</title>
    <link href="/2021/10/26/%E6%AD%BB%E9%94%81/"/>
    <url>/2021/10/26/%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：</p><ul><li>吃饭</li><li>思考</li></ul><p>吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗米饭，每两个哲学家之间有一只筷子。因为用一只筷子很难吃到米饭，所以假设哲学家必须用两只筷子吃东西。他们只能使用自己左右手边的那两只筷子。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20241124014613268.png" alt="image-20241124014613268"></p><h4 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h4><p>来模拟一下就餐的情况</p><blockquote><p>筷子分别用1-5编号代替，五名哲学家的名字分别从A-E</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 根据图片的情况</span><br><span class="hljs-comment">         * A左右筷子分别是5和1</span><br><span class="hljs-comment">         * B左右筷子分别是1和2</span><br><span class="hljs-comment">         * ...</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;A&quot;</span>, c5, c1).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;B&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;C&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;D&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;E&quot;</span>, c4, c5).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 哲学家</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Chopstick left;<br>    Chopstick right;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 尝试拿左手边的筷子</span><br>            <span class="hljs-keyword">synchronized</span> (left) &#123;<br>                <span class="hljs-comment">// 尝试拿右手边的筷子</span><br>                <span class="hljs-keyword">synchronized</span> (right) &#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; eat!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 筷子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> &#123;<br>    <span class="hljs-comment">// 每只筷子的编号</span><br>    Integer id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最开始程序还能进行，执行到最后发现，程序不动了。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221021142734189.png" alt="image-20221021142734189"></p><p>如果5个哲学家同时拿起左边的筷子，并且等待右边的筷子的同时，又不放下左边的筷子。就会导致五个哲学家都吃不到米饭。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="一、线程粗化"><a href="#一、线程粗化" class="headerlink" title="一、线程粗化"></a>一、线程粗化</h5><blockquote><p>把5把锁合并成一把锁，只有抢到这一把锁，才可以执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 定义了一个大锁</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">mutex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;大锁&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 根据图片的情况</span><br><span class="hljs-comment">         * A左右筷子分别是5和1</span><br><span class="hljs-comment">         * B左右筷子分别是1和2</span><br><span class="hljs-comment">         * ...</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;A&quot;</span>, c5, c1, mutex).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;B&quot;</span>, c1, c2, mutex).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;C&quot;</span>, c2, c3, mutex).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;D&quot;</span>, c3, c4, mutex).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;E&quot;</span>, c4, c5, mutex).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 哲学家</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Chopstick left;<br>    Chopstick right;<br>    String name;<br>    String mutex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right, String mutex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>        <span class="hljs-built_in">this</span>.mutex = mutex;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 拿到大锁，才可以吃饭</span><br>            <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>                eat();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; eat!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 筷子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> &#123;<br>    <span class="hljs-comment">// 每只筷子的编号</span><br>    Integer id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>缺点：效率太低，明明大家拿到2个筷子就可以吃饭，却同一时刻只能一个人用餐。</li></ul><h5 id="二、最少保证"><a href="#二、最少保证" class="headerlink" title="二、最少保证"></a>二、最少保证</h5><blockquote><p>代码里，每个哲学家都是先拿左筷子，再拿右筷子。我们让其中一个人，先拿右筷子，再拿左筷子。再次结合下面这张图，假设E是右撇子，A,B,C,D分别同时拿起了左手边的筷子5,1,2,3</p></blockquote><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20241124014755524.png" alt="image-20241124014755524"></p><blockquote><p>而E是右撇子，他要先拿5，但5被占用了，所以他不得不放弃争抢这次资源，而D顺利成章地拿到了4，这样D拥有了3和4，然后吃完释放，C又拿起了2和3，再释放…</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里就不贴所有的代码了，我们把样例中的E哲学家变成右撇子。让他先拿5再拿4</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;A&quot;</span>, c5, c1).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;B&quot;</span>, c1, c2).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;C&quot;</span>, c2, c3).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;D&quot;</span>, c3, c4).start();<br><span class="hljs-comment">// new Philosopher(&quot;E&quot;, c4, c5).start();</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;E&quot;</span>, c5, c4).start();<br></code></pre></td></tr></table></figure><ul><li>缺点：这个效率同样不高，因为D要吃完C才能吃，C要吃完B才能吃，这样就形成了一条链，如果这条链上有500，5000人呢？</li></ul><h5 id="三、奇偶互反"><a href="#三、奇偶互反" class="headerlink" title="三、奇偶互反"></a>三、奇偶互反</h5><blockquote><p>让奇数位置的哲学家先拿左筷子，偶数位置的哲学家先拿右筷子。</p><p>如果A,C,E为奇数；B,D为偶数。</p><p>如果A拿到了5，B只能拿2，AB之间的1，就被空了出来，保证A能拿到；</p><p>同理B如果拿到了2，A只能拿5，AB之间的1，也被空了出来，B也能拿到。</p><p>当他们用餐完毕，释放完以后，可以继续按这个规则，进餐。不会发生死锁。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 根据图片的情况</span><br><span class="hljs-comment">         * A左右筷子分别是5和1</span><br><span class="hljs-comment">         * B左右筷子分别是1和2</span><br><span class="hljs-comment">         * ...</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;A&quot;</span>, c5, c1).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;B&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;C&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;D&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;E&quot;</span>, c4, c5).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 哲学家</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Chopstick left;<br>    Chopstick right;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 模拟 A C E是奇数，实际做的时候 可以用编号对2求余。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;A&quot;</span>.equals(<span class="hljs-built_in">this</span>.name) || <span class="hljs-string">&quot;C&quot;</span>.equals(<span class="hljs-built_in">this</span>.name) || <span class="hljs-string">&quot;E&quot;</span>.equals(<span class="hljs-built_in">this</span>.name)) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 尝试拿左手边的筷子</span><br>                <span class="hljs-keyword">synchronized</span> (left) &#123;<br>                    <span class="hljs-comment">// 尝试拿右手边的筷子</span><br>                    <span class="hljs-keyword">synchronized</span> (right) &#123;<br>                        eat();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 尝试拿右手边的筷子</span><br>                <span class="hljs-keyword">synchronized</span> (right) &#123;<br>                    <span class="hljs-comment">// 尝试拿左手边的筷子</span><br>                    <span class="hljs-keyword">synchronized</span> (left) &#123;<br>                        eat();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; eat!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 筷子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> &#123;<br>    <span class="hljs-comment">// 每只筷子的编号</span><br>    Integer id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个是效率最高的方法</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式RPC框架Apache Dubbo+Zookeeper基本教程</title>
    <link href="/2021/02/12/%E5%88%86%E5%B8%83%E5%BC%8FRPC%E6%A1%86%E6%9E%B6Apache%20Dubbo+Zookeeper%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/12/%E5%88%86%E5%B8%83%E5%BC%8FRPC%E6%A1%86%E6%9E%B6Apache%20Dubbo+Zookeeper%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式RPC框架Apache-Dubbo-Zookeeper基本教程"><a href="#分布式RPC框架Apache-Dubbo-Zookeeper基本教程" class="headerlink" title="分布式RPC框架Apache Dubbo+Zookeeper基本教程"></a>分布式RPC框架Apache Dubbo+Zookeeper基本教程</h1><p>教程来自：<a href="https://www.bilibili.com/video/BV1yD4y1Q77F">黑马_ZooKeeper+Dubbo分布式架构基础教程</a></p><h2 id="一、软件架构的演进过程"><a href="#一、软件架构的演进过程" class="headerlink" title="一、软件架构的演进过程"></a>一、软件架构的演进过程</h2><p>软件架构的发展经历了由单体架构、垂直架构、SOA架构到微服务架构的演进过程。</p><h3 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1 单体架构"></a>1.1 单体架构</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230401005033509.png" alt="单体架构"></p><p>架构说明：</p><p>​全部功能集中在一个项目内（All in one）</p><p>架构优点：</p><p>​架构简单，前期开发成本低、开发周期短，适合小型项目。</p><p>架构缺点：</p><p>​全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护。</p><p>​技术栈受限，只能使用一种语言开发。</p><p>​系统性能扩展只能通过扩展集群节点，成本高。</p><h3 id="1-2-垂直架构"><a href="#1-2-垂直架构" class="headerlink" title="1.2 垂直架构"></a>1.2 垂直架构</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230401005300010.png" alt="垂直架构"></p><p>架构说明：</p><p>​按照业务进行切割，形成小的单体项目。</p><p>架构优点：</p><p>​技术栈可扩展（不同的系统可以用不同的编程语言编写）</p><p>架构缺点：</p><p>​功能集中在一个项目中，不利于开发、扩展、维护。</p><p>​系统扩张只能通过集群的方式。</p><p>​项目之间功能冗余、数据冗余、耦合性强。</p><h3 id="1-3-SOA架构"><a href="#1-3-SOA架构" class="headerlink" title="1.3 SOA架构"></a>1.3 SOA架构</h3><p>SOA全称为Service-Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对松散耦合的细粒度应用组件（服务）进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。</p><p>站在功能的角度，把业务逻辑抽象成可服用的服务，通过服务的编排实现业务的快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230401010121116.png" alt="SOA架构"></p><p>架构说明：</p><p>​将重复功能或模块抽取成组件的形式，对外提供服务，在项目与服务之间使用ESB（企业服务总线）的形式作为通信的桥梁。</p><p>架构优点：</p><p>​重复功能或模块抽取为服务，提高开发效率。</p><p>​可重用性高。</p><p>​可维护性高。</p><p>架构缺点：</p><p>​各系统之间业务不同，很难确认功能或模块是重复的。</p><p>​抽取服务的粒度大。</p><p>​系统和服务之间耦合度高。</p><h3 id="1-4-微服务架构"><a href="#1-4-微服务架构" class="headerlink" title="1.4 微服务架构"></a>1.4 微服务架构</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230401011539873.png" alt="微服务架构"></p><p>架构说明：</p><p>​将系统服务层完全独立出来，抽取为一个一个的微服务。</p><p>​抽取的粒度更细，遵循单一原则。</p><p>​采用轻量级框架协议传输。</p><p>架构优点：</p><p>​服务拆分粒度更细，有利于提高开发效率。</p><p>​可以针对不同服务制定对应的优化方案。</p><p>​适用于互联网时代，产品迭代周期更短。</p><p>架构缺点：</p><p>​粒度太细导致服务太多，维护成本高。</p><p>​分布式系统开发的技术成本高，对团队的挑战大。</p><h2 id="二、Apache-Dubbo概述"><a href="#二、Apache-Dubbo概述" class="headerlink" title="二、Apache Dubbo概述"></a>二、Apache Dubbo概述</h2><h3 id="2-1-Dubbo简介"><a href="#2-1-Dubbo简介" class="headerlink" title="2.1 Dubbo简介"></a>2.1 Dubbo简介</h3><p>Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。</p><p><strong>什么是RPC？</strong></p><p>RPC全称为remote procedure call，即<strong>远程过程调用</strong>。比如两台服务器A和B，A服务上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。</p><p>需要注意的是RPC并不是一个具体的技术，而是整个网络远程调用过程。</p><p>RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC犯愁。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。</p><p>Dubbo官网地址：<a href="http://dubbo.apache.org/">http://dubbo.apache.org</a></p><p>Dubbo提供了三大核心能力：<strong>面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</strong></p><h3 id="2-2-Dubbo架构"><a href="#2-2-Dubbo架构" class="headerlink" title="2.2 Dubbo架构"></a>2.2 Dubbo架构</h3><p>Dubbo架构图（Dubbo官方提供）：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230401012912139.png" alt="dubbo架构图"></p><p><strong>调用关系说明：</strong></p><p><strong>0-start</strong>：Provider（服务的提供方）通常运行在Container中，Container是一个容器，通常指Spring容器。</p><p><strong>1-register</strong>：Provider把自己的地址，以及提供什么样的服务，注册到注册中心Registry。</p><p><strong>2-subscribe</strong>：Consumer（服务的消费方）想调用服务的提供方，就要到注册中心Registry去订阅服务。</p><p><strong>3-notify</strong>：当Provider有更新的时候，注册中心就会通过notify（通知）Comsumer有更新。</p><p><strong>4-invoke</strong>：Consumer拿到Provider的地址，就可以通过网络，去调用到真正的服务。</p><p><strong>5-count</strong>：监控中心Monitor就会监控到Comsumer在什么时间调用了什么服务、调用了多少次等等。</p><p>最重要的三个角色：Prorvider、Consumer、Registry。</p><p><strong>节点角色说明：</strong></p><table><thead><tr><th>节点</th><th>角色名称</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><p>虚线都是异步访问、实现都是同步访问。</p><p>蓝色虚线：在启动的时候就完成。</p><p>红色虚线（实线）：程序运行过程当中执行的功能。</p><h2 id="三、服务注册中心Zookeeper"><a href="#三、服务注册中心Zookeeper" class="headerlink" title="三、服务注册中心Zookeeper"></a>三、服务注册中心Zookeeper</h2><p>通过前面的Dubbo架构图可以看到，Registry（服务注册中心）在其中起着至关重要的作用。Dubbo官方推荐使用Zookeeper作为服务注册中心。</p><h3 id="3-1-Zookeeper介绍"><a href="#3-1-Zookeeper介绍" class="headerlink" title="3.1 Zookeeper介绍"></a>3.1 Zookeeper介绍</h3><p>Zookeeper是Apache Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</p><p>为了便于理解Zookeeper的树型目录服务，我们先来看一下我们电脑的文件系统（也是一个树型目录结构）：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230403230840518.png"></p><p>我们的电脑可以分为多个盘符（例如C、D、E等），每个盘符下可以创建多个目录，每个目录下面可以创建问价你，也可以创建子目录，最终构成了一个树型结构。通过这种树型结构的目录，我们可以将文件分门别类的进行存放，方便我们后期查找。而且磁盘上的每个文件都有一个唯一的访问路径。</p><p>Zookeeper树型目录服务：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240313013.png" alt="Zookeeper树型目录服务"></p><p>流程说明：</p><ul><li>服务提供者(Provicer)启动时，向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li>服务消费者(Consumer)启动时，订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li>监控中心(Monitor)启动时，订阅<code> /dubbo/com.foo.BarService</code> 目录下所有的提供者和消费者 URL 地址</li></ul><h3 id="3-2-安装Zookeeper"><a href="#3-2-安装Zookeeper" class="headerlink" title="3.2 安装Zookeeper"></a>3.2 安装Zookeeper</h3><p>下载地址：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><p>安装步骤：</p><ol><li><p>安装JDK</p></li><li><p>把zookeeper的压缩包（apache-zookeeper-3.8.1-bin.tar.gz）上传到linux系统</p></li><li><p>解压缩压缩包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zxvf apache-zookeeper-3.8.1-bin.tar.gz -C /usr/local<br></code></pre></td></tr></table></figure></li><li><p>进入<code>/usr/local/apache-zookeeper-3.8.1-bin</code>目录，创建data目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> data<br></code></pre></td></tr></table></figure></li><li><p>进入<code>conf</code>目录，把<code>zoo_sample.cfg</code>改名为<code>zoo.cfg</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> conf<br><span class="hljs-built_in">cp</span> zoo_sample.cfg zoo.cfg<br></code></pre></td></tr></table></figure></li><li><p>打开<code>zoo.cfg</code>文件，修改data属性：<code>dataDir=/usr/local/apache-zookeeper-3.8.1-bin/data</code></p></li></ol><h3 id="3-3-启动、停止Zookeeper"><a href="#3-3-启动、停止Zookeeper" class="headerlink" title="3.3 启动、停止Zookeeper"></a>3.3 启动、停止Zookeeper</h3><p>进入Zookeeper的bin目录，</p><p><strong>启动服务命令</strong>：.&#x2F;zkServer.sh start</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230403231924113.png" alt="启动服务"></p><p><strong>停止服务命令</strong>：.&#x2F;zkServer.sh stop</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230403231939347.png" alt="停止服务"></p><p><strong>查看服务状态</strong>：.&#x2F;zkServer.sh status</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230403231958858.png" alt="查看服务状态"></p><h2 id="四、Dubbo快速入门"><a href="#四、Dubbo快速入门" class="headerlink" title="四、Dubbo快速入门"></a>四、Dubbo快速入门</h2><p>Dubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。本小节就是要创建两个应用，一个作为服务的提供方，一个作为服务的消费方。通过Dubbo来实现服务消费放远程调用服务提供方的方法。</p><h3 id="4-1-服务提供方的开发"><a href="#4-1-服务提供方的开发" class="headerlink" title="4.1 服务提供方的开发"></a>4.1 服务提供方的开发</h3><p>开发步骤：</p><h4 id="（1）创建maven工程（打包方式为war）"><a href="#（1）创建maven工程（打包方式为war）" class="headerlink" title="（1）创建maven工程（打包方式为war）"></a>（1）创建maven工程（打包方式为war）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.xiaof<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-provider<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dubbo-provider Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jms<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- dubbo相关 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.sgroschupf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.12.1.GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>dubbo-provider<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 指定端口 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8081<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 请求路径 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）配置web-xml文件"><a href="#（2）配置web-xml文件" class="headerlink" title="（2）配置web.xml文件"></a>（2）配置web.xml文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">web-app</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta"> <span class="hljs-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><br><span class="hljs-meta"> <span class="hljs-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（3）spring配置文件"><a href="#（3）spring配置文件" class="headerlink" title="（3）spring配置文件"></a>（3）spring配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://code.alibabatech.com/schema/dubbo</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 每个dubbo应用（服务方提供方和消费方）都必须指定一个唯一的名称--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbodemo_provider&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定服务的注册中心 ip为zookeeper所在服务器的ip地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://192.168.31.97:2181&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注册  协议和port   端口默认是20880 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20881&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:protocol</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:annotation</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.itheima.service.impl&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（4）接口HelloService-java"><a href="#（4）接口HelloService-java" class="headerlink" title="（4）接口HelloService.java"></a>（4）接口HelloService.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HelloService</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）接口实现类（发布服务）：HelloServiceImpl-java"><a href="#（5）接口实现类（发布服务）：HelloServiceImpl-java" class="headerlink" title="（5）接口实现类（发布服务）：HelloServiceImpl.java"></a>（5）接口实现类（发布服务）：HelloServiceImpl.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.service.impl;<br><br><span class="hljs-keyword">import</span> com.alibaba.dubbo.config.annotation.Service;<br><span class="hljs-keyword">import</span> com.itheima.service.HelloService;<br><br><span class="hljs-meta">@Service</span> <span class="hljs-comment">// 发布服务必须时用Dubbo提供的Service注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-服务消费方的开发"><a href="#4-2-服务消费方的开发" class="headerlink" title="4.2 服务消费方的开发"></a>4.2 服务消费方的开发</h3><p>开发步骤：</p><h4 id="（1）创建maven工程（打包方式为war）-1"><a href="#（1）创建maven工程（打包方式为war）-1" class="headerlink" title="（1）创建maven工程（打包方式为war）"></a>（1）创建maven工程（打包方式为war）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.xiaof<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-provider<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dubbo-provider Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jms<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- dubbo相关 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.sgroschupf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.12.1.GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>dubbo-provider<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 指定端口 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8084<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 请求路径 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）配置web-xml文件-1"><a href="#（2）配置web-xml文件-1" class="headerlink" title="（2）配置web.xml文件"></a>（2）配置web.xml文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">web-app</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta"> <span class="hljs-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><br><span class="hljs-meta"> <span class="hljs-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext-web.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（3）spring配置文件-1"><a href="#（3）spring配置文件-1" class="headerlink" title="（3）spring配置文件"></a>（3）spring配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://code.alibabatech.com/schema/dubbo</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 每个dubbo应用（服务方提供方和消费方）都必须指定一个唯一的名称--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbodemo_consumer&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定服务的注册中心 ip为zookeeper所在服务器的ip地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://192.168.31.97:2181&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:annotation</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.itheima.controller&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（4）把提供方端的HelloService接口复制到消费者中"><a href="#（4）把提供方端的HelloService接口复制到消费者中" class="headerlink" title="（4）把提供方端的HelloService接口复制到消费者中"></a>（4）把提供方端的HelloService接口复制到消费者中</h4><h4 id="（5）消费方Controller"><a href="#（5）消费方Controller" class="headerlink" title="（5）消费方Controller"></a>（5）消费方Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.controller;<br><br><span class="hljs-keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;<br><span class="hljs-keyword">import</span> com.itheima.service.HelloService;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/dubbo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Reference</span>来源：com.alibaba.dubbo.config.annotation.Reference</span><br><span class="hljs-comment">     * 作用：从zookeeper注册中心获取服务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Reference</span><br>    <span class="hljs-keyword">private</span> HelloService helloService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">//远程调用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> helloService.sayHello(name);<br>        System.out.println(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（6）运行测试"><a href="#（6）运行测试" class="headerlink" title="（6）运行测试"></a>（6）运行测试</h4><p>tomcat7:run 分别启动提供方和消费方</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230404000325481.png" alt="启动tomcat"></p><p>输入 <a href="http://localhost:8084/dubbo/hello?name=hahah">http://localhost:8084/dubbo/hello?name=hahah</a></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230404000853566.png" alt="调用方法"></p><p><strong>思考一：</strong>上面的Dubbo入门案例中我们是将HelloService接口从服务提供者工程(dubbo_provider)复制到服务消费者工程(dubbo_consumer)中，接口是相同的，这种做法是否合适？还有没有更好的方式？</p><blockquote><p> <strong>答：</strong> 这种做法显然是不好的，同一个接口被复制了两份，不利于后期维护。更好的方式是单独创建一个maven工程，将此接口创建在这个maven工程中。需要依赖此接口的工程只需要在自己工程的pom.xml文件中引入maven坐标即可。</p></blockquote><p><strong>思考二：</strong>在服务消费者工程(dubbodemo_consumer)中只是引用了HelloService接口，并没有提供实现类，Dubbo是如何做到远程调用的？</p><blockquote><p><strong>答：</strong> Dubbo底层是基于代理技术为HelloService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。</p></blockquote><p><strong>思考三：</strong>上面的Dubbo入门案例中我们使用Zookeeper作为服务注册中心，服务提供者需要将自己的服务信息注册到Zookeeper，服务消费者需要从Zookeeper订阅自己所需要的服务，此时Zookeeper服务就变得非常重要了，那如何防止Zookeeper出现单点故障呢？</p><blockquote><p><strong>答：</strong> Zookeeper支持集群模式，可以配置Zookeeper集群来达到Zookeeper服务的高可用，防止出现单点故障。</p></blockquote><h2 id="五、Dubbo管理控制台"><a href="#五、Dubbo管理控制台" class="headerlink" title="五、Dubbo管理控制台"></a>五、Dubbo管理控制台</h2><h3 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1 安装"></a>5.1 安装</h3><p>（1）因为官方的dubbo-admin不支持JDK1.8，所以这一步我是在网络上找的资源，解压到tomcat中。</p><p>资源地址：<a href="https://github.com/Howinfun/dubbo-admin-2.5.4-for-JDK1.8">https://github.com/Howinfun/dubbo-admin-2.5.4-for-JDK1.8</a></p><p>（2）修改WEB-INF中的dubbo.properties，将zookeeper的连接地址更换为服务器的IP和端口，用户名和密码也在配置文件里。</p><p>（3）启动tomcat，访问URL（Tomcat端口：8080）：<a href="http://localhost:8080/dubbo-admin-2.5.4-for-JDK1.8-master/">http://localhost:8080/dubbo-admin-2.5.4-for-JDK1.8-master/</a></p><blockquote><p>用户名：root</p><p>密码：root</p></blockquote><p>首页：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230404010939935.png" alt="dubbo-admin首页"></p><h3 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h3><p>服务治理页：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230404011919057.png" alt="dubbo-admin服务治理页"></p><h2 id="六、Dubbo相关配置说明"><a href="#六、Dubbo相关配置说明" class="headerlink" title="六、Dubbo相关配置说明"></a>六、Dubbo相关配置说明</h2><h3 id="6-1-包扫描"><a href="#6-1-包扫描" class="headerlink" title="6.1 包扫描"></a>6.1 包扫描</h3><p>服务提供者和服务消费者都需要配置包扫描，作用是扫描指定包(含子包)下的类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:annotation</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.itheima.service&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>如果不使用包扫描，也可以通过如下配置的方式来发布服务（一个类写一次，较麻烦）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.HelloServiceImpl&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.itheima.service.HelloService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;helloService&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>作为服务消费者，可以通过如下配置来引用服务：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.itheima.service.HelloService&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>上面这种方式发布和引用服务，一个配置项(dubbo:service、dubbo:reference)只能发布或者引用一个服务，如果有多个服务，这种方式就比较繁琐了。推荐使用包扫描方式。</p><h3 id="6-2-协议"><a href="#6-2-协议" class="headerlink" title="6.2 协议"></a>6.2 协议</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>一般在服务提供者一方配置，可以指定使用的协议名称和端口号。</p><p>其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。</p><p>推荐使用dubbo协议：</p><p>说明： dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p><p>也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 多协议配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rmi&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;1099&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.itheima.service.HelloService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;helloService&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;dubbo&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.itheima.service.DemoService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;rmi&quot;</span> /&gt;</span> <br></code></pre></td></tr></table></figure><h3 id="6-3-启动时检查"><a href="#6-3-启动时检查" class="headerlink" title="6.3 启动时检查"></a>6.3 启动时检查</h3><p>服务消费者一方，dubbo默认的check值为true，即Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。</p><p>可以通过以下配置将check值改为false来关闭检查：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:consumer</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>建议在开发阶段将check值设置为false，在生产环境下改为true。</p><h3 id="6-4-负载均衡"><a href="#6-4-负载均衡" class="headerlink" title="6.4 负载均衡"></a>6.4 负载均衡</h3><p>负载均衡（Load Balance）：其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。</p><p>在集群负载均衡时，Dubbo 提供了多种均衡策略（包括随机、轮询、最少活跃调用数、一致性Hash），缺省为random随机调用。</p><p>配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br><span class="hljs-comment">//在服务消费者一方配置负载均衡策略</span><br>    <span class="hljs-meta">@Reference(check = false,loadbalance = &quot;random&quot;)</span><br>    <span class="hljs-keyword">private</span> HelloService helloService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">//远程调用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> helloService.sayHello(name);<br>        System.out.println(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在服务提供者一方配置负载均衡</span><br><span class="hljs-meta">@Service(loadbalance = &quot;random&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过启动多个服务提供者来观察Dubbo负载均衡效果。</p><h2 id="七、解决Dubbo无法发布被事务代理的Service的问题"><a href="#七、解决Dubbo无法发布被事务代理的Service的问题" class="headerlink" title="七、解决Dubbo无法发布被事务代理的Service的问题"></a>七、解决Dubbo无法发布被事务代理的Service的问题</h2><p>如果在服务提供者类上加入@Transactional事务控制注解后，服务就发布不成功了。<br>原因是事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前,进行包匹配时无法完成匹配，进而没有进行服务的发布。</p><h3 id="7-1-问题展示"><a href="#7-1-问题展示" class="headerlink" title="7.1 问题展示"></a>7.1 问题展示</h3><p>在入门案例的服务提供者dubbodemo_provider工程基础上进行展示</p><p>操作步骤：</p><p>（1）在pom.xml文件中增加maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）在applicationContext-service.xml配置文件中加入数据源、事务管理器、开启事务注解的相关配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mytest&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 事务管理器  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--开启事务控制的注解支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>上面链接的数据库可以自行创建</p><p>（3）在HelloServiceImpl类上加入spring事务注解：@Transactional</p><p>（4）启动服务提供者和服务消费者，并访问</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230405010038458.png" alt="无提供者"></p><p>上面的错误为没有可用的服务提供者</p><p>查看dubbo管理控制台发现服务并没有发布，如下：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230405004420732.png"></p><p>可以通过断点调试的方式查看Dubbo执行过程，Dubbo通过<code>AnnotationBean</code>类的<code>postProcessAfterInitialization</code>方法进行处理。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230405010526226.png"></p><p>isMatchPackage必须匹配这个包，才能发布服务。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230405010616339.png"></p><p>实际helloService的代理类名称为</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230405011032814.png"></p><p>该方法最后返回了false</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230405011105396.png"></p><h3 id="7-2-解决方案"><a href="#7-2-解决方案" class="headerlink" title="7.2 解决方案"></a>7.2 解决方案</h3><p>解决方法操作步骤：</p><p>（1）修改<code>applicationContext-service.xml</code>配置文件，开启事务控制注解支持时指定<code>proxy-target-class</code>属性，值为<code>true</code>。其作用是使用cglib代理方式为Service类创建代理对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开启事务控制的注解支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>（2）修改HelloServiceImpl类，在该类上dubbo源的@Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(interfaceClass = HelloService.class,protocol = &quot;dubbo&quot;)</span> <span class="hljs-comment">// 发布服务必须时用Dubbo提供的Service注解</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此处也是要修改的，否则会导致发布的服务接口为SpringProxy（这是spring的cglib代理默认实现的接口），而不是HelloService接口。</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Dubbo</tag>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker基础</title>
    <link href="/2021/02/02/Docker/"/>
    <url>/2021/02/02/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote><p>弱小和无知不是生存的障碍，傲慢才是。</p></blockquote><h2 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h2><h3 id="1-1-Docker为什么出现？"><a href="#1-1-Docker为什么出现？" class="headerlink" title="1.1 Docker为什么出现？"></a>1.1 Docker为什么出现？</h3><p>一款产品： 开发–上线 两套环境！应用环境，应用配置！（运维）</p><p>环境配置是十分的麻烦，每一个机器都要部署环境(集群Redis、ES、Hadoop…) !费事费力。而且也不能跨平台</p><p>于是就想：发布一个项目( jar + (Redis MySQL JDK ES) )，项目能不能带上环境安装打包！</p><p>传统：开发jar，运维来做！</p><p>现在：Docker提出了解决方案！开发打包部署上线，一套流程做完！</p><p>安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！</p><p>docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）–下载我们发布的镜像—直接运行即可</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240258306.png" alt="在这里插入图片描述"></p><p>Docker的思想就来自于集装箱！</p><p>JRE – 多个应用(端口冲突) – 原来都是交叉的！</p><p>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p><p>Docker通过隔离机制，可以将服务器利用到极致</p><p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习</p><h3 id="1-2-Docker的历史"><a href="#1-2-Docker的历史" class="headerlink" title="1.2 Docker的历史"></a>1.2 Docker的历史</h3><p>2010年，几个搞IT的年轻人，在美国成立了一家公司<code>dotCloud</code></p><p>做一些paas的云计算服务，LXC有关的容器技术。</p><p>他们将自己的技术（容器化技术）命名为Docker。</p><p>Docker刚刚诞生的时候，没有引起行业的注意。dotCcloud，就活不下去。</p><p>2013年，Docker<strong>开源</strong>了！</p><p>Docker越来越多的人发现了Docker的优点！火了！Docker每个月都会更新一个版本。</p><p>2013年4月9日，Docker1.0发布。</p><p>Docker为什么这么火？十分的轻巧。</p><p>在容器技术出来之前，我们都是使用虚拟机技术。</p><p>虚拟机：在windows中装一个Vmware，通过这个软件我们可以虚拟出来一台或者多台电脑，十分笨重。</p><p>虚拟机也是属于虚拟化技术，Docker容器技术，也是一种虚拟化技术。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vm</span>：linux centos原生镜像（一个电脑！）隔离：需要开启多个虚拟机，几个G，几分钟启动。<br><span class="hljs-attribute">docker</span>：隔离，镜像（最核心的环境 <span class="hljs-number">4</span>m + jdk + mysql）十分的小巧，运行镜像就可以了，几个M，KB，秒级启动。<br></code></pre></td></tr></table></figure><blockquote><p>聊聊docker：</p></blockquote><p>Docker是基于Go语言开发的，开源项目。</p><ul><li>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230418000159864.png" alt="docker官网"></p><ul><li><p>文档地址：<a href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p></li><li><p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a> git命令在这里都可以使用</p></li></ul><h3 id="1-3-Docker能干嘛"><a href="#1-3-Docker能干嘛" class="headerlink" title="1.3 Docker能干嘛"></a>1.3 Docker能干嘛</h3><blockquote><p>之前的虚拟机技术</p></blockquote><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230418002123031.png" alt="之前的虚拟机技术"></p><p>虚拟机技术缺点：</p><ol><li>资源占用十分多</li><li>冗余步骤非常多</li><li>启动很慢</li></ol><blockquote><p>容器化技术</p></blockquote><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230418002340896.png" alt="容器化技术"></p><p>容器化技术不是模拟的一个完整的操作系统</p><p>比较Docker和虚拟机技术的不同：</p><ul><li>传统虚拟机，虚拟出一个硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。</li><li>容器内的应用直接运行在宿主机的内核中，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了。</li><li>每个容器间是互相隔离的，每个容器内都有一个属于自己的文件系统，互不影响。</li></ul><blockquote><p>DevOps（开发、运维）</p></blockquote><p><strong>1. 应用更快速的交付和部署</strong></p><p>传统：一堆帮助文档，安装程序。</p><p>Docker：打包镜像，发布测试，一键运行。</p><p><strong>2. 更便捷的升级和扩缩容</strong></p><p>使用了Docker之后，我们部署应用就和搭积木一样。</p><p>项目打包为一个镜像，扩展。</p><p><strong>3. 更简单的系统运维</strong></p><p>在容器化之后，我们的开发，测试环境都是高度一致的。</p><p><strong>4. 更高效的计算资源利用</strong></p><p>1核2G的服务器，可以同时运行几十个Tomcat。</p><p>Docker是内核级别的虚拟机化，可以在一个物理机上运行很多的容器实例。</p><p>服务器的性能可以被压榨到极致。</p><h2 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h2><h3 id="2-1-Docker的基本组成"><a href="#2-1-Docker的基本组成" class="headerlink" title="2.1 Docker的基本组成"></a>2.1 Docker的基本组成</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240259585.png" alt="Docker架构图"><br>**镜像（image)**：</p><p>docker镜像就好比一个模板，可以通过这个模板来创建容器服务，tomcat镜像&#x3D;&#x3D;&#x3D;&gt;run&#x3D;&#x3D;&#x3D;&gt;tomcat01容器（提供服务器），可通过镜像创建多个容器。</p><p><strong>容器（container）</strong>：</p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的。</p><p>启动、停止、删除、基本命令。</p><p>目前就可以把这个容器理解为一个简易的linux系统。</p><p><strong>仓库（repository）</strong>：</p><p>存放镜像的地方</p><p>仓库分为公有仓库和私有仓库</p><p>DockerHub（默认是国外的）、阿里云都有容器服务器（配置镜像加速）</p><hr><p><em>PS：镜像就像APP安装包，容器就像APP应用</em></p><h3 id="2-2-安装Docker"><a href="#2-2-安装Docker" class="headerlink" title="2.2 安装Docker"></a>2.2 安装Docker</h3><blockquote><p>环境准备：Linux环境</p><p>环境查看：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">系统内核是3.10以上的</span><br>[root@master ~]# uname -r<br>3.10.0-1160.el7.x86_64<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">系统版本</span><br>[root@master ~]# cat /etc/os-release<br>NAME=&quot;CentOS Linux&quot;<br>VERSION=&quot;7 (Core)&quot;<br>ID=&quot;centos&quot;<br>ID_LIKE=&quot;rhel fedora&quot;<br>VERSION_ID=&quot;7&quot;<br>PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;<br>ANSI_COLOR=&quot;0;31&quot;<br>CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;<br>HOME_URL=&quot;https://www.centos.org/&quot;<br>BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;<br><br>CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;<br>CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;<br>REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;<br>REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;<br></code></pre></td></tr></table></figure><blockquote><p>安装</p></blockquote><p>帮助文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.卸载旧版本</span><br>yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br>                  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.需要的安装包</span><br>yum install -y yum-utils<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.设置镜像的仓库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认是国外的，不推荐</span><br>yum-config-manager \ <br>--add-repo \ <br>https://download.docker.com/linux/centos/docker-ce.repo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">推荐使用国内的（这里手敲代码然后复制网站）</span><br>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.更新yum软件包索引</span> <br>yum makecache fast<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.安装docker相关的内容 docker-ce 社区版 ee 是企业版</span><br>yum install docker-ce docker-ce-cli containerd.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">6、启动docker</span><br>systemctl start docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">7、使用 docker version 查看是否安装成功</span><br>docker version<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230418010541255.png" alt="docker version"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">测试</span><br>docker run hello-world<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230418010937780.png" alt="docker run hello-world"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看下载的这个 hello-world 镜像</span><br>docker images<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230418011058247.png" alt="docker images"></p><p>卸载docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.卸载依赖</span><br>yum remove docker-ce docker-ce-cli containerd.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.删除资源</span><br>rm -rf /var/lib/docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/var/lib/docker：docker的默认工作路径</span><br></code></pre></td></tr></table></figure><h3 id="2-3-阿里云镜像加速"><a href="#2-3-阿里云镜像加速" class="headerlink" title="2.3 阿里云镜像加速"></a>2.3 阿里云镜像加速</h3><p>阿里云镜像加速：<a href="https://www.anquanclub.cn/6132.html">https://www.anquanclub.cn/6132.html</a></p><p>Docker配置国内镜像源加速教程：<a href="https://www.runoob.com/docker/docker-mirror-acceleration.html%EF%BC%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%EF%BC%89">https://www.runoob.com/docker/docker-mirror-acceleration.html（建议使用阿里云镜像加速）</a></p><p><em>高可用的镜像配置</em>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;https://bjtzu1jb.mirror.aliyuncs.com&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;http://f1361db2.m.daocloud.io&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://reg-mirror.qiniu.com&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://dockerhub.azk8s.cn&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420002709854.png" alt="配置阿里云镜像后的docker"></p><h3 id="2-4-回顾Hello-World流程"><a href="#2-4-回顾Hello-World流程" class="headerlink" title="2.4 回顾Hello World流程"></a>2.4 回顾Hello World流程</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230419234350846.png" alt="run的运行流程图"></p><h3 id="2-5-底层原理"><a href="#2-5-底层原理" class="headerlink" title="2.5 底层原理"></a>2.5 底层原理</h3><p><strong>Docker是怎么工作的？</strong></p><p>Docker是一个 Client - Server 结构的系统，Docker 的守护进程运行在主机上。通过 Socket 从客户端访问！</p><p>Docker-Server 接收到 Docker-Client 的指令，就会执行这个命令！</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230419234649418.png"></p><p><strong>Docker 为什么比 VM 快？</strong></p><ol><li>Docker 有着比虚拟机更少的抽象层</li><li>Docker 利用的是宿主机的内核，VM 需要的是 Guest OS</li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240300955.png" alt="VM和Docker的区别"></p><p>所以说，新建一个容器的时候，docker 不需要像虚拟机一样重新加载一个操作系统内核，<strong>避免引导和加载操作系统内核</strong>。虚拟机是加载 Guset OS , 分钟级别的，而docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级的，因此新建一个docker容器只需要几秒钟。</p><table><thead><tr><th></th><th>Docker容器</th><th>LXC</th><th>VM</th></tr></thead><tbody><tr><td>虚拟化类型</td><td>OS虚拟化</td><td>OS虚拟化</td><td>硬件虚拟化</td></tr><tr><td>性能</td><td>&#x3D;物理机性能</td><td>&#x3D;物理机性能</td><td>5%-20%损耗</td></tr><tr><td>隔离性</td><td>NS隔离</td><td>NS隔离</td><td>强</td></tr><tr><td>QoS</td><td>Cgroup弱</td><td>Cgroup弱</td><td>强</td></tr><tr><td>安全性</td><td>中</td><td>差</td><td>强</td></tr><tr><td>GuestOS</td><td>只支持Linux+win</td><td>只支持Linux</td><td>全部</td></tr><tr><td>可迁移性</td><td>强</td><td>弱</td><td>强</td></tr></tbody></table><h2 id="三、Docker的常用命令"><a href="#三、Docker的常用命令" class="headerlink" title="三、Docker的常用命令"></a>三、Docker的常用命令</h2><h3 id="3-1-帮助命令"><a href="#3-1-帮助命令" class="headerlink" title="3.1 帮助命令"></a>3.1 帮助命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker version# 显示docker的版本信息。<br>docker info# 显示docker的系统信息，包括镜像和容器的数量<br>docker --help# 帮助命令<br></code></pre></td></tr></table></figure><p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline/">https://docs.docker.com/engine/reference/commandline/</a></p><h3 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h3><ul><li><strong>docker images</strong> 查看所有本地的主机上的镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# docker images<br>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE<br>hello-world   latest    feb5d9fea6a5   19 months ago   13.3kB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解释</span><br>REPOSITORY # 镜像的仓库源 <br>TAG # 镜像的标签 <br>IMAGE ID # 镜像的id <br>CREATED # 镜像的创建时间 <br>SIZE # 镜像的大小<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可选项 Options:</span><br>-a, --all      # 列出所有的镜像<br>-q, --quiet    # 只显示镜像的id<br></code></pre></td></tr></table></figure><ul><li><strong>docker search</strong> 搜索镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# docker search mysql<br>NAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql                           MySQL is a widely used, open-source relation…   14050     [OK] <br>mariadb                         MariaDB Server is a high performing open sou…   5367      [OK] <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可选项</span><br>--filter=STARS=3000 搜索出来的镜像就是STARS大于3000的<br><br>[root@master ~]# docker search mysql --filter=STARS=8000<br>NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql     MySQL is a widely used, open-source relation…   14050     [OK]<br></code></pre></td></tr></table></figure><ul><li><strong>docker pull</strong> 下载镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载镜像 docker pull 镜像名[:tag]（tag是版本）</span><br>[root@master ~]# docker pull mysql<br>Using default tag: latest# 如果不写tag,默认就是latest最新版<br>latest: Pulling from library/mysql<br>72a69066d2fe: Pull complete# 分层下载<br>93619dbc5b36: Pull complete<br>99da31dd6142: Pull complete<br>626033c43d70: Pull complete<br>37d5d7efb64e: Pull complete<br>ac563158d721: Pull complete<br>d2ba16033dad: Pull complete<br>688ba7d5c01a: Pull complete<br>00e060b6d11d: Pull complete<br>1c04857f594f: Pull complete<br>4d7cfa90e6ea: Pull complete<br>e0431212d27d: Pull complete<br>Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709<br>Status: Downloaded newer image for mysql:latest<br>docker.io/library/mysql:latest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">两条命令等价</span><br>docker pull mysql<br>docker.io/library/mysql:latest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定版本下载</span><br>docker pull mysql:5.7<br></code></pre></td></tr></table></figure><p>下载完mysql lastest版本再下载5.7版本会出现 Already exists，这是两个版本冲突的包，如果本地已经有了，就不必再次下载了，这是docker的分层思想。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420005418921.png" alt="docker pull mysql:5.7"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420005626787.png"></p><ul><li><strong>docker rmi</strong> 删除镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi -f 镜像id                # 删除指定的镜像<br>docker rmi -f 镜像id 镜像id 镜像id   # 删除多个镜像<br>docker rmi -f $(docker images -aq)  # 删除全部镜像<br></code></pre></td></tr></table></figure><h3 id="3-3-容器命令"><a href="#3-3-容器命令" class="headerlink" title="3.3 容器命令"></a>3.3 容器命令</h3><p><strong>说明：我们有了镜像才可以创建容器，linux，下载一个 centos 镜像来测试学习</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull centos<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run [可选参数] image<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数说明</span><br>--name = &quot;Name&quot;    容器名字  tomcat01，tomcat02,用来区分容器<br>-d                 后台方式运行<br>-it                使用交互方式运行，进入容器查看内容<br>-p                 指定容器的端口 -p 8080：8080<br>    -p ip:主机端口：容器端口<br>    -p 主机端口：容器端口(常用)<br>    -p 容器端口<br>    容器端口<br>-P                 随机指定端口<br></code></pre></td></tr></table></figure><ul><li>测试，启动并进入容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">测试，启动并进入容器</span><br>[root@master ~]# docker images<br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>centos       latest    5d0da3dc9764   19 months ago   231MB<br><br>[root@master ~]# docker run -it centos /bin/bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看容器内的centos，基础版本，很多命令都是不完善的！</span><br>[root@af0d062b3221 /]# ls<br>bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var dev  home  lib64  media       opt  root  sbin  sys  usr<br></code></pre></td></tr></table></figure><ul><li><strong>从容器中退回主机</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@af0d062b3221 /]# exit<br>exit<br>[root@master ~]# ls<br>anaconda-ks.cfg  initial-setup-ks.cfg<br></code></pre></td></tr></table></figure><ul><li><strong>列出所有的运行的容器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker ps 命令</span><br>       # 列出当前正在运行的容器<br>  -a   # 列出当前正在运行的容器+带出历史运行过的容器<br>  -n=? # 显示最近创建的容器？代表个数<br>  -q   # 只显示容器的编号<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420011029449.png" alt="docker ps"></p><ul><li><strong>退出容器</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span>            <span class="hljs-comment"># 直接容器停止并退出</span><br>Ctrl + P + Q    <span class="hljs-comment"># 容器不停止退出</span><br></code></pre></td></tr></table></figure><ul><li><strong>删除容器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器id                  # 删除指定容器，不能删除正在运行的容器，如果要强制删除 rm -f（f是force）<br>docker rm -f $(docker ps -aq)    # 删除所有的容器<br>docker ps -aq|xargs docker rm    # 删除所有的容器<br></code></pre></td></tr></table></figure><ul><li><strong>启动和停止容器的操作</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器id        # 启动容器<br>docker restart 容器id      # 重启容器<br>docker stop 容器id         # 停止当前正在运行的容器<br>docker kill 容器id         # 强制停止当前容器<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420012014388.png"></p><h3 id="3-4-常用其它命令"><a href="#3-4-常用其它命令" class="headerlink" title="3.4 常用其它命令"></a>3.4 常用其它命令</h3><ul><li><strong>后台启动容器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令 docker run -d 镜像名</span><br>docker run -d centos<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">问题docker ps, 发现 centos 停止了</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常见的坑, docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420224011278.png"></p><ul><li><strong>查看日志</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">自己编写一段shell脚本</span><br>[root@master ~]# docker run  -d centos /bin/sh -c &quot;while true;do echo 666;sleep 1;done&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示日志</span><br>-t                # 显示日志加时间<br>-f  # 保留打印窗口，持续打印<br>--tail number     # 要显示的最后的日志条数<br><br>da3008d5641cad5839f4a354bd933c0cbd5363aba11050b31ccebdf473754396<br>[root@master ~]# docker ps<br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES<br>da3008d5641c   centos    &quot;/bin/sh -c &#x27;while t…&quot;   8 seconds ago   Up 8 seconds             boring_pare<br>[root@master ~]# docker logs -tf --tail 10 da3008d5641c<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420225009481.png"></p><ul><li><strong>查看容器中的进程信息</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令 docker top 容器<span class="hljs-built_in">id</span></span><br>[root@master ~]# docker top da3008d5641c<br>UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD<br>root                14853               14834               0                   22:49               ?                   00:00:00            /bin/sh -c while true;do echo 666;sleep 1;done<br>root                15155               14853               0                   22:52               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1<br></code></pre></td></tr></table></figure><ul><li><strong>查看镜像源数据</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker inspect 容器ID</span><br>[root@master ~]# docker inspect da3008d5641c<br>[<br>    &#123;<br>        &quot;Id&quot;: &quot;da3008d5641cad5839f4a354bd933c0cbd5363aba11050b31ccebdf473754396&quot;,<br>        &quot;Created&quot;: &quot;2023-04-20T14:49:20.020151013Z&quot;,# 容器创建时间<br>        &quot;Path&quot;: &quot;/bin/sh&quot;,<br>        &quot;Args&quot;: [# 传递的参数<br>            &quot;-c&quot;,<br>            &quot;while true;do echo 666;sleep 1;done&quot;<br>        ],<br>        &quot;State&quot;: &#123;<br>            &quot;Status&quot;: &quot;running&quot;,<br>            &quot;Running&quot;: true,<br>            &quot;Paused&quot;: false,<br>            &quot;Restarting&quot;: false,<br>            &quot;OOMKilled&quot;: false,<br>            &quot;Dead&quot;: false,<br>            &quot;Pid&quot;: 14853,<br>            &quot;ExitCode&quot;: 0,<br>            &quot;Error&quot;: &quot;&quot;,<br>            &quot;StartedAt&quot;: &quot;2023-04-20T14:49:20.496770061Z&quot;,<br>            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;<br>        &#125;,<br>        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;, # 从哪个镜像过来的<br>        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/da3008d5641cad5839f4a354bd933c0cbd5363aba11050b31ccebdf473754396/resolv.conf&quot;,<br>        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/da3008d5641cad5839f4a354bd933c0cbd5363aba11050b31ccebdf473754396/hostname&quot;,<br>        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/da3008d5641cad5839f4a354bd933c0cbd5363aba11050b31ccebdf473754396/hosts&quot;,<br>        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/da3008d5641cad5839f4a354bd933c0cbd5363aba11050b31ccebdf473754396/da3008d5641cad5839f4a354bd933c0cbd5363aba11050b31ccebdf473754396-json.log&quot;,<br>        &quot;Name&quot;: &quot;/boring_pare&quot;,<br>        &quot;RestartCount&quot;: 0,<br>        &quot;Driver&quot;: &quot;overlay2&quot;,<br>        &quot;Platform&quot;: &quot;linux&quot;,<br>        &quot;MountLabel&quot;: &quot;&quot;,<br>        &quot;ProcessLabel&quot;: &quot;&quot;,<br>        &quot;AppArmorProfile&quot;: &quot;&quot;,<br>        &quot;ExecIDs&quot;: null,<br>        &quot;HostConfig&quot;: &#123;# 主机的配置<br>            &quot;Binds&quot;: null,<br>            &quot;ContainerIDFile&quot;: &quot;&quot;,<br>            &quot;LogConfig&quot;: &#123;<br>                &quot;Type&quot;: &quot;json-file&quot;,<br>                &quot;Config&quot;: &#123;&#125;<br>            &#125;,<br>            &quot;NetworkMode&quot;: &quot;default&quot;,<br>            &quot;PortBindings&quot;: &#123;&#125;,<br>            &quot;RestartPolicy&quot;: &#123;<br>                &quot;Name&quot;: &quot;no&quot;,<br>                &quot;MaximumRetryCount&quot;: 0<br>            &#125;,<br>            &quot;AutoRemove&quot;: false,<br>            &quot;VolumeDriver&quot;: &quot;&quot;,<br>            &quot;VolumesFrom&quot;: null,<br>            &quot;ConsoleSize&quot;: [<br>                34,<br>                133<br>            ],<br>            &quot;CapAdd&quot;: null,<br>            &quot;CapDrop&quot;: null,<br>            &quot;CgroupnsMode&quot;: &quot;host&quot;,<br>            &quot;Dns&quot;: [],<br>            &quot;DnsOptions&quot;: [],<br>            &quot;DnsSearch&quot;: [],<br>            &quot;ExtraHosts&quot;: null,<br>            &quot;GroupAdd&quot;: null,<br>            &quot;IpcMode&quot;: &quot;private&quot;,<br>            &quot;Cgroup&quot;: &quot;&quot;,<br>            &quot;Links&quot;: null,<br>            &quot;OomScoreAdj&quot;: 0,<br>            &quot;PidMode&quot;: &quot;&quot;,<br>            &quot;Privileged&quot;: false,<br>            &quot;PublishAllPorts&quot;: false,<br>            &quot;ReadonlyRootfs&quot;: false,<br>            &quot;SecurityOpt&quot;: null,<br>            &quot;UTSMode&quot;: &quot;&quot;,<br>            &quot;UsernsMode&quot;: &quot;&quot;,<br>            &quot;ShmSize&quot;: 67108864,<br>            &quot;Runtime&quot;: &quot;runc&quot;,<br>            &quot;Isolation&quot;: &quot;&quot;,<br>            &quot;CpuShares&quot;: 0,<br>            &quot;Memory&quot;: 0,<br>            &quot;NanoCpus&quot;: 0,<br>            &quot;CgroupParent&quot;: &quot;&quot;,<br>            &quot;BlkioWeight&quot;: 0,<br>            &quot;BlkioWeightDevice&quot;: [],<br>            &quot;BlkioDeviceReadBps&quot;: [],<br>            &quot;BlkioDeviceWriteBps&quot;: [],<br>            &quot;BlkioDeviceReadIOps&quot;: [],<br>            &quot;BlkioDeviceWriteIOps&quot;: [],<br>            &quot;CpuPeriod&quot;: 0,<br>            &quot;CpuQuota&quot;: 0,<br>            &quot;CpuRealtimePeriod&quot;: 0,<br>            &quot;CpuRealtimeRuntime&quot;: 0,<br>            &quot;CpusetCpus&quot;: &quot;&quot;,<br>            &quot;CpusetMems&quot;: &quot;&quot;,<br>            &quot;Devices&quot;: [],<br>            &quot;DeviceCgroupRules&quot;: null,<br>            &quot;DeviceRequests&quot;: null,<br>            &quot;MemoryReservation&quot;: 0,<br>            &quot;MemorySwap&quot;: 0,<br>            &quot;MemorySwappiness&quot;: null,<br>            &quot;OomKillDisable&quot;: false,<br>            &quot;PidsLimit&quot;: null,<br>            &quot;Ulimits&quot;: null,<br>            &quot;CpuCount&quot;: 0,<br>            &quot;CpuPercent&quot;: 0,<br>            &quot;IOMaximumIOps&quot;: 0,<br>            &quot;IOMaximumBandwidth&quot;: 0,<br>            &quot;MaskedPaths&quot;: [<br>                &quot;/proc/asound&quot;,<br>                &quot;/proc/acpi&quot;,<br>                &quot;/proc/kcore&quot;,<br>                &quot;/proc/keys&quot;,<br>                &quot;/proc/latency_stats&quot;,<br>                &quot;/proc/timer_list&quot;,<br>                &quot;/proc/timer_stats&quot;,<br>                &quot;/proc/sched_debug&quot;,<br>                &quot;/proc/scsi&quot;,<br>                &quot;/sys/firmware&quot;<br>            ],<br>            &quot;ReadonlyPaths&quot;: [<br>                &quot;/proc/bus&quot;,<br>                &quot;/proc/fs&quot;,<br>                &quot;/proc/irq&quot;,<br>                &quot;/proc/sys&quot;,<br>                &quot;/proc/sysrq-trigger&quot;<br>            ]<br>        &#125;,<br>        &quot;GraphDriver&quot;: &#123;<br>            &quot;Data&quot;: &#123;<br>                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/c596744e1c8bb435f4c9162c9d90723e1edc3293ba2c4e27f5ccfdba3eb1b719-init/diff:/var/lib/docker/overlay2/beaebc6f6613189b207a39e4be551dc60d5d3a096e9612b32e92ca4868fc9edd/diff&quot;,<br>                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/c596744e1c8bb435f4c9162c9d90723e1edc3293ba2c4e27f5ccfdba3eb1b719/merged&quot;,<br>                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/c596744e1c8bb435f4c9162c9d90723e1edc3293ba2c4e27f5ccfdba3eb1b719/diff&quot;,<br>                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/c596744e1c8bb435f4c9162c9d90723e1edc3293ba2c4e27f5ccfdba3eb1b719/work&quot;<br>            &#125;,<br>            &quot;Name&quot;: &quot;overlay2&quot;<br>        &#125;,<br>        &quot;Mounts&quot;: [],# 挂载<br>        &quot;Config&quot;: &#123;<br>            &quot;Hostname&quot;: &quot;da3008d5641c&quot;,<br>            &quot;Domainname&quot;: &quot;&quot;,<br>            &quot;User&quot;: &quot;&quot;,<br>            &quot;AttachStdin&quot;: false,<br>            &quot;AttachStdout&quot;: false,<br>            &quot;AttachStderr&quot;: false,<br>            &quot;Tty&quot;: false,<br>            &quot;OpenStdin&quot;: false,<br>            &quot;StdinOnce&quot;: false,<br>            &quot;Env&quot;: [<br>                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;<br>            ],<br>            &quot;Cmd&quot;: [<br>                &quot;/bin/sh&quot;,<br>                &quot;-c&quot;,<br>                &quot;while true;do echo 666;sleep 1;done&quot;<br>            ],<br>            &quot;Image&quot;: &quot;centos&quot;,<br>            &quot;Volumes&quot;: null,<br>            &quot;WorkingDir&quot;: &quot;&quot;,<br>            &quot;Entrypoint&quot;: null,<br>            &quot;OnBuild&quot;: null,<br>            &quot;Labels&quot;: &#123;<br>                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,<br>                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,<br>                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,<br>                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,<br>                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;<br>            &#125;<br>        &#125;,<br>        &quot;NetworkSettings&quot;: &#123;# 网络配置<br>            &quot;Bridge&quot;: &quot;&quot;,<br>            &quot;SandboxID&quot;: &quot;0b38c1107b4c23d89525c9baad9a0dc5691910e1b4b2e4bea989dd4f50142316&quot;,<br>            &quot;HairpinMode&quot;: false,<br>            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,<br>            &quot;LinkLocalIPv6PrefixLen&quot;: 0,<br>            &quot;Ports&quot;: &#123;&#125;,<br>            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/0b38c1107b4c&quot;,<br>            &quot;SecondaryIPAddresses&quot;: null,<br>            &quot;SecondaryIPv6Addresses&quot;: null,<br>            &quot;EndpointID&quot;: &quot;ef9d43cda8b318ad2890785fae450a8dff6c19fa05c0bc0586338f62cbabd1f4&quot;,<br>            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>            &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>            &quot;GlobalIPv6PrefixLen&quot;: 0,<br>            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>            &quot;IPPrefixLen&quot;: 16,<br>            &quot;IPv6Gateway&quot;: &quot;&quot;,<br>            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>            &quot;Networks&quot;: &#123;<br>                &quot;bridge&quot;: &#123;<br>                    &quot;IPAMConfig&quot;: null,<br>                    &quot;Links&quot;: null,<br>                    &quot;Aliases&quot;: null,<br>                    &quot;NetworkID&quot;: &quot;3aa02576742d371bf5cdea1d676c799a7f9d3ac976870b882993dd10280324f0&quot;,<br>                    &quot;EndpointID&quot;: &quot;ef9d43cda8b318ad2890785fae450a8dff6c19fa05c0bc0586338f62cbabd1f4&quot;,<br>                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>                    &quot;IPPrefixLen&quot;: 16,<br>                    &quot;IPv6Gateway&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6PrefixLen&quot;: 0,<br>                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>                    &quot;DriverOpts&quot;: null<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><ul><li><strong>进入当前正在运行的容器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">我们的容器通常都是使用后台方式运行的，若要进入容器，需要修改一些配置</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令</span><br>docker exec -it 容器id baseShell<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">测试</span><br>[root@master ~]# docker ps<br>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES<br>da3008d5641c   centos    &quot;/bin/sh -c &#x27;while t…&quot;   12 minutes ago   Up 12 minutes             boring_pare<br>[root@master ~]# docker exec -it da3008d5641c /bin/bash<br>[root@da3008d5641c /]# ls<br>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br>[root@da3008d5641c /]# ps -ef<br>UID         PID   PPID  C STIME TTY          TIME CMD<br>root          1      0  0 14:49 ?        00:00:00 /bin/sh -c while true;do echo 666;sleep 1;done<br>root        752      0  0 15:01 pts/0    00:00:00 /bin/bash<br>root        808      1  0 15:02 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1<br>root        809    752  0 15:02 pts/0    00:00:00 ps -ef<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方式二</span><br>docker attach 容器ID<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">测试</span><br>[root@master ~]# docker attach da3008d5641c<br>666<br>666<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker <span class="hljs-built_in">exec</span>        <span class="hljs-comment"># 进入容器后开启一个新的终端，可以在里面操作(常用)</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker attach      <span class="hljs-comment"># 进入容器正在执行的终端，不会启动新的进程</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>从容器内拷贝到主机上</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令</span><br>docker cp [r] 容器id :容器内路径 目的地主机路径<br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数r : 递归拷贝</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动容器</span><br>[root@master home]# docker start 0a179a4eb26e<br>0a179a4eb26e<br><br>[root@master home]# docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES<br>0a179a4eb26e   centos    &quot;/bin/bash&quot;   2 minutes ago   Up 3 seconds             practical_wozniak<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入docker容器内部</span><br>[root@master home]# docker attach 0a179a4eb26e<br>[root@0a179a4eb26e /]# cd /home/<br>[root@0a179a4eb26e home]# ls<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在容器内新建一个文件</span><br>[root@0a179a4eb26e home]# touch test.java<br>[root@0a179a4eb26e home]# exit<br>exit<br><br>[root@master home]# docker ps -a<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES<br>0a179a4eb26e   centos    &quot;/bin/bash&quot;   3 minutes ago   Exited (0) 4 seconds ago             practical_wozniak<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件拷贝出来到主机上</span><br>[root@master home]# docker cp 0a179a4eb26e:/home/test.java /home<br>Successfully copied 1.536kB to /home<br>[root@master home]# ls<br>data  pflm  test.java  xiaoyu<br></code></pre></td></tr></table></figure><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240300869.png" alt="docker命令图"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell">attach Attach local standard input, output, and error streams to a running container# 当前 shell 下 attach 连接指定运行镜像 <br>build Build an image from a Dockerfile# 通过 Dockerfile 定制镜像 <br>commit Create a new image from a container&#x27;s changes# 提交当前容器为新的镜像 <br>cp Copy files/folders between a container and the local filesystem# 从容器中拷贝指定文件或者目录到宿主机中 <br>create Create a new container# 创建一个新的容器，同run，但不启动容器 <br>diff Inspect changes to files or directories on a container&#x27;s filesystem# 查看docker容器变化 <br>events Get real time events from the server# 从 docker 服务获取容器实时事件<br>exec Run a command in a running container# 在已存在的容器上运行命令<br>export Export a container&#x27;s filesystem as a tar archive# 导出容器的内容作为一个 tar 归档文件[对应import] <br>history Show the history of an image# 显示一个镜像形成历史 <br>images List images# 列出系统当前的镜像 <br>import Import the contents from a tarball to create a filesystem image# 从tar包中导入内容创建一个新的文件系统映像[对应export] <br>info Display system-wide information# 显示系统相关信息 <br>inspect Return low-level information on Docker objects# 查看容器详细信息 <br>kill Kill one or more running containers# kill 指定 docker 容器 <br>load Load an image from a tar archive or STDIN# 从一个 tar 包加载一个镜像[对应save] <br>login Log in to a Docker registry# 注册或登录一个 docker 源服务器<br>logout Log out from a Docker registry# 从当前 Docker registry 退出<br>logs Fetch the logs of a container# 输出当前容器日志信息<br>pause Pause all processes within one or more containers# 暂停容器<br>port List port mappings or a specific mapping for the container# 查看映射端口对应的容器内部源端口<br>ps List containers# 列出容器列表<br>pull Pull an image or a repository from a registry# 从docker镜像源服务器拉取指定镜像或者库镜像<br>push Push an image or a repository to a registry# 推送指定镜像或者库镜像至docker源服务器<br>rename Rename a container# <br>restart Restart one or more containers# 重启运行的容器<br>rm Remove one or more containers# 移除一个或者多个容器<br>rmi Remove one or more images# 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]<br>run Run a command in a new container# 创建一个新的容器并运行一个命令<br>save Save one or more images to a tar archive (streamed to STDOUT by default)# 保存一个镜像为一个 tar 包[对应load]<br>search Search the Docker Hub for images# 在 docker hub 中搜索镜像<br>start Start one or more stopped containers# 启动容器<br>stats Display a live stream of container(s) resource usage statistics<br>stop Stop one or more running containers# 停止容器<br>tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE# 给源中镜像打标签<br>top Display the running processes of a container# 查看容器中运行的进程信息<br>unpause Unpause all processes within one or more containers# 取消暂停容器<br>update Update configuration of one or more containers <br>version Show the Docker version information# 查看 docker 版本号<br>wait Block until one or more containers stop, then print their exit codes# 截取容器停止时的退出状态值<br></code></pre></td></tr></table></figure><h3 id="3-6-作业练习"><a href="#3-6-作业练习" class="headerlink" title="3.6 作业练习"></a>3.6 作业练习</h3><h4 id="Docker-安装-Nginx"><a href="#Docker-安装-Nginx" class="headerlink" title="Docker 安装 Nginx"></a>Docker 安装 Nginx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1、搜索镜像</span><br>[root@master home]# docker search nginx<br>NAME                                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>nginx                                             Official build of Nginx.                        18408     [OK]<br>unit                                              Official build of NGINX Unit: a polyglot app…   0         [OK]<br>bitnami/nginx                                     Bitnami nginx Docker Image                      158                  [OK]<br>bitnami/nginx-ingress-controller                  Bitnami Docker Image for NGINX Ingress Contr…   25                   [OK]<br>ubuntu/nginx                                      Nginx, a high-performance reverse proxy &amp; we…   84<br>kasmweb/nginx                                     An Nginx image based off nginx:alpine and in…   4<br>rancher/nginx-ingress-controller                                                                  11<br>rancher/nginx-ingress-controller-defaultbackend                                                   2<br>bitnami/nginx-exporter                                                                            3<br>rancher/nginx                                                                                     2<br>rapidfort/nginx-ib                                RapidFort optimized, hardened image for NGIN…   0<br>rapidfort/nginx                                   RapidFort optimized, hardened image for NGINX   3<br>vmware/nginx-photon                                                                               1<br>bitnami/nginx-ldap-auth-daemon                                                                    3<br>rapidfort/nginx-official                          RapidFort optimized, hardened image for NGIN…   1<br>vmware/nginx                                                                                      2<br>rancher/nginx-conf                                                                                0<br>linuxserver/nginx                                 An Nginx container, brought to you by LinuxS…   192<br>privatebin/nginx-fpm-alpine                       PrivateBin running on an Nginx, php-fpm &amp; Al…   72                   [OK]<br>bitnami/nginx-intel                                                                               1<br>rancher/nginx-ssl                                                                                 0<br>circleci/nginx                                    This image is for internal use                  2<br>continuumio/nginx-ingress-ws                                                                      0<br>rancher/nginx-ingress-controller-amd64                                                            0<br>webdevops/nginx                                   Nginx container                                 11                   [OK]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2、下载镜像 pull</span><br>[root@master home]# docker pull nginx<br>Using default tag: latest<br>latest: Pulling from library/nginx<br>a2abf6c4d29d: Pull complete<br>a9edb18cadd1: Pull complete<br>589b7251471a: Pull complete<br>186b1aaa4aa6: Pull complete<br>b4df32aa5a72: Pull complete<br>a0bcbecc962e: Pull complete<br>Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31<br>Status: Downloaded newer image for nginx:latest<br>docker.io/library/nginx:latest<br><br><br>[root@master home]# docker images<br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>nginx        latest    605c77e624dd   15 months ago   141MB<br>centos       latest    5d0da3dc9764   19 months ago   231MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d 后台运行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--name 给容器命名</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-p 宿主机，容器内部端口</span><br>[root@master home]# docker run -d --name nginx01 -p 3344:80 nginx<br>6ba58e0cadf81d4c807d42946f70ce867ef140a3a0337658154583c1b93a9066<br>docker[root@master home]# docker ps<br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES<br>6ba58e0cadf8   nginx     &quot;/docker-entrypoint.…&quot;   5 seconds ago   Up 2 seconds   0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp   nginx01<br><br>[root@master home]# curl localhost:3344<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>[root@master home]# docker exec -it nginx01 /bin/bash<br>root@6ba58e0cadf8:/# whereis nginx<br>nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx<br>root@6ba58e0cadf8:/# cd /etc/nginx/<br>root@6ba58e0cadf8:/etc/nginx# ls<br>conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params<br>root@6ba58e0cadf8:/etc/nginx#<br></code></pre></td></tr></table></figure><p>端口暴露的概念</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420234237227.png" alt="端口暴露"></p><p>可以在公网访问了</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420234333825.png" alt="在外网访问nginx"></p><p>停止容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master home]# docker stop 6ba58e0cadf8<br>6ba58e0cadf8<br></code></pre></td></tr></table></figure><p>外网无法访问</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230420235128398.png" alt="外网无法访问"></p><p><strong>思考问题：</strong>我们每次改动 nginx 配置文件，都需要进入容器内部吗？那会十分的麻烦。我要是可以在容器外部提供一个映射路径，达到在容器外修改文件名，容器内部就可以自动修改。 <code>-v</code> 数据卷 技术可以解决！</p><h4 id="Docker-安装-Tomcat"><a href="#Docker-安装-Tomcat" class="headerlink" title="Docker 安装 Tomcat"></a>Docker 安装 Tomcat</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">官方使用</span><br>docker run -it --rm tomcat:9.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们之前的启动都是后台，停止了容器之后，容器还是可以查到</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--<span class="hljs-built_in">rm</span> 一般用来测试，用完即删</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们正常操作，下载启动</span><br>docker pull tomcat<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动运行</span><br>docker run -d -p 3355:8080 --name tomcat01 tomcat<br></code></pre></td></tr></table></figure><p>外网访问没有问题，但此时的tomcat是不完整的。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230421001109021.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>[root@master home]# docker exec -it tomcat01 /bin/bash<br><br>root@ae782d777533:/usr/local/tomcat# ls<br>BUILDING.txt     LICENSE  README.md      RUNNING.txt  conf  logs            temp     webapps.dist<br>CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin          lib   native-jni-lib  webapps  work<br><br>root@ae782d777533:/usr/local/tomcat# cd webapps<br>root@ae782d777533:/usr/local/tomcat/webapps# ls<br>root@ae782d777533:/usr/local/tomcat/webapps#<br></code></pre></td></tr></table></figure><p>发现问题：</p><p>1、linux命令少了 </p><p>2、webapps文件夹为空 </p><p>原因：阿里云镜像（阉割版），它为保证最小镜像，将不必要的都剔除了→保证最小可运行环境！</p><p>解决：把webapps.dist文件下的内容复制到webapps文件夹下，再次访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@ae782d777533:/usr/local/tomcat# cd webapps.dist/<br>root@ae782d777533:/usr/local/tomcat/webapps.dist# ls<br>ROOT  docs  examples  host-manager  manager<br>root@ae782d777533:/usr/local/tomcat/webapps.dist# cd ..<br>root@ae782d777533:/usr/local/tomcat# cp -r webapps.dist/* webapps<br>root@ae782d777533:/usr/local/tomcat# cd webapps<br>root@ae782d777533:/usr/local/tomcat/webapps# ls<br>ROOT  docs  examples  host-manager  manager<br>root@ae782d777533:/usr/local/tomcat/webapps#<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230421001604839.png"></p><p><strong>思考问题：</strong>我们以后要部署项目，都需要进入容器内部，十分的麻烦。我要是可以在容器外部放置项目，能自动同步到内部就好了。</p><h4 id="部署ES-Kibana"><a href="#部署ES-Kibana" class="headerlink" title="部署ES+Kibana"></a>部署ES+Kibana</h4><p>难点：</p><ol><li>ES暴露的端口很多</li><li>ES十分的耗内存</li><li>ES的数据一般需要放置到安全目录（挂载）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">--net somenetwork 是 网络配置，后续再使用</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载启动elasticsearch（Docker一步搞定）</span><br>docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ES非常耗内存，所以上一步启动了ES之后，linux就非常的卡。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用命令 docker stats 查看CPU的状态</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230504235128633.png" alt="ES占用1.2个G的内存"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">测试ES是否成功</span><br><br>[root@MiWiFi-R4A-srv ~]# curl localhost:9200<br>&#123;<br>  &quot;name&quot; : &quot;d48893932faf&quot;,<br>  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,<br>  &quot;cluster_uuid&quot; : &quot;6kuxlnPAQFy-hGcKXYBgiw&quot;,<br>  &quot;version&quot; : &#123;<br>    &quot;number&quot; : &quot;7.6.2&quot;,<br>    &quot;build_flavor&quot; : &quot;default&quot;,<br>    &quot;build_type&quot; : &quot;docker&quot;,<br>    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,<br>    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,<br>    &quot;build_snapshot&quot; : false,<br>    &quot;lucene_version&quot; : &quot;8.4.0&quot;,<br>    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,<br>    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;<br>  &#125;,<br>  &quot;tagline&quot; : &quot;You Know, for Search&quot;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将ES停掉，重新分配内存，修改配置文件 -e 环境配置修改</span><br>docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看内存占用</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230504235938487.png" alt="ES占用150M内存"></p><p id="2">作业：使用kibana连接es？思考网络如何才能连接。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505000254838.png" alt="如何让kibana连接ES？"></p><h3 id="3-7-可视化"><a href="#3-7-可视化" class="headerlink" title="3.7 可视化"></a>3.7 可视化</h3><ul><li><p><strong>portainer</strong>（先用这个，不常用）</p><p>介绍：Docker 图形化界面管理工具！提供一个后台面板供我们操作！</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行如下命令即可 打开可视化服务</span><br>docker run -d -p 8088:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer<br></code></pre></td></tr></table></figure><p>访问测试：从外网访问8088，<a href="http://ip:8088/%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%9B%E5%85%A5%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83%E4%B9%85%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E8%A6%81%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%99%E6%8C%82%E8%BD%BD%E5%87%BA%E6%9D%A5%E3%80%82">http://ip:8088/，第一次进入时间比较久，因为它要把所有的数据给挂载出来。</a></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230422201924364.png" alt="登陆界面"></p><p>给它设置一个密码就可以使用了</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230422202020730.png"></p><p>选择本地的：Local，进入之后的面板如下</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230422202148113.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230422202243513.png"></p><p>可视化面板平时不会使用，大家自己测试玩玩即可。</p><h2 id="四、Docker镜像讲解"><a href="#四、Docker镜像讲解" class="headerlink" title="四、Docker镜像讲解"></a>四、Docker镜像讲解</h2><h3 id="4-1-镜像是什么"><a href="#4-1-镜像是什么" class="headerlink" title="4.1 镜像是什么"></a>4.1 镜像是什么</h3><ul><li><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某 个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p></li><li><p>将所有的应用和环境，直接打包为docker镜像，就可以直接运行。</p><p>如何得到镜像：</p><ul><li>从远处仓库下载</li><li>他人拷贝过来</li><li>自己制作一个镜像 DockerFile</li></ul></li></ul><h3 id="4-2-Docker-镜像加载原理"><a href="#4-2-Docker-镜像加载原理" class="headerlink" title="4.2 Docker 镜像加载原理"></a>4.2 Docker 镜像加载原理</h3><blockquote><p>UnionFs（联合文件系统）</p></blockquote><ul><li>我们下载的时候看到一层层的下载就是这个。</li><li>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支 持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</li><li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系 统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li></ul><blockquote><p>Docker镜像加载原理</p></blockquote><ul><li>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是 UnionFS。</li><li>bootfs（boot file system）主要包含 bootloader 和 Kernel，bootloader 主要是引导加载 kernel，Linux 刚启动时会加 bootfs 文件系统，在 Docker 镜像的最底层是 boots。这一层与我们典型的 Linux&#x2F;Unix 系统是一样的，包含 boot 加載器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时 内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</li><li>rootfs（root file system)，在 bootfs 之上。包含的就是典型 Linux 系统中 的 &#x2F;dev，&#x2F;proc，&#x2F;bin。&#x2F;etc 等标准目录和文件。 rootfs 就是各种不同的操作系统发行版，比如 Ubuntu，Centos等等。</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230422202846356.png"></p><p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230422203318596.png"></p><p>对于个精简的OS，rootfs 可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用 Host 的 kernel，自己只需要提供 rootfs 就可以了。由此可见对于不同的 Linux 发行版，boots基本是一致 的，rootfs 会有差別，因此不同的发行版可以公用 bootfs.</p><p>虚拟机是分钟级别，容器是秒级！</p><h3 id="4-3-分层理解"><a href="#4-3-分层理解" class="headerlink" title="4.3 分层理解"></a>4.3 分层理解</h3><p>我们下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载</p><p>第一层显示 Already exists，已经存在，是基本层</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230422203520499.png"></p><blockquote><p>思考：为什么Docker镜像要采用这种分层的结构呢？</p></blockquote><p>最大的好处就是资源共享！比如有多个镜像都从相同的 Base 镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p><p>查看镜像分层的方式可以通过<code>docker image inspect [镜像名]</code> 命令：docker image inspect redis:latest</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230422203945998.png"></p><blockquote><p>理解</p></blockquote><ul><li>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</li><li>举一个简单的例子，假如基于 Ubuntu Linux16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python 包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层</li><li>该像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240301065.png"></p><p>再添加额外镜像层的同时，镜像始终保持是当前所有镜像的组合，（理解这一点非常重要）如下图，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240303155.png"></p><p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件</p><p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240301597.png"></p><p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p><p>Linux上可用的存储引擎有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p><p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW(写时复制)。</p><p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240301823.png"></p><blockquote><p>特点</p></blockquote><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！</p><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240301443.png"></p><p>如何提交一个自己的镜像？</p><h3 id="4-4-commit镜像"><a href="#4-4-commit镜像" class="headerlink" title="4.4 commit镜像"></a>4.4 commit镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit 提交容器成为一个新的副本<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令和git原理类似</span><br>docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]<br></code></pre></td></tr></table></figure><p>实战测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1、启动一个默认的tomcat</span><br>docker run -d -p 8080:8080 tomcat<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！</span><br>docker exec -it 容器id /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3、拷贝文件进去</span><br>cp -r webapps.dist/* webapps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。</span><br>docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]<br>docker commit -a=&quot;kuangshen&quot; -m=&quot;add webapps app&quot; 容器id tomcat02:1.0<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230422211313150.png"></p><p>如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比使用VM的时候的快照。</p><p>到这里才算是入门Docker。</p><h2 id="五、容器数据卷"><a href="#五、容器数据卷" class="headerlink" title="五、容器数据卷"></a>五、容器数据卷</h2><h3 id="5-1-什么是容器数据卷"><a href="#5-1-什么是容器数据卷" class="headerlink" title="5.1 什么是容器数据卷"></a>5.1 什么是容器数据卷</h3><p><strong>docker 的理念回顾</strong></p><p>将应用和环境打包成一个镜像！</p><p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p><p>MySQL，容器删除了，删库跑路！需求：MySQL 数据可以存储在本地</p><p>容器之间可以有一个数据共享的技术！Docker 容器中产生的数据，同步到本地</p><p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到 Linux 上面</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230424235758499.png"></p><p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h3 id="5-2-使用数据卷"><a href="#5-2-使用数据卷" class="headerlink" title="5.2 使用数据卷"></a>5.2 使用数据卷</h3><blockquote><p>方式一：直接使用命令来挂载 -v</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -v 主机目录：容器内目录<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">测试</span><br>[root@master home]# docker run -it -v /home/ceshi:/home centos /bin/bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动起来的时候我们可以通过 docker inspect 容器ID 查看</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230425000622550.png"></p><p><em>注：这是双向绑定</em></p><p><strong>测试文件的同步</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230425001055458.png"></p><p>再来测试</p><ol><li><p>停止容器</p></li><li><p>宿主机修改文件</p></li><li><p>启动容器</p></li><li><p>容器内的数据依旧是同步的</p></li></ol><p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p><h3 id="5-3-实战：安装MySQL"><a href="#5-3-实战：安装MySQL" class="headerlink" title="5.3 实战：安装MySQL"></a>5.3 实战：安装MySQL</h3><p id="1">思考：MySQL的数据持久化的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取mysql镜像</span>  <br>docker pull mysql:5.7 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行容器,需要做数据挂载</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装启动mysql，需要配置密码的，这是要注意点！（去docker hub上找官方命令）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参考官网-e 表示配置，昨天配置过网络限速，这里是配置密码</span><br>hub docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动</span><br>-d 后台运行 <br>-p 端口映射 <br>-v 卷挂载 （可以挂载多个）<br>-e 环境配置 <br>-- name 容器名字 <br>docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动成功之后，我们在本地使用sqlyog来测试一下</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">sqlyog--连接到服务器的3310--和容器内的3306映射</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426232130573.png" alt="测试MySQL连接"></p><p>在本地测试创建一个数据，查看一下我们映射的路径是否ok</p><p>新建一个数据库后，对应的主机内的<code>/home/mysql/data</code>也出现了test数据库的文件</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506021323231.png" alt="创建数据库"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426232301801.png"></p><p>假设我们将容器删除</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> mysql01<br>docker <span class="hljs-built_in">ps</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426232344260.png"></p><p>发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能。</p><h3 id="5-4-具名和匿名挂载"><a href="#5-4-具名和匿名挂载" class="headerlink" title="5.4 具名和匿名挂载"></a>5.4 具名和匿名挂载</h3><h4 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">-P 不指定路径<br>-v 容器内路径! <br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里没指定容器外路径</span><br>docker run -d -P --name nginx01 -v /etc/nginx nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有的volume（卷）的情况</span> <br>docker volume ls<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这种就是匿名挂载，我们在 -v 只写了容器内的路径，没有写容器外的路径！</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426232629027.png"></p><h4 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">具名挂载</span> <br>docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx <br>docker volume ls  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 -v 卷名：容器内路径</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看一下这个卷</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426232751918.png"></p><p>所有的docker容器内的卷，没有指定目录的情况下都是在 <code>/var/lib/docker/volumes/[xxx]/_data</code> 下</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426232833258.png"></p><p>我们通过具名挂载可以方便的找到我们的一个卷，大多数情况使用<code>具名挂载</code></p><p><strong>如何确定是具名挂载还是匿名挂载，还是指定路径挂载？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-v 容器内路径#匿名挂载<br>-v 卷名：容器内路径#具名挂载（和指定路径挂载没关系，具名是指定卷名）<br>-v /宿主机路径：容器内路径 #指定路径挂载 此时 docker volume ls 是查看不到的<br></code></pre></td></tr></table></figure><p><strong>扩展：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 -v 容器内路径： ro rw 改变读写权限</span><br>ro -&gt; readonly 只读<br>rw -&gt; readwrite 可读可写<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一旦设置了容器权限，容器对我们挂载出来的内容就有限定了</span><br>docker run -d -P --name nginx02 -v juming:/etc/nginx:ro nginx<br>docker run -d -P --name nginx02 -v juming:/etc/nginx:rw nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！默认的是rw</span><br></code></pre></td></tr></table></figure><h3 id="5-5-初识Dockerfile"><a href="#5-5-初识Dockerfile" class="headerlink" title="5.5 初识Dockerfile"></a>5.5 初识Dockerfile</h3><blockquote><p>第二种挂载方式</p></blockquote><p>Dockerfile 就是用来构建 docker 镜像的构建文件！相当于命令脚本。先体验一下。</p><p>通过这个脚本可以生成镜像。镜像是一层一层的，脚本的一个个的命令，每个命令都是一层</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个dockerfile文件，名字可以随便 建议Dockerfile，这里 vim dockerfile1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件中的内容 指令(大写) 参数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在dockerfile1中编写以下内容</span><br>FROM centos <br><br>VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] <br><br>CMD echo &quot;----end----&quot; <br>CMD /bin/bash <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里的每个命令，就是镜像的一层！</span><br></code></pre></td></tr></table></figure><p><code>docker build -f /home/docker-test-volume/dockerfile1 -t kuangshen/centos:1.0 .</code>最后面要加上 “<code>.</code>”</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426235006489.png"></p><p><code>docker images</code>，这里就是我们自己创建的镜像</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426235049773.png"></p><p>启动一下自己写的容器</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426235311860.png"></p><p>这个卷和外部一定有一个同步的目录。且这种方式属于匿名挂载</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426235527585.png"></p><p>我们现在容器中的卷内创建一个文件<code>container.txt</code></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426235750691.png"></p><p>不要退出容器，在容器外查看</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426235832457.png"></p><p>可以看到挂载的卷的位置</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230426235926575.png"></p><p>进入路径，可以看到同步过来的文件。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230427000102175.png"></p><p>测试一下刚才的文件是否同步出去了：在主机的挂载目录下也能找到刚才创建的文件，说明同步成功了</p><p>这种方式使用的十分多，因为我们通常会构建自己的镜像！</p><p>假设构建镜像时候没有挂载卷，要手动镜像挂载 <code>-v 卷名：容器内路径</code>！</p><h3 id="5-6-数据卷容器"><a href="#5-6-数据卷容器" class="headerlink" title="5.6 数据卷容器"></a>5.6 数据卷容器</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230427000336179.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动三个容器</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1</span><br>docker run -it --name docker01 kuangshen/centos:1.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2 使用--volumes-from 继承docker01，使docker01的数据卷同步到docker02中</span><br>docker run -it --name docker02 --volumes-from docker01 kuangshen/centos:1.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3 略，和docker02的模式一样</span><br></code></pre></td></tr></table></figure><p>进入docker01的数据卷创建一个文件</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230427001101874.png"></p><p>再进入docker02，会发现docker01创建的内容同步到了docker02上</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230427001316058.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --name docker02 --volumes-from docker01 kuangshen/centos:1.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker02 = Son</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--volumes-from = extends</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker01 = Father</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">相当于docker02继承了docker01，只要通过--volumes-from就可以实现数据的共享</span><br></code></pre></td></tr></table></figure><p>Q：如果我们把docker01停掉，docker02和docker03的数据还在不在？</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230427001654541.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230427001745416.png"></p><p><a href="#1">回顾第三小节</a>：多个MySQL实现数据共享</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7<br><br>docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个时候，可以实现两个容器数据同步！</span><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用为止。</li><li>但是一旦你持久化到了本地（-v），这个时候，本地的数据是一直不会被删除的</li></ol><h2 id="六、DockerFile"><a href="#六、DockerFile" class="headerlink" title="六、DockerFile"></a>六、DockerFile</h2><h3 id="6-1-DockerFile介绍"><a href="#6-1-DockerFile介绍" class="headerlink" title="6.1 DockerFile介绍"></a>6.1 DockerFile介绍</h3><p>dockerfile 是用来构建docker镜像的文件！是一个命令参数脚本</p><p>构建步骤：</p><ol><li><p>编写一个 dockerfile 文件</p></li><li><p>docker build 构建成为一个镜像</p></li><li><p>docker run 运行镜像</p></li><li><p>docker push 发布镜像（DockerHub 、阿里云仓库）</p></li></ol><p>看下官方是怎么做的？</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230427003322784.png"></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230427003440913.png"></p><p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！（可能一百个人有一百个需求，我们可能要求镜像里除了centos，还要有jdk、mysql）</p><p>官方既然可以制作镜像，那我们也可以！</p><h3 id="6-2-DockerFile-构建过程"><a href="#6-2-DockerFile-构建过程" class="headerlink" title="6.2 DockerFile 构建过程"></a>6.2 DockerFile 构建过程</h3><p>基础知识：</p><ol><li>每个保留关键字（指令）都是必须是大写字母</li><li>执行从上到下顺序</li><li><code>#</code> 表示注释</li><li>每一个指令都会创建提交一个新的镜像层，并提交！</li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240302497.png"></p><p>Dockerfile 是面向开发的，我们以后要发布项目，做镜像，就需要编写 dockerfile 文件，这个文件十分简单！</p><p>Docker 镜像逐渐成企业交付的标准，必须要掌握！</p><ul><li><strong>DockerFile</strong>：构建文件，定义了一切的步骤。相当于源代码</li><li><strong>DockerImages</strong>：通过DockerFile构建生成的镜像。是最终发布和运行的产品。</li><li><strong>Docker 容器</strong>：容器就是镜像运行起来提供服务。</li><li><strong>DockerFile –&gt; DockerImages –&gt; Docker 容器</strong>：代码–类–类创建出来的对象</li></ul><h3 id="6-3-DockerFile的指令"><a href="#6-3-DockerFile的指令" class="headerlink" title="6.3 DockerFile的指令"></a>6.3 DockerFile的指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM # 基础镜像，一切从这里开始构建 <br>MAINTAINER  # 镜像是谁写的， 姓名+邮箱 <br>LABEL# 现在推荐写 LABEL，代替上面的那个<br>RUN # 镜像构建的时候需要运行的命令 <br>ADD # 步骤：如要加一个tomcat镜像，就是加这个tomcat压缩包！1.添加内容 2.添加同目录 <br>WORKDIR    # 镜像的工作目录 <br>VOLUME # 挂载的目录 <br>EXPOSE # 暴露端口配置 <br>CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。 <br>ENTRYPOINT  # 指定这个容器启动的时候要运行的命令，可以追加命令 <br>ONBUILD # 当构建一个被继承的 DockerFile 时，这时就会运行ONBUILD的指令，触发别的指令。<br>COPY # 类似ADD，将我们文件拷贝到镜像中 <br>ENV # 构建的时候设置环境变量！<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240302994.png" alt="image-20241124030215925"></p><h3 id="6-4-实战测试"><a href="#6-4-实战测试" class="headerlink" title="6.4 实战测试"></a>6.4 实战测试</h3><p>Docker Hub 中 99% 的镜像都是从这个基础镜像过来的：<code>FROM scratch</code>，然后配置需要的软件和配置 来进行的构建</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230429221635547.png"></p><blockquote><p>创建一个自己的 centos</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 1.编写Dockerfile的文件</span><br><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">MAINTAINER</span> yu&lt;<span class="hljs-number">952450841</span>@qq.com&gt;<br><br><span class="hljs-keyword">ENV</span> MYPATH /usr/local<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MYPATH</span></span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$MYPATH</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;----end----&quot;</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span><br><br><span class="hljs-comment"># 2.通过这个文件构建镜像</span><br><span class="hljs-comment"># 命令 docker build -f 文件路径 -t 镜像名:[tag] .</span><br>docker build -f mydockerfile-centos -t mycentos:<span class="hljs-number">0.1</span> .<br><br><span class="hljs-comment"># 成功后会显示如下信息：</span><br> =&gt; exporting to image                                                                                          <span class="hljs-number">3.2</span>s<br> =&gt; =&gt; exporting layers                                                                                         <span class="hljs-number">3.2</span>s<br> =&gt; =&gt; writing image sha256:<span class="hljs-number">27</span>a4dfc2485bddc6bef7b3b98e112398680f4fcd7224f5545b0e2d99487c5dfb                    <span class="hljs-number">0.0</span>s<br> =&gt; =&gt; naming to docker.io/library/mycentos:<span class="hljs-number">0.1</span>  <br><br><span class="hljs-comment"># 3、测试运行</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230429223156157.png"></p><p><strong>对比：</strong></p><p><strong>之前的原生的 centos</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230429223500600.png"></p><p><strong>我们自己制作的镜像</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230429223640835.png"></p><p>我们可以列出本地进行的变更历史</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230429223908389.png"></p><p>我们平时拿到一个镜像，就可以研究一下它是怎么做的了</p><blockquote><p>CMD 和 ENTRYPOINT 的区别</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。 <br>ENTRYPOINT  # 指定这个容器启动的时候要运行的命令，可以追加命令 <br></code></pre></td></tr></table></figure><p><strong>1. 测试CMD</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编写dockerfile文件</span><br>[root@MiWiFi-R4A-srv dockerfile]# vim dockerfile-cmd-test<br>FROM centos:7<br>CMD [&quot;ls&quot;,&quot;-a&quot;]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建镜像</span><br>[root@MiWiFi-R4A-srv dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行镜像 发现 <span class="hljs-built_in">ls</span> -a 命令生效了</span><br>[root@MiWiFi-R4A-srv dockerfile]# docker run d53776618e7c<br>.<br>..<br>.dockerenv<br>anaconda-post.log<br>bin<br>dev<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">想追加一个命令 -l 成为 <span class="hljs-built_in">ls</span> -al</span><br>[root@MiWiFi-R4A-srv dockerfile]# docker run d53776618e7c -l<br>docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.<br>ERRO[0000] error waiting for container:<br></code></pre></td></tr></table></figure><ul><li>错误原因：cmd 的情况下，<code>-l</code> 替换了 <code>CMD [&quot;ls&quot;,&quot;-a&quot;]</code>。而 <code>-l</code> 不是命令，所以会报错。</li><li>解决方案：写出完整的命令：<code>ls -al</code>。如下</li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230429224800096.png"></p><p><strong>2. 测试ENTRYPOINT</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编写dockerfile文件</span><br>[root@MiWiFi-R4A-srv dockerfile]# vim dockerfile-entrypoint-test<br>FROM centos:7<br>ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建镜像</span><br>[root@MiWiFi-R4A-srv dockerfile]# docker build -f dockerfile-entrypoint-test -t entrypoint-test:0.1 .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将命令-l直接添加在run的后面。会发现也能正常显示</span><br>[root@MiWiFi-R4A-srv dockerfile]# docker run 878051c15b29 -l<br>total 0<br>drwxr-xr-x.   1 root root   6 Apr 29 14:52 .<br>drwxr-xr-x.   1 root root   6 Apr 29 14:52 ..<br>-rwxr-xr-x.   1 root root   0 Apr 29 14:52 .dockerenv<br>lrwxrwxrwx.   1 root root   7 Nov  3  2020 bin -&gt; usr/bin<br>drwxr-xr-x.   5 root root 340 Apr 29 14:52 dev<br>drwxr-xr-x.   1 root root  66 Apr 29 14:52 etc<br>drwxr-xr-x.   2 root root   6 Nov  3  2020 home<br>lrwxrwxrwx.   1 root root   7 Nov  3  2020 lib -&gt; usr/lib<br>lrwxrwxrwx.   1 root root   9 Nov  3  2020 lib64 -&gt; usr/lib64<br>drwx------.   2 root root   6 Sep 15  2021 lost+found<br>drwxr-xr-x.   2 root root   6 Nov  3  2020 media<br>drwxr-xr-x.   2 root root   6 Nov  3  2020 mnt<br>drwxr-xr-x.   2 root root   6 Nov  3  2020 opt<br>dr-xr-xr-x. 140 root root   0 Apr 29 14:52 proc<br>dr-xr-x---.   2 root root 162 Sep 15  2021 root<br>drwxr-xr-x.  11 root root 163 Sep 15  2021 run<br>lrwxrwxrwx.   1 root root   8 Nov  3  2020 sbin -&gt; usr/sbin<br>drwxr-xr-x.   2 root root   6 Nov  3  2020 srv<br>dr-xr-xr-x.  13 root root   0 Apr 26 15:07 sys<br>drwxrwxrwt.   7 root root 171 Sep 15  2021 tmp<br>drwxr-xr-x.  12 root root 144 Sep 15  2021 usr<br>drwxr-xr-x.  20 root root 262 Sep 15  2021 var<br><br></code></pre></td></tr></table></figure><p>Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比它们然后测试效果</p><h3 id="6-5-实战：Tomcat镜像"><a href="#6-5-实战：Tomcat镜像" class="headerlink" title="6.5 实战：Tomcat镜像"></a>6.5 实战：Tomcat镜像</h3><ol><li><p>准备镜像文件</p><p>准备tomcat压缩包 和 jdk压缩包到当前目录，编写好README 。</p></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230429235638667.png"></p><ol start="2"><li><p>编写 dokerfile 文件，使用官方命名 <code>Dockerfile</code>。这样的话，build 时就会自动寻找这个文件，就不用加 -f 指定文件<img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230430000914710.png"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">MAINTAINER</span> yu&lt;<span class="hljs-number">952450841</span>@qq.com&gt;<br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> readme.txt /usr/local/readme.txt</span><br><br><span class="hljs-keyword">ADD</span><span class="language-bash"> apache-tomcat-9.0.74.tar.gz /usr/local/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> jdk-8u181-linux-x64.tar.gz /usr/local/</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim</span><br><br><span class="hljs-keyword">ENV</span> MYPATH /usr/local<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MYPATH</span></span><br><br><span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="hljs-number">8.0</span>_181<br><span class="hljs-keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br><span class="hljs-keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">74</span><br><span class="hljs-keyword">ENV</span> CATALINA_BASE /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">74</span><br><span class="hljs-keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin<br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /usr/local/apache-tomcat-9.0.74/bin/startup.sh &amp;&amp; <span class="hljs-built_in">tail</span> -F /url/local/apache-tomcat-9.0.74/bin/logs/catalina.out</span><br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t diytomcat:1.0 .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建成功</span><br><br> =&gt; exporting to image                                                                                          4.3s<br> =&gt; =&gt; exporting layers                                                                                         4.3s<br> =&gt; =&gt; writing image sha256:a0e7e27b3b2e663ad65aab69df1e43d31dae1cb70bd2a384fe0cd33ec983d14b                    0.0s<br> =&gt; =&gt; naming to docker.io/library/diytomcat:1.0   <br></code></pre></td></tr></table></figure></li><li><p>启动镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@MiWiFi-R4A-srv docker-tomcat]# docker run -d -p 9090:8080 --name yutomcat -v /home/dockerfile/docker-tomcat/test:/usr/local/apache-tomcat-9.0.74/webapps/test -v /home/dockerfile/docker-tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.74/logs diytomcat:1.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示容器ID</span><br>fc38aba8b1e73f3acd5827d30c5656fa67f8cb7d2f0ae1b95965426cdeaea994<br></code></pre></td></tr></table></figure><p>进入镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@MiWiFi-R4A-srv docker-tomcat]# docker exec -it fc38aba8b1e7 /bin/bash<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230430002420954.png"></p></li><li><p>访问测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">访问挂载出来的端口</span><br>[root@MiWiFi-R4A-srv docker-tomcat]# curl localhost:9090<br></code></pre></td></tr></table></figure><p>curl没问题</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230430002512164.png"></p><p>在外网查看</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230430002621510.png"></p></li><li><p>发布项目（由于做了卷挂载，我们直接在本地编写项目就可以发布了！）</p><p>进入我们挂载的宿主机目录，创建WEB-INF目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@MiWiFi-R4A-srv docker-tomcat]# cd test<br>[root@MiWiFi-R4A-srv test]# pwd<br>/home/dockerfile/docker-tomcat/test<br>[root@MiWiFi-R4A-srv test]# mkdir WEB-INF<br></code></pre></td></tr></table></figure><p>进入WEB-INF目录，创建web.xml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@MiWiFi-R4A-srv test]# cd WEB-INF/<br>[root@MiWiFi-R4A-srv WEB-INF]# vim web.xml<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.0&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span>&gt;</span><br>        <br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>退到上一级，创建index.jsp文件，WEB-INF文件夹和index.jsp同级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@MiWiFi-R4A-srv WEB-INF]# cd ..<br>[root@MiWiFi-R4A-srv test]# vim index.jsp<br></code></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>Hello World!&lt;br/&gt;<br>&lt;%<br>System.out.println(<span class="hljs-string">&quot;----my test web logs----&quot;</span>);<br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>访问成功！</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230430004234961.png"></p><p>查看日志：发现打印了日志，说明日志的目录也挂载成功了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@MiWiFi-R4A-srv docker-tomcat]# cd tomcatlogs/<br>[root@MiWiFi-R4A-srv tomcatlogs]# tail -f catalina.out<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230430004513679.png"></p><p>我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！</p></li></ol><h3 id="6-6-发布自己的镜像"><a href="#6-6-发布自己的镜像" class="headerlink" title="6.6 发布自己的镜像"></a>6.6 发布自己的镜像</h3><blockquote><p>把镜像发布到DockerHub</p></blockquote><ol><li><p>地址 <code>https://hub.docker.com/</code>，注册登录</p></li><li><p>确定这个账号可以登陆。</p></li><li><p>在我们服务器上提交自己的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@MiWiFi-R4A-srv tomcatlogs]# docker login --help<br><br>Usage:  docker login [OPTIONS] [SERVER]<br><br>Log in to a registry.<br>If no server is specified, the default is defined by the daemon.<br><br>Options:<br>  -p, --password string   Password<br>      --password-stdin    Take the password from stdin<br>  -u, --username string   Username<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@MiWiFi-R4A-srv tomcatlogs]# docker login -u xiaoyu0219<br>Password:<br>WARNING! Your password will be stored unencrypted in /root/.docker/config.json.<br>Configure a credential helper to remove this warning. See<br>https://docs.docker.com/engine/reference/commandline/login/#credentials-store<br><br>Login Succeeded<br></code></pre></td></tr></table></figure></li><li><p>提交镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先需要用tag命令，把镜像打个tag</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里要严格按照推送规范来：docker tag [imageID] 用户名/镜像名:版本号</span><br>[root@MiWiFi-R4A-srv tomcatlogs]# docker tag a0e7e27b3b2e xiaoyu0219/diytomcat:1.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送镜像的规范是：docker push 注册用户名/镜像名:版本号</span><br>[root@MiWiFi-R4A-srv tomcatlogs]# docker push xiaoyu0219/diytomcat:1.0<br><br>The push refers to repository [docker.io/xiaoyu0219/diytomcat]<br>5f70bf18a086: Pushing  1.024kB<br>9515394e7596: Pushing [=====================&gt;                             ]  110.2MB/259.4MB<br>44c0d4e884e0: Preparing<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后推送成功</span><br></code></pre></td></tr></table></figure><p><em>PS：阿里云容器镜像的推送参考官方</em></p></li></ol><h3 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240302484.png"></p><p>镜像打包（save）成为一个tar压缩包，可以发送压缩包给别人（load）。</p><h2 id="七、Docker网络"><a href="#七、Docker网络" class="headerlink" title="七、Docker网络"></a>七、Docker网络</h2><h3 id="7-1-理解Docker0"><a href="#7-1-理解Docker0" class="headerlink" title="7.1 理解Docker0"></a>7.1 理解Docker0</h3><p>清空所有环境，方便我们测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -f $(docker ps -aq)<br>docker rmi -f $(docker images -aq)<br></code></pre></td></tr></table></figure><p id=3>测试：三个网络</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505003033891.png"></p><p><strong>问题： docker 是如果处理容器网络访问的？</strong><a href="#2">回顾之前提出的问题</a></p><p>假设一个tomcat容器要访问mysql容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">测试 运行一个 tomcat</span><br>docker run -d -P --name tomcat01 tomcat:7.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看容器的内部网络地址（命令后追加 ip addr）</span><br>docker exec -it tomcat01 ip addr<br></code></pre></td></tr></table></figure><p>发现容器启动的时候 会得到一个<code>eth0@if59</code>的IP地址，这个地址是docker分配的</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505002211865.png"></p><p>思考： Linux 能不能ping通容器内部？– 可以</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505002241236.png"></p><blockquote><p>原理</p></blockquote><ol><li><p>我们每启动一个docker容器，docker就会给docker容器分配一个IP，我们只要安装了docker就会有一个网卡-docker0，（桥接模式），使用的技术是veth-pair技术！</p><p>第一次执行ip addr，<a href="#3">只有三个网卡</a>。</p><p>再次执行ip addr，发现多了一个网卡（刚刚启动的tomcat容器）。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505003128692.png"></p></li><li><p>再启动一个tomcat02，继续测试ip addr，发现又多了一对网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -P --name tomcat02 tomcat:7.0<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505003347923.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器查看内部地址</span><br>docker exec -it tomcat02 ip addr<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505003601861.png"></p><p>内部是 <strong>60</strong>: eth0@if<strong>61</strong></p><p>外部是 <strong>61</strong>: vethbde694b@if<strong>60</strong></p><p>所以是一对。</p><blockquote><p>我们发现这个容器带来网卡，都是一对对的。<br>veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连。<br>正因为有这个特性，利用 veth-pair 充当一个桥梁，连接各种虚拟网络设备的。<br>OpenStac，Docker容器之间的连接，OVS的连接，都是使用veth-pair技术。</p></blockquote></li><li><p>我们来测试下 tomcat01 和 tomcat02 是否可以ping通</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505004246689.png"></p></li></ol><p><strong>结论：容器和容器之间是可以 ping 通的</strong></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505004932984.png"></p><p>结论：tomcat01和tomcat02是共用的一个路由器—docker0</p><p>所有的容器不指定网络的情况下，都是 docker0 路由的，docker会给我们的容器分配一个默认的可用 ip</p><blockquote><p>小结</p></blockquote><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230505005954501.png"></p><p>Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）</p><p>只要容器删除，对应的一对网桥就没了！</p><h3 id="7-2-–link"><a href="#7-2-–link" class="headerlink" title="7.2 –link"></a>7.2 –link</h3><blockquote><p>思考一个场景：我们编写了一个微服务，访问数据库MySQL，但容器分配的数据库ip换掉了，database url&#x3D;ip: 如何做到项目不重启，但是数据ip换了，我们希望可以处理这个问题。也就是可以通过名字来进行访问容器。</p><p>如果做到这个，就可以实现高可用了！</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动两个tomcat容器 tomcat01和tomcat02</span><br>docker run -d -P --name tomcat01 tomcat:7.0<br>docker run -d -P --name tomcat02 tomcat:7.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">让tomcat02 ping tomcat01</span><br>docker exec -it tomcat02 ping tomcat01<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506001400534.png"></p><p>发现ping不通，如何可以解决呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动tomcat03，让其和tomcat02使用 --<span class="hljs-built_in">link</span> 连通</span><br>docker run -d -P --name tomcat03 --link tomcat02 tomcat:7.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再使用 tomcat03 去 ping tomcat02</span><br>docker exec -it tomcat03 ping tomcat02<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506001527341.png"></p><p>发现可以连通。</p><p>反向可以连通吗？使用tomcat02 ping tomcat03</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@MiWiFi-R4A-srv ~]# docker exec -it tomcat02 ping tomcat03<br>ping: tomcat03: No address associated with hostname<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发现并不可以ping通</span><br></code></pre></td></tr></table></figure><p><strong>探究：inspect命令</strong></p><p>原理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看tomcat03的 /etc/hosts 文件</span><br>docker exec -it tomcat03 cat /etc/hosts<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506002754526.png"></p><p>本质探究：–link就是我们在hosts配置中增加了一个 172.18.0.3 tomcat02，而tomcat02中的hosts文件没有（可以后续手动添加）。</p><p>也就是在hosts中增加了一层映射</p><p>现在使用Docker已经不建议使用–link了！</p><p>自定义网络，不适用docker0！</p><p>docker0问题：不支持容器名连接访问</p><h3 id="7-3-自定义网络"><a href="#7-3-自定义网络" class="headerlink" title="7.3 自定义网络"></a>7.3 自定义网络</h3><blockquote><p>查看所有的docker网络：docker netework ls</p></blockquote><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506003028687.png"></p><blockquote><p>网络模式</p></blockquote><ul><li>bridge ：桥接 docker（默认，我们自己也是用bridge模式）</li><li>none ：不配置网络，一般不用</li><li>host ：和宿主机共享网络</li><li>container ：容器网络连通（用得少！局限很大）</li></ul><blockquote><p>测试</p></blockquote><p>清空所有的环境：docker rm -f $(docker ps -aq)</p><p>让我们的虚拟机只有原来的三个网络</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506003611758.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">我们直接启动的命令 --net bridge,而这个就是我们的docker0</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">bridge就是docker0</span> <br>docker run -d -P --name tomcat01 tomcat:7.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">相当于↓</span><br>docker run -d -P --name tomcat01 --net bridge tomcat:7.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker0，特点：默认，域名不能访问。 --<span class="hljs-built_in">link</span>可以打通连接，但是很麻烦！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们可以 自定义一个网络</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">subnet 是子网，gateway 是路由，mynet是网络的名称，16代表最多支持IP范围 192.168.00 ~ 192.168.255.255</span><br>docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看网络</span><br>docker network ls<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506004127804.png"></p><p>这个就是我们创建的自定义网络：docker network inspect mynet</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506004434484.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">再次使用我们自定义的网络创建两个tomcat</span><br>docker run -d -P --name tomcat-net-01 --net mynet tomcat:7.0<br>docker run -d -P --name tomcat-net-02 --net mynet tomcat:7.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看网络状态</span><br>docker network inspect mynet<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506004926928.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">再次测试ping连接</span><br>docker exec -it tomcat-net-01 ping 192.168.0.3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">二者等价↓ 不再需要--<span class="hljs-built_in">link</span></span><br>docker exec -it tomcat-net-01 ping tomcat-net-02<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506005131601.png"></p><p>我们自定义的网络docker帮我们维护好了对应的关系，推荐我们平时这样使用网络！</p><p><strong>好处：</strong></p><p>redis - 不同的集群使用不同的网络，保证集群是安全和健康的</p><p>mysql - 不同的集群使用不同的网络，保证集群是安全和健康的</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506005503051.png"></p><h3 id="7-4-网络连通"><a href="#7-4-网络连通" class="headerlink" title="7.4 网络连通"></a>7.4 网络连通</h3><p>我们现在的情况是这样的：</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506010035376.png"></p><p><code>tomcat01</code> 可以ping通<code>tomcat-net-01</code> 吗？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">基于上一小节的内容，再在docker0网络中启动两个tomcat</span><br>docker run -d -P --name tomcat01 tomcat:7.0<br>docker run -d -P --name tomcat02 tomcat:7.0<br></code></pre></td></tr></table></figure><p>查看现在所有的容器，docker0和mynet中各有两个tomcat容器</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506010229220.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">用docker0中的tomcat01 去ping mynet中的tomcat-net-01</span><br>docker exec -it tomcat01 ping tomcat-net-01<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506010337301.png"></p><p>发现不通</p><blockquote><p>测试：打通 tomcat01 到 mynet</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 connect 命令，打通网络</span><br>docker network connect mynet tomcat01<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看mynet网络情况</span><br>docker network inspect mynet<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506010729703.png"></p><p>连通之后，将docker0中的tomcat01 和 mynet网络打通，直接放到了mynet网络下。</p><p>官方的名称就叫做：一个容器，两个IP地址。</p><p>例如：阿里云服务器的公网IP和私网IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">再次测试 tomcat01 ping tomcat-net-01</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506011012030.png"></p><p>网络打通了，但由于tomcat02并没有打通mynet，所以tomcat02依旧是不行的</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506011052390.png"></p><p><strong>结论：假设要跨网络操作别人，就需要使用docker network connect 连通！</strong></p><h3 id="7-5-实战：部署Redis集群"><a href="#7-5-实战：部署Redis集群" class="headerlink" title="7.5 实战：部署Redis集群"></a>7.5 实战：部署Redis集群</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506014100764.png"></p><p>清空所有的环境：docker rm -f $(docker ps -aq)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 redis docker网络</span><br>docker network create redis --subnet 172.38.0.0/16<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为6个redis创建配置文件（直接在命令行键入以下内容即可）</span><br>for port in $(seq 1 6); \<br>do \<br>mkdir -p /mydata/redis/node-$&#123;port&#125;/conf<br>touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf<br>cat &lt;&lt; EOF &gt; /mydata/redis/node-$&#123;port&#125;/conf/redis.conf<br>port 6379<br>bind 0.0.0.0<br>cluster-enabled yes<br>cluster-config-file nodes.conf<br>cluster-node-timeout 5000<br>cluster-announce-ip 172.38.0.1$&#123;port&#125;<br>cluster-announce-port 6379<br>cluster-announce-bus-port 16379<br>appendonly yes<br>EOF<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入 /mydata/redis 路径可以看见6个节点，在6个节点下，分别有每个节点自己的redis配置</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506011955593.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过脚本运行6个redis（直接在命令行键入以下内容即可）</span><br>for port in $(seq 1 6); \<br>do \<br>docker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \<br>-v /mydata/redis/node-$&#123;port&#125;/data:/data \<br>-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \<br>-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入其中一个容器</span><br>docker exec -it redis-1 /bin/sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在容器内执行创建集群命令</span><br>redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506012649960.png"></p><p>集群配置完毕</p><blockquote><p>测试</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建集群完毕后，在redis-1中，开启redis交互</span><br>redis-cli -c<br></code></pre></td></tr></table></figure><p><strong>查看集群信息：cluster info</strong></p><p>集群数量为3</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506013454345.png"></p><p><strong>查看节点状态：cluster nodes</strong></p><p>全部节点都是健康的，三个master，三个slave</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506013531664.png"></p><p><strong>执行命令：set a b</strong></p><p>kv被存放在了13节点上，也就是redis-3上</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506013631883.png"></p><p><strong>停止容器 redis-3：docker stop redis-3</strong></p><p><strong>执行命令：get a</strong></p><p>在14上发现了key a的值</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506013811037.png"></p><p><strong>再次查看节点状态：cluster nodes</strong></p><p>13容器宕机了，节点发生了故障转移。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230506013856589.png"></p><h2 id="八、Docker整合"><a href="#八、Docker整合" class="headerlink" title="八、Docker整合"></a>八、Docker整合</h2><h3 id="8-1-SpringBoot微服务打包Docker镜像"><a href="#8-1-SpringBoot微服务打包Docker镜像" class="headerlink" title="8.1 SpringBoot微服务打包Docker镜像"></a>8.1 SpringBoot微服务打包Docker镜像</h3><ol><li><p>准备好一个springboot项目：myfavorites-0.0.1-SNAPSHOT.jar，拷贝到linux中。</p></li><li><p>在同级文件夹下，创建dockerfile文件</p><p>vim Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> myfavorites-0.0.1-SNAPSHOT.jar springboot.jar</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/springboot.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>保存并退出。</p><blockquote><p>FROM：表示基础镜像，即运行环境</p><p>VOLUME：&#x2F;tmp创建&#x2F;tmp目录并持久化到Docker数据文件及，因为SpringBoot使用的内嵌Tomcat容器默认使用&#x2F;Tmp作为工作目录</p><p>ADD：拷贝文件并且重命名（ADD myfavorites-0.0.1-SNAPSHOT.jar springboot.jar 将应用jar包复制到&#x2F;springboot.jar）</p><p>EXPOSE：并不是真正的发布端口，这个只是容器部署人员与监理image的人员之间的交流，即监理image的人员告诉容器部署人员容器应该映射哪个端口给外界</p><p>ENTRYPOINT：容器启动时运行的命令，相当于我们在命令行中输入 java -jar xxx.jar</p></blockquote></li><li><p>构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t springboot .<br></code></pre></td></tr></table></figure></li><li><p>完成容器的创建</p><p>上一步结束后，docker images 就可以发现 该镜像，基于该镜像，完成容器的创建。</p><p>把所有容器全部停掉：docker stop $(docker ps -a -q)</p><p>运行容器（这里可以运行两个，暴露不同的端口号）：</p><p>docker run -d –name springboot-8080 -p 8080:8080 –rm springboot</p><p>docker run -d –name springboot-8081 -p 8081:8080 –rm springboot</p></li><li><p>访问页面</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230519013039430.png"></p></li></ol><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230519013205117.png"></p><p>8080和8081都能访问成功。</p><h3 id="8-2-IDEA集成Docker实现镜像打包一键部署"><a href="#8-2-IDEA集成Docker实现镜像打包一键部署" class="headerlink" title="8.2 IDEA集成Docker实现镜像打包一键部署"></a>8.2 IDEA集成Docker实现镜像打包一键部署</h3><p>Idea集成docker实现镜像打包一键部署</p><h4 id="1）Docker开启远程访问"><a href="#1）Docker开启远程访问" class="headerlink" title="1）Docker开启远程访问"></a>1）Docker开启远程访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">修改该Docker服务文件</span><br>vi /lib/systemd/system/docker.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改ExecStart这行</span><br>ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock<br></code></pre></td></tr></table></figure><blockquote><p>将文件内的 ExecStart注释。 新增如上行。<br>#ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H fd:&#x2F;&#x2F; –containerd&#x3D;&#x2F;run&#x2F;containerd&#x2F;containerd.sock ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H tcp:&#x2F;&#x2F;0.0.0.0:2375-H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">重新加载配置文件</span><br>systemctl daemon-reload<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启服务</span><br>systemctl restart docker.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看端口是否开启</span><br>netstat -nlpt #如果找不到netstat命令，可进行安装。yum install net-tools<br><span class="hljs-meta prompt_">#</span><span class="language-bash">直接curl看是否生效</span><br>curl http://127.0.0.1:2375/info<br></code></pre></td></tr></table></figure><h4 id="2）IDEA安装Docker插件"><a href="#2）IDEA安装Docker插件" class="headerlink" title="2）IDEA安装Docker插件"></a>2）IDEA安装Docker插件</h4><blockquote><p>打开Idea，从File-&gt;Settings-&gt;Plugins-&gt;Install JetBrains plugin进入插件安装界面，</p><p>在搜索框中输入docker，可以看到Docker integration，点击右边的Install按钮进行安装。</p><p>安装后重启Idea。</p></blockquote><h4 id="3）IDEA配置docker"><a href="#3）IDEA配置docker" class="headerlink" title="3）IDEA配置docker"></a>3）IDEA配置docker</h4><p>配置docker，连接到远程docker服务。</p><p>从File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Docker打开配置界面</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230519015408579.png"></p><p>开放防火墙端口命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看已经开放的端口</span><br>firewall-cmd --list-ports<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开放 2375</span><br>firewall-cmd --zone=public --add-port=2375/tcp --permanent<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启防火墙</span><br>firewall-cmd --reload<br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看 2375 是否已经开放</span><br>firewall-cmd --list-ports<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230519015610707.png"></p><p>对着镜像右键，进行create创建容器操作</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230519020103781.png"></p><p>启动后，再次访问测试接口</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230519020300382.png"></p><h4 id="4）docker-maven-plugin"><a href="#4）docker-maven-plugin" class="headerlink" title="4）docker-maven-plugin"></a>4）docker-maven-plugin</h4><p>传统过程中，打包、部署、等。</p><p>而在持续集成过程中，项目工程一般使用 Maven 编译打包，然后生成镜像，通过镜像上线，能够大大提供上线效率，同时能够快速动态扩容，快速回滚，着实很方便。docker-maven-plugin 插件就是为了帮助我们在Maven工程中，通过简单的配置，自动生成镜像并推送到仓库中。</p><p><strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">docker.image.prefix</span>&gt;</span>guoweixin<span class="hljs-tag">&lt;/<span class="hljs-name">docker.image.prefix</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 镜像名称 guoweixin/exam--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--指定标签--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">imageTags</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">imageTag</span>&gt;</span>latest<span class="hljs-tag">&lt;/<span class="hljs-name">imageTag</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">imageTags</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 基础镜像jdk 1.8--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">baseImage</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">baseImage</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 制作者提供本人信息 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span>&gt;</span>guoweixin guoweixin@aliyun.com<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--切换到/ROOT目录 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">workdir</span>&gt;</span>/ROOT<span class="hljs-tag">&lt;/<span class="hljs-name">workdir</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">cmd</span>&gt;</span>[&quot;java&quot;, &quot;-version&quot;]<span class="hljs-tag">&lt;/<span class="hljs-name">cmd</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entryPoint</span>&gt;</span>[&quot;java&quot;, &quot;-jar&quot;, &quot;$&#123;project.build.finalName&#125;.jar&quot;]<span class="hljs-tag">&lt;/<span class="hljs-name">entryPoint</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 指定 Dockerfile 路径</span><br><span class="hljs-comment">&lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt;</span><br><span class="hljs-comment">--&gt;</span><br>                <span class="hljs-comment">&lt;!--指定远程 docker api地址--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dockerHost</span>&gt;</span>http://192.168.20.135:2375<span class="hljs-tag">&lt;/<span class="hljs-name">dockerHost</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 这里是复制 jar 包到 docker 容器指定目录配置 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/ROOT<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--用于指定需要复制的根目录，$&#123;project.build.directory&#125;表示target目录--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--用于指定需要复制的文件。$&#123;project.build.finalName&#125;.jar指的是打包后的jar包文件。--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Dockerfile</strong></p><p>如上用docker-maven插件 自动生成如下文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java<br><span class="hljs-keyword">MAINTAINER</span> guoweixin guoweixin@aliyun.com<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /ROOT</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> /ROOT/qfnj-0.0.1-SNAPSHOT.jar /ROOT/</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;qfnj-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-version&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="5）执行命令"><a href="#5）执行命令" class="headerlink" title="5）执行命令"></a>5）执行命令</h4><p>对项目进行 打包。并构建镜像 到Docker 上。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mvn clean package docker:build<br></code></pre></td></tr></table></figure><h4 id="6）IDEA操作Docker"><a href="#6）IDEA操作Docker" class="headerlink" title="6）IDEA操作Docker"></a>6）IDEA操作Docker</h4><h4 id="7）扩展配置"><a href="#7）扩展配置" class="headerlink" title="7）扩展配置"></a>7）扩展配置</h4><p>绑定Docker 命令到 Maven 各个阶段</p><blockquote><p>我们可以绑定 Docker 命令到 Maven 各个阶段。</p><p>我们可以把 Docker 分为 build、tag、push，然后分别绑定 Maven 的 package、deploy 阶段。</p><p>我们只需要执行 mvn deploy 就可以完成整个 build、tag、push操作了，当我们执行 mvn build 就只完成build、tag 操作。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--当执行mvn package 时，执行： mvn clean package docker:build --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--当执行mvn package 时，会对镜像进行 标签设定--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>tag-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>tag<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:latest<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">newName</span>&gt;</span>docker.io/$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">newName</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>push-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>deploy<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>push<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>docker.io/$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br></code></pre></td></tr></table></figure><p>总结：</p><p>当我们执行 <code>mvn package</code> 时，执行 build、tag 操作，</p><p>当执行 <code>mvn deploy</code> 时，执行build、tag、push 操作。</p><p>如果我们想跳过 docker 某个过程时，只需要：</p><ul><li><code>-DskipDockerBuild</code> 跳过 build 镜像</li><li><code>-DskipDockerTag</code> 跳过 tag 镜像</li><li><code>-DskipDockerPush</code> 跳过 push 镜像</li><li><code>-DskipDocker</code> 跳过整个阶段</li></ul><p>例如：我们想执行 package 时，跳过 tag 过程，那么就需要 <code>mvn package -DskipDockerTag</code></p><h3 id="8-3-Idea整合Docker-CA加密认证"><a href="#8-3-Idea整合Docker-CA加密认证" class="headerlink" title="8.3 Idea整合Docker CA加密认证"></a>8.3 Idea整合Docker CA加密认证</h3><p>前面提到的配置是允许所有人都可以访问的，因为docker默认是root权限的，把2375端口暴露在外面，意味着别人随时都可以提取到你服务器的root权限，是很容易被黑客黑的，因此,docker官方推荐使用加密的tcp连接，以Https的方式与客户端建立连接。</p><p>官方示例Demo：</p><p><a href="https://docs.docker.com/engine/security/https/#create-a-ca-server-and-client-keys-with-openssl">https://docs.docker.com/engine/security/https/#create-a-ca-server-and-client-keys-with-openssl</a></p><h4 id="Docker认证命令配置"><a href="#Docker认证命令配置" class="headerlink" title="Docker认证命令配置"></a>Docker认证命令配置</h4><h5 id="1）创建ca文件夹，存放CA私钥和公钥"><a href="#1）创建ca文件夹，存放CA私钥和公钥" class="headerlink" title="1）创建ca文件夹，存放CA私钥和公钥"></a>1）创建ca文件夹，存放CA私钥和公钥</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /usr/local/ca <br>cd /usr/local/ca/<br></code></pre></td></tr></table></figure><h5 id="2）生成CA私钥和公钥"><a href="#2）生成CA私钥和公钥" class="headerlink" title="2）生成CA私钥和公钥"></a>2）生成CA私钥和公钥</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -aes256 -out ca-key.pem 4096<br></code></pre></td></tr></table></figure><p>输入密码时，输入两次相同的密码，并且后面会用到。</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230522025233486.png"></p><h5 id="3）依次输入密码、国家、省、市、组织名称、邮箱等"><a href="#3）依次输入密码、国家、省、市、组织名称、邮箱等" class="headerlink" title="3）依次输入密码、国家、省、市、组织名称、邮箱等"></a>3）依次输入密码、国家、省、市、组织名称、邮箱等</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230522024709823.png"></p><p>现在已经有了CA，接下来创建一个服务器密钥和证书签名请求(CSR)。确保“公用名”与你用来连接到Docker的主机名匹配。</p><h5 id="4）生成server-key-pem"><a href="#4）生成server-key-pem" class="headerlink" title="4）生成server-key.pem"></a>4）生成server-key.pem</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out server-key.pem 4096<br></code></pre></td></tr></table></figure><h5 id="5）CA来签署公钥"><a href="#5）CA来签署公钥" class="headerlink" title="5）CA来签署公钥"></a>5）CA来签署公钥</h5><p>由于TLS连接可以通过IP地址和DNS名称进行，所以在创建证书时需要指定IP地址。例如，允许使用10.10.10.20 和127.0.0.1进行连接: ]</p><p>$Host换成你自己服务器外网的IP或者域名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -subj &quot;/CN=$HOST&quot; -sha256 -new -key server-key.pem -out server.csr<br> 比如<br>openssl req -subj &quot;/CN=192.168.20.135&quot; -sha256 -new -key server-key.pem -out server.csr <br> 或<br>openssl req -subj &quot;/CN=www.javaqf.com&quot; -sha256 -new -key server-key.pem -out server.csr<br></code></pre></td></tr></table></figure><p>本地是局域网： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -subj &quot;/CN=192.168.31.212&quot; -sha256 -new -key server-key.pem -out server.csr<br></code></pre></td></tr></table></figure><h5 id="6）配置白名单"><a href="#6）配置白名单" class="headerlink" title="6）配置白名单"></a>6）配置白名单</h5><p>1 允许指定ip可以连接到服务器的docker，可以配置ip，用逗号分隔开。</p><p>2 因为已经是ssl连接，所以我推荐配置0.0.0.0,也就是所有ip都可以连接(但只有拥有证书的才可以连接成功)，这样配置好之后公司其他人也可以使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">如果填写的是ip地址 命令如下 echo subjectAltName = IP:$HOST,IP:0.0.0.0 &gt;&gt; extfile.cnf <br>如果填写的是域名 命令如下 echo subjectAltName = DNS:$HOST,IP:0.0.0.0 &gt;&gt; extfile.cnf<br></code></pre></td></tr></table></figure><p>上面的$Host依旧是你服务器外网的IP或者域名，请自行替换。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> subjectAltName = IP:<span class="hljs-number">192.168.31.212</span>,IP:<span class="hljs-number">0.0.0.0</span> &gt;&gt; extfile.cnf<br></code></pre></td></tr></table></figure><h5 id="7）执行命令"><a href="#7）执行命令" class="headerlink" title="7）执行命令"></a>7）执行命令</h5><p>将Docker守护程序密钥的扩展使用属性设置为仅用于服务器身份验证:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf<br></code></pre></td></tr></table></figure><h5 id="8）生成签名证书"><a href="#8）生成签名证书" class="headerlink" title="8）生成签名证书"></a>8）生成签名证书</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem \<br>-CAcreateserial -out server-cert.pem -extfile extfile.cnf<br></code></pre></td></tr></table></figure><h5 id="9）生成客户端的key-pem"><a href="#9）生成客户端的key-pem" class="headerlink" title="9）生成客户端的key.pem"></a>9）生成客户端的key.pem</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out key.pem 4096 <br>openssl req -subj &#x27;/CN=client&#x27; -new -key key.pem -out client.csr<br></code></pre></td></tr></table></figure><h5 id="10）要使密钥适合客户端身份验证"><a href="#10）要使密钥适合客户端身份验证" class="headerlink" title="10）要使密钥适合客户端身份验证"></a>10）要使密钥适合客户端身份验证</h5><p>创建扩展配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf <br>echo extendedKeyUsage = clientAuth &gt; extfile-client.cnf<br></code></pre></td></tr></table></figure><h5 id="11）现在，生成签名证书"><a href="#11）现在，生成签名证书" class="headerlink" title="11）现在，生成签名证书"></a>11）现在，生成签名证书</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem \<br>-CAcreateserial -out cert.pem -extfile extfile-client.cnf<br></code></pre></td></tr></table></figure><p>生成cert.pem,需要输入前面设置的密码</p><h5 id="12）删除不需要的文件，两个证书签名请求"><a href="#12）删除不需要的文件，两个证书签名请求" class="headerlink" title="12）删除不需要的文件，两个证书签名请求"></a>12）删除不需要的文件，两个证书签名请求</h5><p>生成cert.pem和server-cert之后。您可以安全地删除两个证书签名请求和扩展配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -v client.csr server.csr extfile.cnf extfile-client.cnf<br></code></pre></td></tr></table></figure><h5 id="13）可修改权限"><a href="#13）可修改权限" class="headerlink" title="13）可修改权限"></a>13）可修改权限</h5><p>要保护您的密钥免受意外损坏，请删除其写入权限。要使它们只能被您读取，更改文件模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod -v 0400 ca-key.pem key.pem server-key.pem<br></code></pre></td></tr></table></figure><p>证书可以是对外可读的，删除写入权限以防止意外损坏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod -v 0444 ca.pem server-cert.pem cert.pem<br></code></pre></td></tr></table></figure><h5 id="14）归集服务器证书"><a href="#14）归集服务器证书" class="headerlink" title="14）归集服务器证书"></a>14）归集服务器证书</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp server-*.pem /etc/docker/ <br>cp ca.pem /etc/docker/<br></code></pre></td></tr></table></figure><h5 id="15）修改Docker配置"><a href="#15）修改Docker配置" class="headerlink" title="15）修改Docker配置"></a>15）修改Docker配置</h5><p>使Docker守护程序仅接受来自提供CA信任的证书的客户端的连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /lib/systemd/system/docker.service <br>将<br>ExecStart=/usr/bin/dockerd <br>替换为： <br>ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/usr/local/ca/ca.pem --tlscert=/usr/local/ca/server-cert.pem --tlskey=/usr/local/ca/server-key.pem -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock<br></code></pre></td></tr></table></figure><h5 id="16）重新加载daemon并重启docker"><a href="#16）重新加载daemon并重启docker" class="headerlink" title="16）重新加载daemon并重启docker"></a>16）重新加载daemon并重启docker</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload <br>systemctl restart docker<br></code></pre></td></tr></table></figure><h5 id="17）开放2375端口"><a href="#17）开放2375端口" class="headerlink" title="17）开放2375端口"></a>17）开放2375端口</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/sbin/iptables -I INPUT -p tcp --dport 2375 -j ACCEPT<br></code></pre></td></tr></table></figure><h5 id="18）重启docker"><a href="#18）重启docker" class="headerlink" title="18）重启docker"></a>18）重启docker</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure><h4 id="IDEA操作Docker"><a href="#IDEA操作Docker" class="headerlink" title="IDEA操作Docker"></a>IDEA操作Docker</h4><h5 id="1）保存相关客户端的pem文件到本地"><a href="#1）保存相关客户端的pem文件到本地" class="headerlink" title="1）保存相关客户端的pem文件到本地"></a>1）保存相关客户端的pem文件到本地</h5><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230522030158213.png"></p><p>2）IDEA CA配置</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230522030617839.png"></p><p>PS：如果配置package一键部署，需要把pom中的http改为https</p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20230522030736946.png" alt="image-20230522030736946"></p><h2 id="九、Docker-Compose"><a href="#九、Docker-Compose" class="headerlink" title="九、Docker Compose"></a>九、Docker Compose</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h3><p>前面我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run -d –name -p等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知</p><p><strong>使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具</strong></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p><code>Docker Compose</code> 是 Docker 官方编排（Orchestration）项目之一，<strong>负责快速的部署分布式应用</strong>。</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code>中的 <code>Heat</code> 十分类似。</p><p>其代码目前在 <a href="https://github.com/docker/compose">https://github.com/docker/compose</a> 上开源。</p><p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p><p>通过第一部分中的介绍，我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p><code>Compose</code> 中有两个重要的概念：</p><ul><li>服务 ( <code>service</code> )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 ( <code>project</code> )：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li></ul><p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p><h3 id="Docker-Compose使用"><a href="#Docker-Compose使用" class="headerlink" title="Docker Compose使用"></a>Docker Compose使用</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><blockquote><p>首先介绍几个术语。</p><ul><li>服务 ( service )：一个应用容器，实际上可以运行多个相同镜像的实例。</li><li>项目 ( project )：由一组关联的应用容器组成的一个完整业务单元。</li></ul><p>可见，一个项目可以由多个服务（容器）关联而成， Compose 面向项目进行管理。</p></blockquote><h4 id="Docker-compose创建容器"><a href="#Docker-compose创建容器" class="headerlink" title="Docker-compose创建容器"></a>Docker-compose创建容器</h4><blockquote><p>通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p></blockquote><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p><strong>用compose的方式创建3个springboot服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">1 管理文件夹，创建相应的目录</span><br>[root@MiWiFi-R4A-srv ~]# mkdir -p /opt/docker-boot-cluster<br>[root@MiWiFi-R4A-srv ~]# cd /opt/docker-boot-cluster/<br></code></pre></td></tr></table></figure><p>#2 在如上目录中 编写创建 <code>docker-compose.yml</code>配置文件</p><p>编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">boot-8080:</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">yu/myfavorites</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">boot-8080</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span><br>  <span class="hljs-attr">boot-8081:</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">yu/myfavorites</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">boot-8081</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8081</span><span class="hljs-string">:8080</span><br>  <span class="hljs-attr">boot-8082:</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">yu/myfavorites</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">boot-8082</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8082</span><span class="hljs-string">:8080</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">3 启动(执行命令创建容器)</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>#默认执行的文件名：docker-compose.yml(且需要在当前上下文路径中) 。如果说文件名不是默认的需要使用下面的指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose -f 文件名.后缀名 up –d<br></code></pre></td></tr></table></figure><h5 id="测试："><a href="#测试：" class="headerlink" title="测试："></a><strong>测试：</strong></h5><p>分别访问8080，8081，8082端口的接口，调用成功。</p><h4 id="Docker-compose-常用命令"><a href="#Docker-compose-常用命令" class="headerlink" title="Docker-compose 常用命令"></a>Docker-compose 常用命令</h4><blockquote><p>build 构建或重建服务<br>help 命令帮助<br>kill 杀掉容器<br>logs 显示容器的输出内容<br>port 打印绑定的开放端口<br>ps 显示容器<br>pull 拉取服务镜像<br>restart 重启服务<br>rm 删除停止的容器<br>run 运行一个一次性命令<br>scale 设置服务的容器数目<br>start 开启服务<br>stop 停止服务<br>up 创建并启动容器<br>down</p></blockquote><h4 id="常用命令示例："><a href="#常用命令示例：" class="headerlink" title="常用命令示例："></a>常用命令示例：</h4><blockquote><p>docker-compose up -d nginx 构建启动nignx容器<br>docker-compose exec nginx bash 登录到nginx容器中<br>docker-compose down 删除所有nginx容器,镜像<br>docker-compose ps 显示所有容器<br>docker-compose restart nginx 重新启动nginx容器<br>docker-compose run –no-deps –rm php-fpm php -v 在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器<br>docker-compose build nginx 构建镜像 。<br>docker-compose build –no-cache nginx 不带缓存的构建。<br>docker-compose logs nginx 查看nginx的日志<br>docker-compose logs -f nginx 查看nginx的实时日志<br>docker-compose config -q 验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息。<br>docker-compose events –json nginx 以json的形式输出nginx的docker日志<br>docker-compose pause nginx 暂停nignx容器<br>docker-compose unpause nginx 恢复ningx容器<br>docker-compose rm nginx 删除容器（删除前必须关闭容器）<br>docker-compose stop nginx 停止nignx容器<br>docker-compose start nginx 启动nignx容器</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2020/10/06/redis/"/>
    <url>/2020/10/06/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="一、Redis介绍"><a href="#一、Redis介绍" class="headerlink" title="一、Redis介绍"></a>一、Redis介绍</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><p><strong>1. 由于用户量增大，请求数量也随之增大，数据压力过大。</strong></p><p><strong>例</strong>：数据库根据SQL语句去磁盘通过io来拿到数据，数据压力就会比较大，轻则查询效率降低，重则服务器宕机。</p><p><strong>解决</strong>：针对热点数据添加缓存，把数据放到Redis，查询都找Redis。</p><p><strong>原理</strong>：Redis是基于内存存储数据和读取数据的，并且支持并发量很大。</p><p><strong>2. 多台服务器之间，数据不同步。</strong></p><p><strong>例</strong>：客户端发送请求，说不定请求会发到哪台服务器中，比如客户在登录中，在服务器1存放了客户的唯一标识，下一次如果请求发送到服务器2，就没有标识了。</p><p><strong>解决</strong>：不用Session来存放用户数据，用Redis统一存放。</p><p><strong>原理</strong>：Redis是独立于Tomcat服务器之外的单独中间件，可以将之前存储在Session中的共享数据统一的存放在Redis中，服务器1和服务器2都找Redis。</p><p><strong>3. 多台服务器之间的锁，已经不存在互斥性了。</strong></p><p><strong>例</strong>：在服务器1使用锁操作，和在服务器2使用锁操作，两把锁不存在互斥性，会导致锁失效。</p><p><strong>解决</strong>：使用Redis</p><p><strong>原理</strong>：Redis基于它接收用户的请求是单线程的，可以帮我们实现类似锁的功能。</p><h3 id="1-2-NoSQL"><a href="#1-2-NoSQL" class="headerlink" title="1.2 NoSQL"></a>1.2 NoSQL</h3><p>Redis就是一款NoSQL</p><p>NoSQL -&gt; 菲关系型数据库 -&gt; Not Only SQL</p><p>除了关系型数据库都是非关系型数据库。</p><p>NoSQL只是一种概念，泛指非关系型数据库，和关系型数据库做一个区分。</p><h3 id="1-3-Redis介绍"><a href="#1-3-Redis介绍" class="headerlink" title="1.3 Redis介绍"></a>1.3 Redis介绍</h3><p>Redis（Remote Dictionary Server）远程字典服务，由C语言去编写，所以不需要java环境。</p><h2 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h2><h3 id="2-1-下载中文版Redis可视化软件"><a href="#2-1-下载中文版Redis可视化软件" class="headerlink" title="2.1 下载中文版Redis可视化软件"></a>2.1 下载中文版Redis可视化软件</h3><p><font size=5 color=orange>RedisDesktopManager</font></p><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240223404.png"></p><h3 id="2-2-为Redis赋值"><a href="#2-2-为Redis赋值" class="headerlink" title="2.2 为Redis赋值"></a>2.2 为Redis赋值</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240224063.png"></p><h3 id="2-3-在Redis中查看"><a href="#2-3-在Redis中查看" class="headerlink" title="2.3 在Redis中查看"></a>2.3 在Redis中查看</h3><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240248957.png"></p><h2 id="三、Redis常用命令"><a href="#三、Redis常用命令" class="headerlink" title="三、Redis常用命令"></a>三、Redis常用命令</h2><blockquote><p>官网Redis命令参考文档：redisdoc.com</p></blockquote><h3 id="3-1-Redis存储数据的结构"><a href="#3-1-Redis存储数据的结构" class="headerlink" title="3.1 Redis存储数据的结构"></a>3.1 Redis存储数据的结构</h3><p>常用的五种数据结构</p><ul><li><p><strong>key-string</strong>：一个key对应一个值</p></li><li><p><strong>key-hash</strong>：一个key对应一个Map</p></li><li><p><strong>key-list</strong>：一个key对应一个列表</p></li><li><p><strong>key-set</strong>：一个key对应一个集合</p></li><li><p><strong>key-zset</strong>：一个key对应一个有序的集合</p><p><em>另外三种数据结构。</em></p><p>HyperLogLog：计算近似值的。</p><p>GEO：存储地理位置（经纬度）</p><p>BIT：一般存储的也是一个字符串，存储的是一个byte[]</p></li></ul><p><img src="https://raw.githubusercontent.com/yu980219/image-host/master/hexo/202411240248212.png"></p><p>应用：</p><p>key-string：最常用的，一般用于存储一个值</p><p>key-hash：存储一个对象数据的</p><p>key-list：使用list结构实现栈和队列结构</p><p>key-set：交集，差集和并集的操作</p><p>key-zest：排行榜，积分存储等操作。</p><h3 id="3-2-String常用命令"><a href="#3-2-String常用命令" class="headerlink" title="3.2 String常用命令"></a>3.2 String常用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1.添加值</span><br><span class="hljs-built_in">set</span> key value<br><br><span class="hljs-comment">#2.取值</span><br>get key<br><br><span class="hljs-comment">#3.批量操作</span><br>mset key value [key value...]<br>mget key [key...]<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#4.自增命令（自增1）（应用场景 -&gt; 点赞）</span><br>incr key<br><br><span class="hljs-comment">#5.自减命令（自减1)</span><br>decr key<br><br><span class="hljs-comment">#6.自增或自减指定数量</span><br>incrby key &lt;increment&gt;<br>decrby key &lt;increment&gt;<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#7.设置值的同时。指定生存时间（每次向Redis中添加数据时，尽量都设置上生存时间）</span><br>setex key &lt;second&gt; value<br><br><span class="hljs-comment">#8.设置值，如果当前key不存在的话（如果这个key存在，什么事都不做，如果这个key不存在，和set命令一样）</span><br>setnx key value<br><br><span class="hljs-comment">#9. 在key对应的value后，追加内容</span><br>append key value<br><br><span class="hljs-comment">#10. 查看value字符串的长度</span><br>strlen key<br></code></pre></td></tr></table></figure><h3 id="3-3-hash常用命令"><a href="#3-3-hash常用命令" class="headerlink" title="3.3 hash常用命令"></a>3.3 hash常用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1.存储数据</span><br>hset key field value<br><br><span class="hljs-comment">#2.获取数据</span><br>hget key field<br><br><span class="hljs-comment">#3.批量操作</span><br>hmset key field value [field value ...]<br>hmget key field [field ...]<br><br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#4.自增（指定自增的值）</span><br>hincrby key field increment<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#5.设置值（如果key-field不存在，那么就正常添加，如果存在，什么事都不做）</span><br>hsetnx key field value<br><br><span class="hljs-comment">#6.检查field是否存在</span><br>hexists key field<br><br><span class="hljs-comment">#7.删除key对应的某一个field，可以删除多个</span><br>hdel key field [field]<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#8.获取当前hash结构中的全部field和value</span><br>hgetall key<br><br><span class="hljs-comment">#9.获取当前hash结构中的全部field</span><br>hkeys key<br><br><span class="hljs-comment">#10. 获取当前hash结构中的全部value</span><br>hvals key<br><br><span class="hljs-comment">#11. 获取当前hash结构中field的数量</span><br>hlen key<br></code></pre></td></tr></table></figure><h3 id="3-4-list常用命令"><a href="#3-4-list常用命令" class="headerlink" title="3.4 list常用命令"></a>3.4 list常用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1.存储数据（从左侧插入数据，从右侧插入数据）</span><br>lpush key value [value ...]<br>rpush key value [value ...]<br><br><span class="hljs-comment">#2.存储数据（如果key不存在，什么事都不做，如果key存在，但是不是list结构，什么都不做）</span><br>lpushx key value<br>rpushx key value<br><br><span class="hljs-comment">#3.修改数据（在存储数据时，指定好你的索引位置，覆盖之前索引位置的数据，index超出整个列表的长度，也会失败）</span><br>lset key index value<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#4.弹栈方式获取数据（左侧弹出数据，从右侧弹出数据）</span><br>lpop key<br>rpop key<br><br><span class="hljs-comment">#5.获取指定索引范围的数据（start从0开始，stop输入-1代表最后一个）</span><br>lrange key start stop<br><br><span class="hljs-comment">#6.获取指定索引位置的数据</span><br>lindex kek index<br><br><span class="hljs-comment">#7.获取整个列表的长度</span><br>llen key<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#8.删除列表中的数据（删除当前列表中的count个value值；count&gt;0，从左侧向右侧删除；count&lt;0，从右侧向左侧删除；count==0，删除列表中全部数据）</span><br>lrem key count value<br><br><span class="hljs-comment">#9.保留列表中的数据（保留指定索引范围内的数据，超过整个索引范围被移除掉）</span><br>ltrim key start stop<br><br><span class="hljs-comment">#10. 将一个列表中最后的一个数据，插入到另外一个列表的头部位置</span><br>rpoplpush list1 list2<br></code></pre></td></tr></table></figure><h3 id="3-5-set常用命令"><a href="#3-5-set常用命令" class="headerlink" title="3.5 set常用命令"></a>3.5 set常用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1.存储数据</span><br>sadd key member [member ...]<br><br><span class="hljs-comment">#2.获取数据（获取全部数据）</span><br>smembers key<br><br><span class="hljs-comment">#3.随机获取一个数据（获取的同时，移除数据，count默认为1，代表弹出数据的数量）</span><br>spop key [count]<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#4. 交集（取多个set集合交集）</span><br>sinter set1 set2 ...<br><br><span class="hljs-comment">#5. 并集（获取全部集合中的数据）</span><br>sunion set1 set2 ...<br><br><span class="hljs-comment">#6.差集(获取多个集合中不一样的数据)</span><br>sdiff set1 set2 ... （获取set1-set2）<br>sdiff set2 set1 ... （获取set2-set1）<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#7.删除数据</span><br>srem key member [member ...]<br><br><span class="hljs-comment">#8.查看当前的set集合中是否包含这个值</span><br>sismember key member<br></code></pre></td></tr></table></figure><h3 id="3-6-zset常用命令"><a href="#3-6-zset常用命令" class="headerlink" title="3.6 zset常用命令"></a>3.6 zset常用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1.添加数据（score必须是一个数值，member不允许重复）</span><br>zadd key score member [socre member ...]<br><br><span class="hljs-comment">#2. 修改member的分数（如果member是存在于key中的，正常增加分数，如果member不存在，这个命令就相当于zadd）</span><br>zincrby key increment member<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#3.查看指定的member的分数</span><br>zscore key member<br><br><span class="hljs-comment">#4.获取zset中数据的数量</span><br>zcard key<br><br><span class="hljs-comment">#5.根据score的范围查询member数量</span><br>zcount key min max<br><br><span class="hljs-comment">#6.删除zset中的成员</span><br>zrem key member [member ...]<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#7.根据分数从小到大排序，获取指定范围内的数据（withscore如果添加这个参数，那么会返回member对应的分数）</span><br>zrange key start stop [withscores]<br><br><span class="hljs-comment">#8.根据分数从大到小排序，获取指定范围内的数据</span><br>zrevrange key start stop [withscores]<br><br><span class="hljs-comment">#9.根据分数的返回去获取member（withscores代表返回score，添加limit，就和MySQL一样，如果不希望等于min或者max的值被查询出来可以采用‘（分数’相当于 &lt; 但是不等于的方式，最大值和最小值使用+inf和-inf来表示）</span><br>zrangebyscore key min max [withscores] [<span class="hljs-built_in">limit</span> offset count]<br><br><span class="hljs-comment">#10.根据分数的返回去获取member（withscores代表返回score，添加limit，就和MySQL一个样）</span><br>zrangebyscore key max min [withscores] [<span class="hljs-built_in">limit</span> offset count]<br></code></pre></td></tr></table></figure><h3 id="3-7-key常用命令"><a href="#3-7-key常用命令" class="headerlink" title="3.7 key常用命令"></a>3.7 key常用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1.查看Redis中的全部的key（pattern: *, xxx*, *xxx）</span><br>keys pattern<br><br><span class="hljs-comment">#2.查看某一个key是否存在（1 - key存在，0 - key不存在）</span><br>exists key<br><br><span class="hljs-comment">#3.删除key</span><br>del key [key ...]<br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#4.设置key的生存时间，单位为秒，单位为毫秒，设置还能活多久</span><br>expire key second<br>pexpire key milliseconds<br><br><span class="hljs-comment">#5.设置key的生存时间，单位为秒，单位为毫秒，设置能活到什么时间点</span><br>expireat key timestamp<br>pexpireat key milliseconds<br><br><span class="hljs-comment">#6. 查看key的剩余生存时间，单位为秒，单位为毫秒（-2 - 当前key不存在，-1 - 当前key没有设置生存时间，具体剩余的生存时间）</span><br>ttl key<br>pttl key<br><br><span class="hljs-comment">#7. 移除key的生存时间（1 - 移除成功，0 - key不存在生存时间，key不存在）</span><br>persist key <br></code></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#8.选择操作的库</span><br>select 0~15<br><br><span class="hljs-comment">#9.移动key到另外一个库中</span><br>move key db<br></code></pre></td></tr></table></figure><p>3.8 库的常用命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1. 清空当前所在的数据库</span><br>flushdb<br><br><span class="hljs-comment">#2.清空全部数据库</span><br>flushall<br><br><span class="hljs-comment">#3.查看当前数据库中有多少个key</span><br>dbsize<br><br><span class="hljs-comment">#4.查看最后一次操作的时间</span><br>lastsave<br><br><span class="hljs-comment">#5.实时监控redis服务接收到的目录</span><br>monitor<br></code></pre></td></tr></table></figure><h2 id="四、Java连接Redis"><a href="#四、Java连接Redis" class="headerlink" title="四、Java连接Redis"></a>四、Java连接Redis</h2><p>Jedis连接Redis，Lettuce连接Redis</p><h3 id="4-1-Jedis连接Redis"><a href="#4-1-Jedis连接Redis" class="headerlink" title="4.1 Jedis连接Redis"></a>4.1 Jedis连接Redis</h3><blockquote><ol><li>创建maven项目</li><li>导入需要的依赖</li><li>测试</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//1. 连接Redis</span><br>        Jedis jedis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br><br>        <span class="hljs-comment">//2. 操作Redis - 因为Redis的命令是什么，Jedis的方法就是什么</span><br>        jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>);<br><br>        <span class="hljs-comment">//3. 释放资源</span><br>        jedis.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//1. 连接Redis</span><br>        Jedis jedis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br><br>        <span class="hljs-comment">//2. 操作Redis - 因为Redis的命令是什么，Jedis的方法就是什么</span><br>        String value=jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(value);<br><br>        <span class="hljs-comment">//3. 释放资源</span><br>        jedis.close();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Jedis如何存储一个对象到Redis以Byte-的形式"><a href="#4-2-Jedis如何存储一个对象到Redis以Byte-的形式" class="headerlink" title="4.2 Jedis如何存储一个对象到Redis以Byte[]的形式"></a>4.2 Jedis如何存储一个对象到Redis以Byte[]的形式</h3><blockquote><p>准备一个User实体类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <br>    <span class="hljs-comment">// serialVersionUID</span><br>    <span class="hljs-comment">// NoArgsConstructor</span><br>    <span class="hljs-comment">// AllArgsConstructor</span><br>    <br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>    <br>    <span class="hljs-comment">// get set...</span><br>        <br>    <span class="hljs-comment">// toString ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>导入spring-context依赖</p><blockquote><p>创建Demo类，编写测试内容</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisTest2</span> &#123;<br><br>    <span class="hljs-comment">// 存储对象 - 以byte[]形式存储在Redis中</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setByteArray</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//1. 连接Redis</span><br>        Jedis jedis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br><br>        <span class="hljs-comment">//-------------------------------</span><br>        <span class="hljs-comment">//2.1 准备key(String)-value(User)</span><br>        String key=<span class="hljs-string">&quot;user&quot;</span>;<br>        User value=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-comment">//2.2 将key和value转换为byte[]</span><br>        <span class="hljs-type">byte</span>[] byteKey = SerializationUtils.serialize(key);<br>        <span class="hljs-type">byte</span>[] byteValue = SerializationUtils.serialize(value);<br>        <span class="hljs-comment">//2.3 将key和value存储到Redis</span><br>        jedis.set(byteKey,byteValue);<br>        <span class="hljs-comment">//-------------------------------</span><br><br>        <span class="hljs-comment">//3. 释放资源</span><br>        jedis.close();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取对象 - 以byte[]形式在Redis中获取</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getByteArray</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//1. 连接Redis</span><br>        Jedis jedis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br><br>        <span class="hljs-comment">//-------------------------------</span><br>        <span class="hljs-comment">//2.1 准备key</span><br>        String key=<span class="hljs-string">&quot;user&quot;</span>;<br>        <span class="hljs-comment">//2.2 将key转换为byte[]</span><br>        <span class="hljs-type">byte</span>[] byteKey = SerializationUtils.serialize(key);<br>        <span class="hljs-comment">//2.3 jedis去Redis中获取value</span><br>        <span class="hljs-type">byte</span>[] value = jedis.get(byteKey);<br>        <span class="hljs-comment">//2.4 将value反序列化为User对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) SerializationUtils.deserialize(value);<br>        <span class="hljs-comment">//2.5 输出</span><br>        System.out.println(user.toString());<br>        <span class="hljs-comment">//-------------------------------</span><br><br>        <span class="hljs-comment">//3. 释放资源</span><br>        jedis.close();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-Jedis如何存储一个对象到Redis以String的形式"><a href="#4-3-Jedis如何存储一个对象到Redis以String的形式" class="headerlink" title="4.3 Jedis如何存储一个对象到Redis以String的形式"></a>4.3 Jedis如何存储一个对象到Redis以String的形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisTest3</span> &#123;<br><br>    <span class="hljs-comment">// 存储对象 - 以String形式存储</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//1. 连接Redis</span><br>        Jedis jedis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br><br>        <span class="hljs-comment">//2.1 准备key(String)-value(User)</span><br>        String stringKey=<span class="hljs-string">&quot;stringUser&quot;</span>;<br>        User value=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-comment">//2.2 使用fastJSON将value转化为json字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stringValue</span> <span class="hljs-operator">=</span> JSON.toJSONString(value);<br>        <span class="hljs-comment">//2.3 存储到redis中</span><br>        jedis.set(stringKey,stringValue);<br><br>        <span class="hljs-comment">//3. 释放资源</span><br>        jedis.close();<br><br>    &#125;<br><br>    <span class="hljs-comment">// 获取对象 - 以String形式获取</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//1. 连接Redis</span><br>        Jedis jedis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br><br>        <span class="hljs-comment">//2.1 准备一个key</span><br>        String key=<span class="hljs-string">&quot;stringUser&quot;</span>;<br>        <span class="hljs-comment">//2.2 去Redis中查询value</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> jedis.get(key);<br>        <span class="hljs-comment">//2.3 存储到redis中</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> JSON.parseObject(value, User.class);<br>        <span class="hljs-comment">//2.4 输出</span><br>        System.out.println(user.toString());<br><br>        <span class="hljs-comment">//3. 释放资源</span><br>        jedis.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-Jedis的连接池操作"><a href="#4-4-Jedis的连接池操作" class="headerlink" title="4.4 Jedis的连接池操作"></a>4.4 Jedis的连接池操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pool2</span><span class="hljs-params">()</span>&#123;<br>    <br>    <span class="hljs-comment">//1. 创建连接池的配置信息</span><br>    GenericObjectPoolConfig poolConfig=<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericObjectPoolConfig</span>();<br>    poolConfig.setMaxTotal(<span class="hljs-number">100</span>); <span class="hljs-comment">// 连接池中最大活跃数</span><br>    poolConfig.setMaxIdle(<span class="hljs-number">10</span>); <span class="hljs-comment">// 最大空闲数</span><br>    poolConfig.setMinIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">// 最小空闲数</span><br>    poolConfig.setMaxWaitMillis(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 当连接池空了，多久没获取到jedis对象就超时</span><br><br>    <span class="hljs-comment">//2. 创建连接池</span><br>    JedisPool pool=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig,<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br><br>    <span class="hljs-comment">//3. 通过连接池获取Jedis对象</span><br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> pool.getResource();<br><br>    <span class="hljs-comment">//4. 操作</span><br>    String value=jedis.get(<span class="hljs-string">&quot;stringUser&quot;</span>);<br>    System.out.println(value);<br><br>    <span class="hljs-comment">//5. 释放资源</span><br>    jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-Redis的管道操作"><a href="#4-5-Redis的管道操作" class="headerlink" title="4.5 Redis的管道操作"></a>4.5 Redis的管道操作</h3><p>因为在操作Redis的时候，执行一个命令需要先发送请求到Redis服务器，这个过程需要经历网络的延迟，Rdis还需要给客户端一个响应。</p><p>如果我需要一次性执行很多个命令，上述的方式效率很低，可以通过Redis的管道，先将命令放到客户端的一个Pipeline中，之后一次性的将全部命令都发送Redis服务，Redis服务一次性的将全部的返回结果响应给客户端。</p><p>（提高Redis并发能力，处理请求的效率更高）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Redis管道的操作</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pipeline</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//1. 创建连接池</span><br>    JedisPool pool=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-comment">//2. 获取一个连接对象</span><br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> pool.getResource();<br><br>    <span class="hljs-comment">//3. 执行incr - 10000次</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++)&#123;<br>        jedis.incr(<span class="hljs-string">&quot;qq&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//4. 释放资源</span><br>    jedis.close();<br><br>    <span class="hljs-comment">// =================================</span><br><br>    <span class="hljs-comment">//2. 获取一个连接对象</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    Jedis jedis1=pool.getResource();<br>    <span class="hljs-comment">//3. 创建管道</span><br>    <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipelined</span> <span class="hljs-operator">=</span> jedis1.pipelined();<br>    <span class="hljs-comment">//4. 执行incr - 10000次放到管道中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++)&#123;<br>        jedis.incr(<span class="hljs-string">&quot;pp&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5. 执行命令</span><br>    pipelined.syncAndReturnAll();<br>    <span class="hljs-comment">//6. 释放资源</span><br>    jedis1.close();<br>    <br>    System.out.println(System.currentTimeMillis()-l);<br>    System.out.println(System.currentTimeMillis()-l1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、Redis其它配置及集群"><a href="#五、Redis其它配置及集群" class="headerlink" title="五、Redis其它配置及集群"></a>五、Redis其它配置及集群</h2><h3 id="5-1-Redis的AUTH"><a href="#5-1-Redis的AUTH" class="headerlink" title="5.1 Redis的AUTH"></a>5.1 Redis的AUTH</h3><p>Redis默认配置是不需要密码认证的，也就是说只要连接的Redis服务器的host和port正确，就可以连接使用。这在安全性上会有一定的问题，所以需要启用Redis的认证密码，增加Redis服务器的安全性。</p><h4 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h4><p>Redis的配置文件默认在<code>/etc/redis.conf</code>，找到如下行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#requirepass foobared</span><br></code></pre></td></tr></table></figure><p>去掉前面的注释，并修改为所需要的密码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">requirepass myPassword （其中myPassword就是要设置的密码）<br></code></pre></td></tr></table></figure><h4 id="2-重启Redis"><a href="#2-重启Redis" class="headerlink" title="2. 重启Redis"></a>2. 重启Redis</h4><p>如果Redis已经配置为<code>service</code>服务，可以通过以下方式重启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">service redis restart<br></code></pre></td></tr></table></figure><p>如果Redis没有配置为<code>service</code>服务，可以通过以下方式重启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">/usr/local/bin/redis-cli shutdown<br>/usr/local/bin/redis-server /etc/redis.conf<br></code></pre></td></tr></table></figure><h4 id="3-登录验证"><a href="#3-登录验证" class="headerlink" title="3. 登录验证"></a>3. 登录验证</h4><p>设置Redis认证密码后，客户端登录时需要使用<code>-a</code>参数输入认证密码，不添加该参数虽然也可以登录成功，但是没有任何操作权限。如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./redis-cli -h 127.0.0.1 -p 6379<br>127.0.0.1:6379&gt; keys *<br>(error) NOAUTH Authentication required.<br></code></pre></td></tr></table></figure><p>使用密码认证登录，并验证操作权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./redis-cli -h 127.0.0.1 -p 6379 -a myPassword<br>127.0.0.1:6379&gt; config get requirepass<br>1) <span class="hljs-string">&quot;requirepass&quot;</span><br>2) <span class="hljs-string">&quot;myPassword&quot;</span><br></code></pre></td></tr></table></figure><p>看到类似上面的输出，说明Reids密码认证配置成功。</p><p>除了按上面的方式在登录时，使用<code>-a</code>参数输入登录密码外。也可以不指定，在连接后进行验证：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./redis-cli -h 127.0.0.1 -p 6379<br>127.0.0.1:6379&gt; auth myPassword<br>OK<br>127.0.0.1:6379&gt; config get requirepass<br>1) <span class="hljs-string">&quot;requirepass&quot;</span><br>2) <span class="hljs-string">&quot;myPassword&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure><h4 id="4-在命令行客户端配置密码（redis重启前有效）"><a href="#4-在命令行客户端配置密码（redis重启前有效）" class="headerlink" title="4. 在命令行客户端配置密码（redis重启前有效）"></a>4. 在命令行客户端配置密码（redis重启前有效）</h4><p>前面介绍了通过<code>redis.conf</code>配置密码，这种配置方式需要重新启动Redis。也可以通命令行客户端配置密码，这种配置方式不用重新启动Redis。配置方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; config <span class="hljs-built_in">set</span> requirepass newPassword<br>OK<br>127.0.0.1:6379&gt; config get requirepass<br>1) <span class="hljs-string">&quot;requirepass&quot;</span><br>2) <span class="hljs-string">&quot;newPassword&quot;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>使用命令行客户端配置密码，重启Redis后仍然会使用<code>redis.conf</code>配置文件中的密码。</strong></p><h4 id="5-在Redis集群中使用认证密码"><a href="#5-在Redis集群中使用认证密码" class="headerlink" title="5. 在Redis集群中使用认证密码"></a>5. 在Redis集群中使用认证密码</h4><p>如果Redis服务器，使用了集群。除了在<code>master</code>中配置密码外，也需要在<code>slave</code>中进行相应配置。在<code>slave</code>的配置文件中找到如下行，去掉注释并修改与<code>master</code>相同的密码即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># masterauth master-password</span><br></code></pre></td></tr></table></figure><h4 id="6-Jedis客户端中使用auth"><a href="#6-Jedis客户端中使用auth" class="headerlink" title="6. Jedis客户端中使用auth"></a>6. Jedis客户端中使用auth</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//连接Redis</span><br>   Jedis jedis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br>   jedis.auth(<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建连接池（3000：超时时间；123：auth密码）</span><br>JedisPool pool=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig,<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>,<span class="hljs-number">3000</span>,<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="5-2-Redis的事务"><a href="#5-2-Redis的事务" class="headerlink" title="5.2 Redis的事务"></a>5.2 Redis的事务</h3><p>Redis的事务：一次事务操作，该成功的成功，该失败的失败。</p><p>先开启事务，执行一系列的命令，但是命令不会立即执行，会被放在一个队列中，如果你执行事务，那么这个队列中的命令全部执行，如果取消了事务，一个队列中的命令全部作废。</p><blockquote><ol><li>开启事务：multi</li><li>输入要执行的命令 -&gt; 放到一个队列中</li><li>执行事务：exec</li><li>取消事务：discard</li></ol></blockquote><p>Redis的事务向发挥功能，需要配置watch监听机制</p><p>在开启事务之前，先通过watch命令去监听一个或多个key，在开启事务之后，如果有其他客户端修改了我监听的key，事务会自动取消。</p><p> 如果执行了事务，或者取消了事务，watch监听自动消除，一般不需要去手动执行unwatch。</p><h3 id="5-3-Redis持久化机制"><a href="#5-3-Redis持久化机制" class="headerlink" title="5.3 Redis持久化机制"></a>5.3 Redis持久化机制</h3><p>RDB是Redis默认的持久化机制</p><blockquote><ol><li><p>RDB是持久化文件，速度比较快，而且存储的是一个二进制的文件，传输起来很方便。</p></li><li><p>RDB持久化的时机：</p><p>save 900 1：在900秒内，有1个key改变了，就执行RDB持久化。<br>save 300 10：在300秒内，有10个key改变了，就执行RDB持久化。<br>save 60 10000：在6秒内，有10000个key改变了，就执行RDB持久化。</p></li><li><p>RDB无法保证数据的绝对安全。</p></li></ol></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 开启RDB持久化的压缩</span><br>rdbcompression <span class="hljs-built_in">yes</span><br><span class="hljs-comment"># RDB持久化文件的名称</span><br>dbfilename redis.rdb<br></code></pre></td></tr></table></figure><hr><blockquote><pre><code class="hljs">AOF持久化机制默认是关闭的，Redis官方推荐同时开启RDB和AOF持久化，更安全，避免数据丢失。        1. AOF持久化的速度，相对RDB是较慢的，存储的是一个文本文件，到了后期文件会比较大，传输困难。        2. AOF的持久化时机。          appendfsync always：每执行一个写操作，立即持久化到AOF文件中，性能比较低。          appendfsync everysec：每秒执行一次持久化。          appendfsync no：会根据你的操作系统不同，环境的不同，在一定时间内执行一次持久化。        3. AOF相对RDB更安全，推荐同时开启AOF和RDB。</code></pre></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代表开启AOF持久化</span><br>appendonly <span class="hljs-built_in">yes</span><br><span class="hljs-comment"># AOF文件的名称</span><br>appendfilename <span class="hljs-string">&quot;redis.aof&quot;</span><br></code></pre></td></tr></table></figure><hr><p>同时开启RDB和AOF的注意项：</p><p>如果同时开启了AOF和RDB持久化，那么Redis宕机重启之后，需要加载一个持久化文件，优先选择AOF文件。</p><p>如果先开启了RDB，再次开启AOF，如果RDB执行了持久化，那么RDB文件中的内容会被AOF覆盖掉。</p><h3 id="5-4-Redis的主从架构"><a href="#5-4-Redis的主从架构" class="headerlink" title="5.4 Redis的主从架构"></a>5.4 Redis的主从架构</h3><p>单机版Redis存在读写瓶颈的问题</p><h3 id="5-5-哨兵"><a href="#5-5-哨兵" class="headerlink" title="5.5 哨兵"></a>5.5 哨兵</h3><p>哨兵可以帮助我们解决主从架构中的单点故障问题</p><p>准备哨兵的配置文件，并且在容器内部手动启动哨兵即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 哨兵需要后台启动</span><br>daemonize no<br><span class="hljs-comment"># 指定Master 节点的ip的端口（主）</span><br>sentinel monitor master localhost 6379 2<br><span class="hljs-comment"># 指定Master 节点的ip的端口（主）</span><br>sentinel monitor master master 6379 2<br><span class="hljs-comment"># 哨兵每隔多久监听一次redis架构</span><br>sentinel down-after-milliseconds master 10000<br></code></pre></td></tr></table></figure><p>在Redis容器内部启动sentinel即可</p><h3 id="5-6-Redis的集群"><a href="#5-6-Redis的集群" class="headerlink" title="5.6 Redis的集群"></a>5.6 Redis的集群</h3><p>Redis集群在保证主从加哨兵的基本功能之外，还能够提升Redis存储的能力</p><ol><li>Redis集群是无中心的。</li><li>Redis集群有一个ping-pang机制。</li><li>投票机制，Redis集群节点的数量必须是2n+1。</li><li>Redis集群中默认分配了16384个hash槽，在存储数据时，就会将key进行crc16的算法，并且对16384取余，根据最终的结果，将key-value存放到执行Redis节点中，而且每一个Redis集群都在维护着相应的hash槽。</li><li>为了保证数据的安全性，每一个集群的节点，至少要跟着一个从节点。</li><li>单独的针对Redis集群中的某一个节点搭建主从。</li><li>当Redis集群中，超过半数的节点宕机之后，Redis集群就瘫痪了。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># redis.conf</span><br><span class="hljs-comment"># 指定redis的端口号</span><br>port 7001<br><span class="hljs-comment"># 开启Redis集群</span><br>cluster-enabled <span class="hljs-built_in">yes</span><br><span class="hljs-comment"># 集群信息的文件</span><br>cluster-config-file nodes-7001.conf<br><span class="hljs-comment"># 集群的对外ip地址</span><br>cluster-announce-ip 192.168.200.130 <br><span class="hljs-comment"># 集群的对外port</span><br>cluster-announce-port 7001<br><span class="hljs-comment"># 集群的总线端口</span><br>cluster-announce-bus-port 17001<br></code></pre></td></tr></table></figure><blockquote><p>启动了6个Redis的节点</p><p>随便跳转到一个容器内部，使用redis-cli管理集群</p></blockquote><h2 id="六、Redis常见问题"><a href="#六、Redis常见问题" class="headerlink" title="六、Redis常见问题"></a>六、Redis常见问题</h2><h3 id="6-1-key的生存时间到了，Redis会立即删除吗？"><a href="#6-1-key的生存时间到了，Redis会立即删除吗？" class="headerlink" title="6.1 key的生存时间到了，Redis会立即删除吗？"></a>6.1 key的生存时间到了，Redis会立即删除吗？</h3><blockquote><p>不会立即删除。</p></blockquote><ol><li>定期删除：</li></ol><p>  Redis每隔一段时间就会去查看Redis设置了过期时间的key。会在100ms的间隔中默认查看3个key。</p><ol start="2"><li><p>惰性删除：</p><p>如果当你去查询一个已经过了生存时间的key时，Redis会查看当前key的生存时间，是否已经到了，直接删除当前key，并且给用户返回一个空值。</p></li></ol><h3 id="6-2-Redis的淘汰机制"><a href="#6-2-Redis的淘汰机制" class="headerlink" title="6.2 Redis的淘汰机制"></a>6.2 Redis的淘汰机制</h3><blockquote><p>在Redis内存已经满的时候，添加了一个新的数据，执行淘汰机制。</p></blockquote><ol><li><p>volatile-lru：</p><p>在内存不足时，Redis会在已经设置过了生存时间的key中干掉一个最近最少使用的key。</p></li><li><p>allkeys-lru：</p><p>在内存不足时，Redis会在全部的key中干掉一个最近最少使用的key。</p></li><li><p>volatile-lfu：</p><p>在内存不足时，Redis会在已经设置过了生存时间的key中干掉一个最近最少频次使用的key。</p></li><li><p>allkeys-lfu：</p><p>在内存不足时，Redis会在全部的key中干掉一个最近最少频次使用的key。</p></li><li><p>volatile-random：</p><p>在内存不足时，Redis会在已经设置过了生存时间的key中随机干掉一个。</p></li><li><p>allkeys-random：</p><p>在内存不足时，Redis会在全部的key中随机干掉一个。</p></li><li><p>volatile-ttl：</p><p>在内存不足时，Redis会在已经设置过了生存时间的key中干掉一个剩余生存时间最少的key。</p></li><li><p>noeviction：（默认）</p><p>在内存不足时，直接报错</p></li></ol><p> 指定淘汰机制的方式：maxmemory-policy noeviction</p><p> 设置Redis的最大内存：maxmemory <bytes></p><h3 id="6-3-缓存的常见问题"><a href="#6-3-缓存的常见问题" class="headerlink" title="6.3 缓存的常见问题"></a>6.3 缓存的常见问题</h3><blockquote><p>缓存穿透：</p></blockquote><p>问题出现的原因：查询的数据，Redis中没有，数据库也没有。<br>1：根据id查询时，如果id是自增的，将id的最大值放到Redis中，在查询数据库之前，直接比较一下id。</p><p>2：如果id不是整型，可以将全部的id放到set中，在用户查询之前，去set中查看一下是否有一个id。</p><p>3：获取客户端的ip地址，可以将ip的访问添加限制。</p><blockquote><p>缓存击穿</p></blockquote><p>问题：缓存中的热点数据，突然到期了，造成了大量的请求都去访问数据库，造成数据库宕机。</p><p>1.在访问缓存中没有的时候，直接添加一个锁，让几个请求去访问数据库，避免数据库宕机。</p><p>2.热点数据的生存时间去掉。</p><blockquote><p>缓存雪崩</p></blockquote><p>问题：当大量缓存同时到期时，最终大量的请求同时去访问数据库，导致数据库宕机。</p><p>将缓存中的数据的生存时间，设置为30~60分钟的一个随机时间。</p><blockquote><p>缓存倾斜</p></blockquote><p>问题：热点数据放在了一个Redis节点上，导致Redis节点无法承受住大量的请求，最终Redis宕机。</p><p>1.扩展主从架构，搭建大量的从节点，缓解Redis的压力。</p><p>2.可以在Tomcat中JVM缓存，在查看Redis之前，先去查询Tomcat中的缓存。</p><p><strong>文献来源：</strong></p><p><a href="https://www.bilibili.com/video/BV1FZ4y1u7ny">Redis超详细版教程通俗易懂</a></p><p><a href="https://www.jb51.net/article/115775.htm">详解Redis使用认证密码登录</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里巴巴集团开发规约</title>
    <link href="/2020/01/01/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6/"/>
    <url>/2020/01/01/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="../../../../pdf/阿里巴巴集团开发规约.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>规约</tag>
      
      <tag>阿里巴巴</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
