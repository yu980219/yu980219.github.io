---
title: 4. 寻找两个正序数组的中位数
tags: [LeetCode]
categories:
  - 算法
  - LeetCode力扣
  - Hard
index_img: /img/leetcode.jpeg
date: 2022/10/08 15:26:47
---

#### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

在分析这道题之前，先贴一个普通解法。

执行用时: **1 ms**

内存消耗: **42.2 MB**

#### 普通解：

##### 解析：

首先要了解中位数的定义，一个长度为sum的数组中，如果长度是奇数，则中位数所在的索引位置就是sum/2+1，如果是偶数，为sum/2+1和sum/2的平均数。

其实我们不需要真正的全部遍历完，我们只需要找到中位数，遍历到中位数的位置停下即可。

##### 时间复杂度：O((m+n-1)/2)

时间复杂度不用说了，遍历一半是肯定的要的。

##### 代码：

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int sum = nums1.length + nums2.length;
    
    // n1,n2分别代表两个数组的指针，从0开始往后移动。
    int n1 = 0, n2 = 0, val1 = 0, val2 = 0;
    
    // 遍历到中位数，停止
    while (n1 + n2 <= sum / 2) {
        
        // 赋值阶段，两个数组指针开始移动对比
        // 哪个指针指向的数小，哪个就赋值给val2，下次遍历，val2赋值给val1，相当于清空val2
        // 如果一个数组全部遍历完毕，接下来在另一个数组里指针一个一个往后移动即可。
        val1 = val2;
        if (n1 == nums1.length) {
            val2 = nums2[n2++];
        } else if (n2 == nums2.length) {
            val2 = nums1[n1++];
        } else if (nums1[n1] < nums2[n2]) {
            val2 = nums1[n1++];
        } else {
            val2 = nums2[n2++];
        }
    }
    return sum % 2 != 0 ? val2 : (val1 + val2) / 2.0;
}
```

#### 最优解：

##### 解析：

首先时间复杂度要求O(log(m+n))，自然想到二分法。

----

1. 设定一个k，k为第k小的数

   如果数组长度是奇数，直接求**k=(sum+1)/2**小的数，即中位数

   如果数组长度是偶数，不光要求上面的k，还要再求一个k，**k=(sum+2)/2**小的数，然后把他们平均。

   ex：

   假设两个数组和是7，奇数，k=(7+1)/2=4，第4小的数就是中位数。

   假设两个数组和是10，偶数，第一个k=(10+1)/2=5，第二个k=(10+2)/2=6，索引位置5和6的和的平均值，即为中位数。

2. 在第一个数组中取前**k/2**个数，则第二个数组取前**k-k/2**个数。

   设两个数组分别为A，B

   **① 如果 A[k/2] < B[k-k/2]，那么第k个数一定不在A中前k/2中，直接删掉，删掉了k/2个数，一共还剩k-k/2个数。**

   **② 如果 A[k/2] > B[k-k/2]，那么第k个数一定不在B中前k-k/2中，直接删掉，删掉了k/2个数，一共还剩k-(k-k/2)个数。**

   **③ 如果 k==1，这里是递归的出口。**

   ex：

   **A : [1,3,6,9]**

   **B : [1,2,3,4,5,6,7]**

   > 1. 一共11个数，奇数个，k=(11+1)/2=6，找出第6小的数。
   >
   > 2. k=6，k/2=3，k-k/2=3。
   >
   >    A第3个数，6
   >
   >    B第3个数，3
   >
   >    A[k/2] > B[k-k/2]，那么B中前k-k/2，可以直接“删除”，指针移动到B中的4，A中不变。

   **A : [1,3,6,9]**

   **B : [4,5,6,7]**

   > 3. 一共还剩k=k-(k-k/2)=3个数，找出第3小的数。
   >
   > 4. k=3，k/2=1，k-k/2=2
   >
   >    A第1个数，1
   >
   >    B第2个数，5
   >
   >    A[k/2] < B[k-k/2]，A中前k/2个数，可以直接“删除”，指针移动到A中的3，B中不变。

   **A : [3,6,9]**

   **B : [4,5,6,7]**

   > 5. 一共还剩k=k-k/2=2个数，找出第2小的数。
   >
   > 6. k=2，k/2=1，k-k/2=1
   >
   >    A第1个数，3
   >
   >    B第1个数，4
   >
   >    A[k/2] < B[k-k/2]，A中前k/2个数，可以直接“删除”，指针移动到A中的6，B中不变。

   **A : [6,9]**

   **B : [4,5,6,7]**

   > 7. 一共还剩k=k-k/2=1个数，找出第1小的数。
   >
   > 8. 已经到了递归的出口，直接比较两个数组中，指针的位置，哪个更小，就是中位数。
   >
   >    4和6比较，4更小，4是中位数。

##### 代码：

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int n = nums1.length;
    int m = nums2.length;
    // 中位数1
    int left = (n + m + 1) / 2;
    // 中位数2
    int right = (n + m + 2) / 2;
   
    return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;  
}

private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
    
    // 求两个数组的长度
    int len1 = end1 - start1 + 1;
    int len2 = end2 - start2 + 1;
    
    // 如果nums1比nums2长，两个数组交换，让nums1总是数少的那个。
    if (len1 > len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);
    
    // 如果nums1用完了，直接找出中位数即可。
    if (len1 == 0) return nums2[start2 + k - 1];

    // 如果k==1，说明就在两个数组中的指针最开始的位置比较了，哪个小哪个就是中位数。
    if (k == 1) return Math.min(nums1[start1], nums2[start2]);

    // 设定两个数组起始位置
    // 这里把数组长度和k/2比较，是为了防止k/2越界
    int i = start1 + Math.min(len1, k / 2) - 1;
    int j = start2 + Math.min(len2, k / 2) - 1;

    // 如果较小的数在第二个数组中
    if (nums1[i] > nums2[j]) {
        // nums1的指针不动，nums2的指针移动j+1个距离，相当于把j+1前面的所有数都删掉了。
        return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
    }
    // 如果较小的数在第一个数组中
    else {
        // nums2的指针不动，nums1的指针移动i+1个距离，相当于把i+1前面的所有数都删掉了。
        return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
    }
}
```





