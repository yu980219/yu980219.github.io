---
title: 4. 寻找两个正序数组的中位数
tags: [LeetCode]
categories:
  - 算法
  - LeetCode力扣
  - Hard
index_img: /img/leetcode.jpeg
date: 2022/10/08 15:26:47
---

#### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

在分析这道题之前，我在题解里发现一个大部分人都能想出来的办法，代码我贴在下面。我最开始想的也是这个，只不过我没用两个常量去存值，而是用的栈。

#### 普通解：

##### 解析：

首先要了解中位数的定义，如果是奇数则中位数就是sum/2，如果是偶数(sum/2-1+sum/2)/2。

其中sum就是两个数组的和，其实我们不需要真正的全部遍历完，我们只需要找到中位数，遍历到中位数的位置停下即可。

##### 时间复杂度：O((m+n-1)/2)

时间复杂度不用说了，遍历一半是肯定的。

##### 代码：

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int sum = nums1.length + nums2.length;
    
    // n1,n2分别代表两个数组的指针，从0开始往后移动。
    int n1 = 0, n2 = 0, val1 = 0, val2 = 0;
    
    // 遍历到中位数，停止
    while (n1 + n2 <= sum / 2) {
        
        // 赋值阶段，两个数组指针开始移动对比
        // 哪个指针指向的数小，哪个就赋值给val2，下次遍历，val2赋值给val1，再清空val2
        // 如果一个数组全部遍历完毕，接下来在另一个数组里指针一个一个往后移动即可。
        val1 = val2;
        if (n1 == nums1.length) {
            val2 = nums2[n2++];
        } else if (n2 == nums2.length) {
            val2 = nums1[n1++];
        } else if (nums1[n1] < nums2[n2]) {
            val2 = nums1[n1++];
        } else {
            val2 = nums2[n2++];
        }
    }
    return sum % 2 != 0 ? val2 : (val1 + val2) / 2.0;
}
```

#### 最优解：

##### 解析：

解析可能有点长，但真正理解了以后，就会发现，很妙。

首先时间复杂度要求O(log(m+n))，那肯定是要二分法，log，对数嘛。

----

接下来就一步一步分析这道题到底要怎么解。

假设有这么两个数组

a：[1,3,6]

b：[2,4,7,10,13]

本例，中位数 k=(3+5)/2 = 4，那就是要找第4小的数字，和第5小的数字，然后求平均数。

----

先思考，如果让你找



