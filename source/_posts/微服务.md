---
title: 微服务
tags: [Spring,SpringCloud, Java]
categories:
  - 微服务
index_img: /img/default.jpeg
date: 2022/11/17 00:36:00
---
# 微服务

[SpringCloud从小白到精通教程，Spring Cloud微服务架构开发项目实战](https://www.bilibili.com/video/BV1eE41187Ug)

## 微服务基础

### 系统架构的演变

随着互联网的发展，网站应用的规模不断扩大，常规的应用架构已无法应对，分布式服务架构以及微服务架构势在必行，亟需一个治理系统确保架构有条不紊的演进。

例：一个电商系统包含多个模块

#### 单体应用架构

Web应用程序发展的早期，大部分web工程(包含前端页面,web层代码,service层代码,dao层代码)是将所有的功能模块,打包到一起并放在一个web容器中运行。

![image-20221022182714476](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022182714476.png)

比如搭建一个电商系统：客户下订单，商品展示，用户管理。这种将所有功能都部署在一个web容器中运行的系统就叫做单体架构。

优点：

- 项目架构简单，前期开发成本低，周期短，小型项目的首选
- 所有功能集成在一个项目中

缺点：

- 全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。
- 系统性能扩展只能通过扩展集群结点，成本高、有瓶颈。
- 技术栈受限。

#### 垂直应用架构

当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率![image-20221022182850022](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022182850022.png)

优点：

- 解决高并发问题，流量转向了不同的系统
- 针对不同模块的优化
- 方便水平扩展，和容错（例：用户出现问题不会影响商品系统和后台系统）。

缺点：

- 系统间相互独立（如果用户想用商品系统，调用是一个问题）
- 有很多重复开发工作

#### 分布式SOA架构

当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求

![image-20221022183024749](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183024749.png)

优点：

- 抽取公共的功能为服务，提高开发效率
- 对不同的服务进行集群化部署解决系统压力
- 基于ESB/DUBBO减少系统耦合

缺点：

- 抽取服务的粒度较大
- 服务提供方与调用方接口耦合度较高

#### 微服务架构

![image-20221022183051081](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183051081.png)

优点：

- 通过服务的原子化拆分，以及微服务的独立打包、部署和升级，小团队的交付周期将缩短，运维成本也将大幅度下降
- 微服务遵循单一原则，微服务之间采用Restful等轻量协议传输

缺点：

- 微服务过多，服务治理成本高，不利于系统维护。
- 分布式系统开发的技术成本高（容错、分布式事务等）

#### SOA和微服务的关系

- **SOA(Service oriented Architecture)“面向服务的架构"**：他是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用。
- **微服务架构**：其实和SOA架构类似微服务是在SOA上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。

| 功能     | SOA                  | 微服务                       |
| -------- | -------------------- | ---------------------------- |
| 组件大小 | 大块业务逻辑         | 单独任务或小块业务逻辑       |
| 耦合     | 通常松耦合           | 总是松耦合                   |
| 公司架构 | 任何类型             | 小型、专注于功能交叉团队     |
| 管理     | 着重中央管理         | 着重分散管理                 |
| 目标     | 确保应用能够交互操作 | 执行新功能、快速拓展开发团队 |

### 分布式核心知识

#### 分布式中的远程调用

远程调用：

​		![image-20220921001823614](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20220921001823614.png)

##### RPC协议

**RPC**（Remote Procedure Call ） 一种进程间通信方式。允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式（TCP或者UDP）、序列化方式（XML/JSON/二进制）和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。

![image-20221022183346046](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183346046.png)

##### HTTP-Restful接口

REST，即Representational State Transfer的缩写，如果一个架构符合REST原则，就称它为RESTful架构。

RESTful架构：

- 每一个URI代表一种资源；
- 客户端和服务器之间，传递这种资源的某种表现层；
- 客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。

##### 区别与联系

| 比较项   | RESTful    | RPC         |
| -------- | ---------- | ----------- |
| 通讯协议 | HTTP       | 一般使用TCP |
| 性能     | 略低       | 较高        |
| 灵活度   | 高         | 低          |
| 应用     | 微服务架构 | SOA架构     |

1. HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。
2. RPC框架作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。

#### 分布式中的CAP原理

现如今，对于多数大型互联网应用，分布式系统（distributed system）正变得越来越重要。分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。

![image-20221022183526516](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183526516.png)

**Consistency（一致性）**：数据一致更新，所有数据的变化都是同步的

**Availability（可用性）**：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求

**Partition tolerance（分区容忍性）**：某个节点的故障，并不影响整个系统的运行

> 通过学习CAP理论，我们得知任何分布式系统只可同时满足二点，没法三者兼顾，既然一个分布式系统无法同时满足一致性、可用性、分区容错性三个特点，所以我们就需要抛弃一样：
>
> ![image-20221022183625865](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022183625865.png)

| 选择 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| CA   | 放弃分区容错性，加强一致性和可用性，其实就是传统的关系型数据库的选择 |
| AP   | 放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此 |
| CP   | 放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用 |

需要明确一点的是，在一个分布式系统当中，分区容忍性和可用性是最基本的需求，所以在分布是系统中，我们的系统最当关注的就是A（可用性）P（容忍性），通过补偿的机制寻求数据的一致性

### 常见微服务框架

SpringCloud、ServiceComb、ZeroC ICE

#### 微服务中的相关概念

##### 服务注册与发现

**服务注册**：服务实例将自身服务信息注册到注册中心。这部分服务信息包括服务所在主机IP和提供服务的Port，以及暴露服务自身状态以及访问协议等信息。

**服务发现**：服务实例请求注册中心获取所依赖服务信息。服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。

![image-20221104000810699](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104000810699.png)

##### 负载均衡

负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。

![image-20221104000850657](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104000850657.png)

##### 熔断

**熔断**这一概念来源于电子工程中的断路器（Circuit Breaker）。在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。

![image-20221104000927961](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104000927961.png)

##### 链路追踪

随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。因此，就需要对一次请求涉及的多个服务链路进行日志记录，性能监控即**链路追踪**

![image-20221104000959599](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104000959599.png)

##### API网关

随着微服务的不断增多，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信可能出现：

- 客户端需要调用不同的url地址，增加难度

- 在一定的场景下，存在跨域请求的问题

- 每个微服务都需要进行单独的身份认证

针对这些问题，API网关顺势而生。

**API网关**直面意思是将所有API调用统一接入到API网关层，由网关层统一接入和输出。一个网关的基本功能有：统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力。有了网关之后，各个API服务提供团队可以专注于自己的的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。

![image-20221104001201911](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104001201911.png)

#### SpringCloud介绍

![image-20221022184638558](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022184638558.png)

Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如**服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控**等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。

#### SpringCloud核心组件

**Spring Cloud**的本质是在 Spring Boot 的基础上，增加了一堆微服务相关的规范，并对应用上下文（Application Context）进行了功能增强。既然 Spring Cloud 是规范，那么就需要去实现，目前Spring Cloud 规范已有 Spring官方，Spring Cloud Netflflix，Spring Cloud Alibaba等实现。通过组件化的方式，Spring Cloud将这些实现整合到一起构成全家桶式的微服务技术栈。

###### SpringCloud Netflix

| 组件名称 | 作用           |
| -------- | -------------- |
| Eureka   | 服务注册中心   |
| Ribbon   | 客户端负载均衡 |
| Feign    | 声明式服务调用 |
| Hystrix  | 客户端容错保护 |
| Zuul     | API服务网关    |

###### SpringCloud Alibaba

| 组件名称 | 作用           |
| -------- | -------------- |
| Nacos    | 服务注册中心   |
| Sentinel | 客户端容错保护 |

###### SpringCloud原生及其他组件：

| 组件          | 作用           |
| ------------- | -------------- |
| Consul        | 服务注册中心   |
| Config        | 分布式配置中心 |
| Gateway       | API服务网关    |
| Sleuth/Zipkin | 分布式链路追踪 |

#### SpringCloud体系结构

![image-20221022184937835](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022184937835.png)

从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。

- **注册中心**负责服务的注册与发现，很好将各服务连接起来

- **断路器**负责监控服务之间的调用情况，连续多次失败进行熔断保护。

- **API网关**负责转发所有对外的请求和服务

- **配置中心**提供了统一的配置信息管理服务,可以实时的通知各个服务获取最新的配置信息**链路追踪技术**可以将所有的请求数据记录下来，方便我们进行后续分析

- 各个组件又提供了功能完善的**dashboard监控平台**,可以方便的监控各组件的运行状况

#### 模拟微服务存在的问题

![image-20221022185050581](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022185050581.png)

1. 将微服务的请求路径硬编码到Java代码中
2. 对微服务调用的负载均衡
3. 加入API网关
4. 配置的统一管理
5. 链路追踪：方便定位可能出现的问题

## 注册中心

### 概述

在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，到这里找到服务的地址，进行调用。

![image-20221022185117179](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022185117179.png)

### 主要作用

1. 服务发现：

   - 服务注册/反注册：保存服务提供者和服务调用者的信息

   - 服务订阅/取消订阅：服务调用者订阅服务提供者的信息，最好有实时推送的功能

   - 服务路由（可选）：具有筛选整合服务提供者的能力。

2. 服务配置：

   - 配置订阅：服务提供者和服务调用者订阅微服务相关的配置

   - 配置下发：主动将配置推送给服务提供者和服务调用者

3. 服务健康检测
   - 检测服务提供者的健康情况

### 常见的注册中心

- zookeeper
- eureka
- consul
- Nacos

| 组件名    | 语言 | CAP  | 一致性算法 | 服务健康检查 | 对外暴露接口 |
| --------- | ---- | ---- | ---------- | ------------ | ------------ |
| Eureka    | Java | AP   | 无         | 可配支持     | HTTP         |
| Consul    |      | CP   | Raft       | 支持         | HTTP/DNS     |
| Zookeeper | Java | CP   | Paxos      | 支持         | 客户端       |
| Nacos     | Java | AP   | Raft       | 支持         | HTTP         |

## Eureka

### 概述

Eureka是Netflflix开发的服务发现框架，SpringCloud将它集成在自己的子项目spring-cloud-netflix中，实现SpringCloud的服务发现功能。

![image-20221022185246611](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022185246611.png)

上图简要描述了Eureka的基本架构，由3个角色组成：

1. Eureka Server

​		提供服务注册和发现

2. Service Provider

​		服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到

3. Service Consumer

​		服务消费方从Eureka获取注册服务列表，从而能够消费服务

### Eureka的交互与原理

![image-20221104001904331](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104001904331.png)

图是来自Eureka官方的架构图，大致描述了Eureka集群的工作过程。图中包含的组件非常多，可能比较难以理解，我们用通俗易懂的语言解释一下：

- Application Service 相当于本书中的服务提供者，Application Client相当于服务消费者；
- Make Remote Call，可以简单理解为调用RESTful API；
- us-east-1c、us-east-1d等都是zone，它们都属于us-east-1这个region；

**由图可知，Eureka包含两个组件：Eureka Server和Eureka Client，它们的作用如下：**

- Eureka Client是一个Java客户端，用于简化与Eureka Server的交互；

- Eureka Server提供服务发现的能力，各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如网络信息），Eureka Server会存储该服务的信息；

- 微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为30秒）以续约自己的信息。如果Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（默认90秒）；

- 每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过复制的方式完成服务注册表的同步；

- Eureka Client会缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。

综上，Eureka通过心跳检测、健康检查和客户端缓存等机制，提高了系统的灵活性、可伸缩性和可用性。

### 使用步骤

1. **搭建eureka server**

   1.1 创建工程并导入坐标

   ```xml
<dependencies>
       <dependency>
        <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
       </dependency>
   </dependencies>
   ```
   
   1.2 配置application.yml
   
   ```yml
spring:
     application:
    name: eureka-server
   server:
     port: 8761 #端口
   #配置eureka server
   eureka:
     client:
       register-with-eureka: false 	#是否将自己注册到注册中心
       fetch-registry: false 			#是否从eureka中获取注册信息
       service-url: 					#配置暴露给Eureka Client的请求地址
         defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
   ```
   
   1.3 配置启动类
   
   ```java
@SpringBootApplication
   @EnableEurekaServer //激活eurekaserver
public class EurekaServerApplication {
       public static void main(String[] args) {
           SpringApplication.run(EurekaServerApplication.class,args);
       }
   }
   ```
   
   1.4 **服务注册中心管理后台**
   
   打开浏览器访问http://localhost:8761即可进入EurekaServer内置的管理控制台，显示效果如下

   ![image-20221104002357554](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104002357554.png)

2. **将服务提供者注册到eureka server上**

   2.1 引入Eureka Client相应坐标

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-client</artxmlifactId>
   </dependency>
   ```

   2.2 修改application.yml添加eureka server相关信息

   在工程的`application.yml`中添加Eureka Server的主机地址

   ```yml
   #配置Eureka
   eureka:
     client:
       service-url:
         defaultZone: http://localhost:8761/eureka/
     instance:
       prefer-ip-address: true #使用ip地址注册
   ```

   2.3 修改启动类，添加服务发现的支持（可选）

   > 从Spring Cloud Edgware版本开始， `@EnableDiscoveryClient` 或 `@EnableEurekaClient` **可省略**。只需加上相关依赖，并进行相应配置，即可将微服务注册到服务发现组件上

3. **服务消费者通过注册中心获取服务列表并调用**

   Eureka中的原数据：服务的主机名，ip，等信息，可以通过eureka server进行获取，用于服务之间的调用注入DiscoveryClient，通过discoveryClient.getInstances("服务名")，可以拿到client的元数据。

   ```Java
   /**
    * 注入DiscoveryClient :
    *  springcloud提供的获取原数组的工具类
    *      调用方法获取服务的元数据信息
    */
   @Autowired
   private DiscoveryClient discoveryClient;
   
   @RequestMapping(value = "/buy/{id}",method = RequestMethod.GET)
   public Product findById(@PathVariable Long id) {
      // 调用discoveryClient方法
      //已调用服务名称获取所有的元数据
      List<ServiceInstance> instances = discoveryClient.getInstances("service-product");
      //获取唯一的一个元数据
      ServiceInstance instance = instances.get(0);
      //根据元数据中的主机地址和端口号拼接请求微服务的URL
      Product product = null;
      //如何调用商品服务?
      product = restTemplate.getForObject("http://"+instance.getHost()+":"+instance.getPort()+"/product/1",Product.class);
      return product;
   }
   ```


### Eureka Server的高可用

![image-20221022185611489](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022185611489.png)

1. **准备两个Eureka Server，需要互相注册**

   1号server：9000

   ```yml
   #模拟两个EurekaServer
   #端口9000 , 8000
   #两个server需要相互注册
   spring:
     application:
       name: eureka-server
   server:
     port: 9000 #端口
   #配置eureka server
   eureka:
     client:
       service-url: #配置暴露给Eureka Client的请求地址
         defaultZone: http://127.0.0.1:8000/eureka/
   ```

   2号server：8000

   ```yml
   #模拟两个EurekaServer
   #端口9000 , 8000
   #两个server需要相互注册
   spring:
     application:
       name: eureka-server
   server:
     port: 8000 #端口
   #配置eureka server
   eureka:
     client:
       service-url: #配置暴露给Eureka Client的请求地址
         defaultZone: http://127.0.0.1:9000/eureka/
   ```

2. 需要将微服务注册到两个EurekaServer上

​		如果需要将微服务注册到Eureka Server集群只需要修改yml配置文件即可

```yml
eureka:
 client:
   serviceUrl:
     defaultZone: http://eureka-server:8000/eureka/,http://eureka-server:9000/eureka/
```

### 细节问题

1. 在控制台显示服务IP

   在服务提供者，通过`eureka.instance.instance-id`配置

2. 服务的剔除问题

   默认情况下，由于Eureka Server剔除失效服务间隔时间为90s且存在自我保护的机制。所以不能有效而迅速的剔除失效节点，这对开发或测试会造成困扰。解决方案如下：

   **Eureka Client**：

   配置开启健康检查，并设置续约时间

   ```yml
   # 客户端配置Eureka
   eureka:
     client:
     	healthcheck: true  #开启健康检查(依赖spring-boot-actuator)
       service-url:
         defaultZone: http://localhost:9000/eureka/ #,http://localhost:8000/eureka/ 多个注册
     instance:
       prefer-ip-address: true #使用ip地址注册
       instance-id: ${eureka.instance.prefer-ip-address}:${server.port} #向注册中心中注册服务id
       lease-renewal-interval-in-seconds: 5 #发送心跳的间隔
       lease-expiration-duration-in-seconds: 10 #续约到期时间
   ```

   **Eureka Server**：

   配置关闭自我保护，设置剔除无效节点的时间间隔

   ```yml
   eureka:
     server:
       enable-self-preservation: false # 关闭自我保护机制
       eviction-interval-timer-in-ms: 4000 #剔除服务间隔
   ```

3. Eureka的自我保护机制

   在测试阶段，为了效率更高，通过`enable-self-preservation`和`eviction-interval-timer-in-ms`，关闭自我保护机制。

   > 在eureka中，如果统计发现在15分钟之内，没有收到85%以上的客户端的心跳，就不会再对服务进行剔除了。
   >
   > 暂时把这些失效的服务保护起来，不让其过期，但这些服务也并不是永远不会过期。
   >
   > Eureka在启动完成后，每隔60秒会检查一次服务健康状态，如果这些被保护起来失效的服务过一段时间后（默认90秒）还是没有恢复，就会把这些服务剔除。如果在此期间服务恢复了并且实例心跳占比高于85%时，就会自动关闭自我保护机制。

### 源码

1. 启动项目，通过`@SpringBootApplication`注解找到`@EnableAutoConfiguration`注解

   ↓

2. 再找到`@Import({AutoConfigurationImportSelector.class})`注解

   ↓

3. 找到`AutoConfigurationImportSelector`类中的`selectImports()`方法，该方法不但读取了所有外部配置类，也可以读取自定义注解上自定义的配置类。

   ↓

4. 方法中调用了`this.getAutoConfigurationEntry(annotationMetadata)`方法

   ↓

5. 再进入`this.getCandidateConfigurations(annotationMetadata, attributes)`中

   ↓

6. 通过`SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())`加载所有的外部配置类

   ↓

7. 在`loadSpringFactories()`方法中`classLoader.getResources("META-INF/spring.factories")`加载所有的SpringBoot外部配置类

   ↓

8. spring.factories文件中，前面是map的key，后面是value，当使用注解@key，就会自动加载value类。

#### spring.factory -> EurekaServerAutoConfiguration.class

1. 配合页面完成控制台相关功能

```java
// 程序启动，创建Controller对象
@Bean
@ConditionalOnProperty(
    prefix = "eureka.dashboard",
    name = {"enabled"},
    matchIfMissing = true
)
public EurekaController eurekaController() {
    return new EurekaController(this.applicationInfoManager);
}
```
2. 发布web接口，让EurekaClient调用

```java
@Bean
public Application jerseyApplication(Environment environment, ResourceLoader resourceLoader) {
        String[] var5 = EUREKA_PACKAGES;
    }
```

↓ 扫描@Path @Provider

```java
private static final String[] EUREKA_PACKAGES = new String[]{"com.netflix.discovery", "com.netflix.eureka"};
```

#### spring.factory -> EurekaClientAutoConfiguration.class

1. 向server准备好的接口发送请求，完成发现，注册等操作。

```java
@Bean
public DiscoveryClient discoveryClient(EurekaInstanceConfig config, EurekaClient client) {
    return new EurekaDiscoveryClient(config, client);
}
```

## Ribbon

> 多个微服务的提供者该如何选择，如何负载均衡。

### 概述

Ribbon是Netfilx发布的一个负载均衡器，有助于控制HTTP和TCP客户端行为。在SpringCloud中，Eureka一般配合Ribbon进行使用，Ribbon提供了客户端负载均衡的功能，Ribbon利用从Eureka中读取到的服务信息，在调用服务节点提供的服务时，会合理的进行负载。

在SpringCloud中可以将注册中心和Ribbon配合使用，Ribbon自动的从注册中心中获取服务提供者的列表信息，并基于内置的负载均衡算法，请求服务。

![image-20221022190258923](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022190258923.png)

### 客户端负载均衡与服务端负载均衡

**服务端负载均衡**

先发送请求到负载均衡服务器或者软件，然后通过负载均衡算法，在多个服务器之间选择一个进行访

问；即在服务器端再进行负载均衡算法分配

**客户端负载均衡**

客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择一个服务器，然后进行访问，这

是客户端负载均衡；即在客户端就进行负载均衡算法分配

### 主要作用

**（1）服务调用**

eureka内部集成了ribbon

- 在创建RestTemplate时，声明@LoadBalanced

- 使用RestTemplate调用远程微服务：不需要去拼接微服务的URL，以待请求的服务名替换IP地址

  ```Java
  @LoadBalanced
  @Bean
  public RestTemplate restTemplate(){
  	return new RestTemplate();
  }
  
  @RequestMapping(value = "/buy/{id}",method = RequestMethod.GET)
  public Product findById(@PathVariable Long id) {
     Product product = null;
     product = restTemplate.getForObject("http://service-product/product/1",Product.class);
     return product;
  }
  ```

**（2）负载均衡**

Ribbon是一个典型的客户端负载均衡器（在发送请求之前就知道要发送到哪个地址），Ribbon会获取服务的所有地址，根据内部的负载均衡算法，获取本次请求的有效地址。

**（3）重试机制**

引入Spring的重试组件

```xml
<dependency>
	<groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
```

```yml
# 修改ribbon负载均衡策略 服务名 - ribbon - NFLoadBalancerRuleClassName ：策略
service-product:
  ribbon:
    ConnectTimeout: 250 # Ribbon的连接超时时间（如果消费对服务A创建HTTP连接的时间达到250ms没有响应，就会访问服务B）
    ReadTimeout: 1000 # Ribbon的数据读取超时时间（连接好了以后获取数据的时间超过1s，重试）
    OkToRetryOnAllOperations: true # 是否对所有操作都进行重试
    MaxAutoRetriesNextServer: 1 # 切换实例的重试次数
    MaxAutoRetries: 1 # 对当前实例的重试次数
```



### 负载均衡策略

> 准备两个商品微服务（9001，9011），在订单系统中，远程以负载均衡的形式调用商品服务。

**默认：轮询策略**

策略选择：

1. 如果每个机器配置一样，则建议不修改策略（推荐）
2. 如果部分机器配置强，则可以改为WeightedResponseTimeRule

```yml
# 修改ribbon负载均衡策略 服务名 - ribbon - NFLoadBalancerRuleClassName ：策略
service-product:
  ribbon:
    NFLoadBanlancerRuleClassName: com.netfilx.loadbalancer.RandomRule	# 轮询
```

### 源码

#### spring.factory -> RibbonAutoConfiguration.class

1. 程序启动，在加载该类之前加载`LoadBalancerAutoConfiguration`这个类

   ```java
   @AutoConfigureBefore({LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class})
   public class RibbonAutoConfiguration {}
   ```

2. 向RestTemplate中添加请求拦截器

   ```java
   @Bean
   @ConditionalOnMissingBean
   public RestTemplateCustomizer restTemplateCustomizer(final RetryLoadBalancerInterceptor loadBalancerInterceptor) {
       return (restTemplate) -> {
           List<ClientHttpRequestInterceptor> list = new ArrayList(restTemplate.getInterceptors());
           list.add(loadBalancerInterceptor);
           restTemplate.setInterceptors(list);
       };
   }
   ```

3. 发送请求时，会执行`LoadBalancerInterceptor`中的`intercept`方法

   ```java
   // 当发送一个请求时，会进入下面的方法中
   restTemplate.getForObject("http://service-product/product/1",Product.class);
   ```

   ```java
   public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException {
           URI originalUri = request.getURI();
           String serviceName = originalUri.getHost();
           Assert.state(serviceName != null, "Request URI does not contain a valid hostname: " + originalUri);
       	// 执行该行方法
           return (ClientHttpResponse)this.loadBalancer.execute(serviceName, this.requestFactory.createRequest(request, body, execution));
   }
   ```

4. 执行`loadBalancer.execute`方法

   ```java
   public <T> T execute(String serviceId, LoadBalancerRequest<T> request) throws IOException {
       	// ILoadBalancer是一个负载均衡器（这里挂载了很多负载均衡算法）
           ILoadBalancer loadBalancer = this.getLoadBalancer(serviceId);
       	// 通过getServer获取到要请求的地址
           Server server = this.getServer(loadBalancer);
           if (server == null) {
               throw new IllegalStateException("No instances available for " + serviceId);
           } else {
               RibbonLoadBalancerClient.RibbonServer ribbonServer = new RibbonLoadBalancerClient.RibbonServer(serviceId, server, this.isSecure(server, serviceId), this.serverIntrospector(serviceId).getMetadata(server));
               return this.execute(serviceId, ribbonServer, request);
           }
   }
   ```

## Consul

### 概述

Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服 务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。 使用起来也较为简单。Consul 使用 Go 语言编写，因此具有天然可移植性（支持Linux、windows和 Mac OS X）；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。

### Consul的优势

- 使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是Paxos, 而 etcd 使用的则是 Raft。

  > http://thesecretlivesofdata.com/raft/ RAFT算法动态演示

- 支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持。

- 支持健康检查。 etcd 不提供此功能。

- 支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持 http 协议。

- 官方提供 web 管理界面, etcd 无此功能。

综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究。

### 特性

- 服务发现

- 健康检查

- Key/Value 存储

- 多数据中心

### consul与Eureka的区别

**（1）一致性**

Consul强一致性（CP）

- 服务注册相比Eureka会稍慢一些。因为Consul的raft协议要求必须过半数的节点都写入成功才认为注册成功
- Leader挂掉时，重新选举期间整个consul不可用。保证了强一致性但牺牲了可用性。

Eureka保证高可用和最终一致性（AP）

- 服务注册相对要快，因为不需要等注册信息replicate到其他节点，也不保证注册信息是否 replicate成功
- 当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性。

**（2）开发语言和使用**

- eureka就是个servlet程序，跑在servlet容器中
- Consul则是go编写而成，安装启动即可

### consul的下载与安装

> [consul官方网站](https://www.consul.io/)

进入安装目录

```shell
##以开发者模式启动
consul agent -dev -client=0.0.0.0
```

web平台：127.0.0.1:8500

### consul的基本使用

（1）服务注册

（2）服务查询

（3）服务删除

### 入门案例

- 提供一个商品微服务
- 一共一个订单系统

#### 将微服务注册到注册中心consul

依赖

```xml
<!--springcloud 提供的对基于consul的服务发现-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency>

<!--actuator的健康检查-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

配置

```yml
###开始配置consul的服务注册
spring:
  cloud:
    consul:
      host: 127.0.0.1 #consul服务器的主机地址
      port: 8500 #consul服务器的端口
      discovery:
        #是否需要注册
        register: true
        #注册的实例ID (唯一标志)
        instance-id: ${spring.application.name}-1
        #服务的名称
        service-name: ${spring.application.name}
        #服务的请求端口
        port: ${server.port}
        #指定开启ip地址注册
        prefer-ip-address: true
        #当前服务的请求ip
        ip-address: ${spring.cloud.client.ip-address}
```

#### 服务的消费者从consul中拉取所有的服务列表

消费者配置同上

### consul高可用集群

![image-20221021001215507](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221021001215507.png)

### consul集群搭建

**（1）准备环境**

| 服务器ip       | consul类型 | Node（节点名称） | 序号 |
| -------------- | ---------- | ---------------- | ---- |
| 192.168.74.101 | server     | server-1         | s1   |
| 192.168.74.102 | server     | server-2         | s2   |
| 192.168.74.103 | server     | server-3         | s3   |
| 192.168.71.1   | client     | clent-1          | s4   |

- Agent 以 client 模式启动的节点。在该模式下，该节点会采集相关信息，通过 RPC 的方式向 server 发送。Client模式节点有无数个，官方建议搭配微服务配置
- Agent 以 server 模式启动的节点。一个数据中心中至少包含 1 个 server 节点。不过官方建议使用 3 或 5 个 server 节点组建成集群，以保证高可用且不失效率。server 节点参与 Raft、维护会员信 息、注册服务、健康检查等功能。

**（2）安装consul并启动**

在每个consul节点上安装consul服务，下载安装过程和单节点一致。

```shell
##从官网下载最新版本的Consul服务
wget https://releases.hashicorp.com/consul/1.5.3/consul_1.5.3_linux_amd64.zip
##使用unzip命令解压
unzip consul_1.5.3_linux_amd64.zip
##将解压好的consul可执行命令拷贝到/usr/local/bin目录下
cp consul /usr/local/bin
##测试一下
consul
```

启动每个consul server节点

```shell
##登录s1虚拟机，以server形式运行
consul agent -server -bootstrap-expect 3 -data-dir /etc/consul.d -node=server-1 
-bind=192.168.74.101 -ui -client 0.0.0.0 &
##登录s2 虚拟机，以server形式运行
consul agent -server -bootstrap-expect 2 -data-dir /etc/consul.d -node=server-2 
-bind=192.168.74.102 -ui -client 0.0.0.0 & 
##登录s3 虚拟机，以server形式运行
consul agent -server -bootstrap-expect 2 -data-dir /etc/consul.d -node=server-3 
-bind=192.168.74.103 -ui -client 0.0.0.0 & 
```

> -server：以server身份启动
>
> -bootstrap-expect：集群要求的最少server数量，当低于这个数量，集群即失效。
>
> -data-dir：data存放的目录，更多信息请参阅consul数据同步机制。
>
> -node：节点id，在同一集群不能重复
>
> -bind：监听的ip地址
>
> -client：客户端的ip地址（0.0.0.0表示不限制）
>
> &：在后台运行，此为linux脚本语法

至此三个Consul Server模式服务全部启动成功

```shell
##在本地电脑中使用client形式启动consul
consul agent -client=0.0.0.0 -bind=192.xx.xx.xx -data-dir /etc/consul.d -node=client-1
```

**（3）每个节点加入集群**

在s2，s3，s4 服务其上通过consul join 命令加入 s1中的consul集群中

```shell
##加入consul集群
consul join 192.168.74.101
```

**（4） 测试**

在任意一台服务器中输入 consul members查看集群中的所有节点信息

```shell
##查看consul集群节点信息
consul members
```

![登录任意一台服务器的UI界面](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221021002433112.png)

### consul常见问题

**（1）节点和服务注销**

当服务或者节点失效． Consul 不会对注册的信息进行剔除处理，仅仅标记已状态进行标记（并且不可使用 ） 。如果担心失效节点和失效服务过多影晌监控。可以通过调用 HTTP API 的形式进行

处理节点和服务的注销可以使用HTTP API：

- 注销任意节点和服务： /catalog/deregister
- 注梢当前节点的服务： /agent/service/deregister/service _ id

如果某个节点不继续使用了，也可以在本机使用 consul leave命令，或者在其它节点使用 consul force -leave 节点id。

**（2）健康检查与故障转移**

在集群环境下，键康检查是由服务注册到的Agent 来处理的，那么如果这个Agent挂掉了，那么此节点的健康检查就处于无人管理的状态。

从实际应用，节点上的服务可能既要被发现，又要发现别的服务．如果节点挂掉了，仅提供被发现的功能实际上服务还是不可用的。当然发现别的服务也可以不使用本机节点，可以通过访问一个 Nginx 实现的若干 Consul 节点的负载均衡来实现．

## Feign

### 简介

Feign是Netflix开发的声明式，模板化的HTTP客户端，其灵感来自RetrofitJAXRS20以及WebSocket.

- Feign可帮助我们更加便捷，优雅的调用HTTP API。

- 在SpringCloud中，使用Feign非常简单一一创建一个接口，并在接口上添加一些注解，代码就完 

成了。

- Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等。

- SpringCloud对Feign进行了增强，使Feign支持了SpringMVC注解，并整合了Ribbon和Eureka , 

从而让Feign的使用更加方便。

### Feign和Ribbon的联系

**Ribbon**是一个基于 HTTP 和 TCP **客户端** 的负载均衡的工具。它可以 **在客户端** 配置RibbonServerList（服务端列表），使用 HttpClient 或 RestTemplate 模拟http请求，步骤相当繁琐。

**Feign** 是在 Ribbon的基础上进行了一次改进，是一个使用起来更加方便的 HTTP 客户端。采用接口的方式， 只需要创建一个接口，然后在上面添加注解即可 ，将需要调用的其他服务的方法定义成抽象方法即可， 不需要自己构建http请求。然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写客户端变得非常容易

### 组件入门

1. 导入依赖

```xml
<!--springcloud整合的openFeign-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

2. 配置调用接口

```java
/**
 * 声明需要调用的微服务名称
 *  @FeignClient
 *      * name : 服务提供者的名称
 */
@FeignClient(name="service-product")
public interface ProductFeignClient {
 
    /**
     * 配置需要调用的微服务接口
     */
    @RequestMapping(value="/product/{id}",method = RequestMethod.GET)
    public Product findById(@PathVariable("id") Long id);
}
```

3. 在启动类上激活feign

```java
@SpringBootApplication
@EntityScan("cn.itcast.order.entity")
//激活Feign
@EnableFeignClients
public class OrderApplication {}
```

4. 通过自动的接口调用远程微服务

```java
@RestController
@RequestMapping("/order")
public class OrderController {
 
    @Autowired
    private ProductFeignClient productFeignClient;
 
    /**
     */
    @RequestMapping(value = "/buy/{id}",method = RequestMethod.GET)
    public Product findById(@PathVariable Long id) {
        Product product = null;
        product = productFeignClient.findById(id);
        return product;
    }
 
}
```

### Feign的配置

从Spring Cloud Edgware开始，Feign支持使用属性自定义Feign。对于一个指定名称的Feign Client（例如该Feign Client的名称为 feignName ），Feign支持如下配置项：

```yaml
feign:
    client:
        config:
            feignName: ##定义FeginClient的名称
                connectTimeout: 5000 # 相当于Request.Options
                readTimeout: 5000 # 相当于Request.Options
                # 配置Feign的日志级别，相当于代码配置方式中的Logger
                loggerLevel: full
                # Feign的错误解码器，相当于代码配置方式中的ErrorDecoder
                errorDecoder: com.example.SimpleErrorDecoder
                # 配置重试，相当于代码配置方式中的Retryer
                retryer: com.example.SimpleRetryer
                # 配置拦截器，相当于代码配置方式中的RequestInterceptor
                requestInterceptors:
                    - com.example.FooRequestInterceptor
                    - com.example.BarRequestInterceptor
                decode404: false
 
```

- feignName：FeginClient的名称
- connectTimeout ： 建立链接的超时时长
- readTimeout ： 读取超时时长
- loggerLevel: Fegin的日志级别
- errorDecoder ：Feign的错误解码器
- retryer ： 配置重试
- requestInterceptors ： 添加请求拦截器
- decode404 ： 配置熔断不处理404异常

### 日志打印

order_service中配置

```yaml
# 日志配置
# NONE：不输出日志
# BASIC：适用于生产环境追踪问题
# HEADERS：在BASIC的基础上，记录请求和响应头信息
# FULL：记录所有
feign:
  client:
    config:
      service-product:
        loggerLevel: FULL
logging:
  level:
    cn.itcast.order.fegin.ProductFeginClient: debug
```

### 源码

1. `@EnableFeignClients`注解

```
@EnableFeignClients
```

2. FeignClientsRegistra类中的registerBeanDefinitions()方法中的registerFeignClients()方法

```java
public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
    this.registerDefaultConfiguration(metadata, registry);
    this.registerFeignClients(metadata, registry);
}
```

3. registerFeignClients()方法

```java
public void registerFeignClients(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
    // AnnotationTypeFilter会找到项目中哪里用到了@FeignClient这个注解
	scanner.addIncludeFilter(new AnnotationTypeFilter(FeignClient.class));
    // 这里完成相关注册工作，注册到Spring当中
    this.registerFeignClient(registry, annotationMetadata, attributes);
}
```

4. registerFeignClient()方法

```java
private void registerFeignClient(BeanDefinitionRegistry registry, AnnotationMetadata annotationMetadata, Map<String, Object> attributes) {
        String contextId = this.getContextId(beanFactory, attributes);
        String name = this.getName(attributes);
        FeignClientFactoryBean factoryBean = new FeignClientFactoryBean();
        factoryBean.setBeanFactory(beanFactory);
        factoryBean.setName(name);
        factoryBean.setContextId(contextId);
        factoryBean.setType(clazz);
    	// 创建FeignClientFactoryBean对象，并设置它的一些属性
        BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(clazz, () -> {
            factoryBean.setUrl(this.getUrl(beanFactory, attributes));
            factoryBean.setPath(this.getPath(beanFactory, attributes));
            factoryBean.setDecode404(Boolean.parseBoolean(String.valueOf(attributes.get("decode404"))));
            Object fallback = attributes.get("fallback");
            if (fallback != null) {
                factoryBean.setFallback(fallback instanceof Class ? (Class)fallback : ClassUtils.resolveClassName(fallback.toString(), (ClassLoader)null));
            }

            Object fallbackFactory = attributes.get("fallbackFactory");
            if (fallbackFactory != null) {
                factoryBean.setFallbackFactory(fallbackFactory instanceof Class ? (Class)fallbackFactory : ClassUtils.resolveClassName(fallbackFactory.toString(), (ClassLoader)null));
            }

            return factoryBean.getObject();
        });
		// 把FeignClientFactoryBean注册到Spring容器当中
        BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className, new String[]{alias});
        BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);
    }
```

5. 再看FeignClientFactoryBean类

```java
// 这个类实现了FactoryBean接口，实现了getObject()方法
public class FeignClientFactoryBean implements FactoryBean<Object>

public Object getObject() {
    return this.getTarget();
}

// 方法中调用了getTarget()方法
<T> T getTarget() {
    return targeter.target(this, builder, context, new HardCodedTarget(this.type, this.name, url));
	}
}

// targeter.target开始着手去创建对象
public <T> T target(FeignClientFactoryBean factory, Builder feign, FeignContext context, HardCodedTarget<T> target) {
    return feign.target(target);
}

public <T> T target(Target<T> target) {
    return this.build().newInstance(target);
}

public <T> T newInstance(Target<T> target) {
    InvocationHandler handler = this.factory.create(target, methodToHandler);
}
// 到最后创建了标注了@FeignClinet接口的动态代理对象FeignInvocationHandler
public InvocationHandler create(Target target, Map<Method, InvocationHandlerFactory.MethodHandler> dispatch) {
    return new FeignInvocationHandler(target, dispatch);
}

// 实际上，下面调用findById()方法是productFeignClient的实现类执行的
	@Autowired
    private ProductFeignClient productFeignClient;
 
    /**
     */
    @RequestMapping(value = "/buy/{id}",method = RequestMethod.GET)
    public Product findById(@PathVariable Long id) {
        Product product = null;
        product = productFeignClient.findById(id);
        return product;
    }
```

## 微服务架构的高并发问题

### 性能工具Jmeter

#### 使用步骤

1. 官网下载解压

![image-20221022170835776](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022170835776.png)

2. 找到`bin`目录下的`jmeter.bat`双击运行

   ![image-20221022170942820](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022170942820.png)

3. 点击新建->创建测试计划->测试计划上右键->添加->Threads->线程组

![image-20221022171147208](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022171147208.png)

4. 线程组右键->添加->Sampler->HTTP请求

   ![image-20221022171246755](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022171246755.png)

5. 填写接口信息

   ![image-20221022171402411](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20221022171402411.png)

6. 在HTTP请求上添加结果树查看结果

   ![image-20221022171443299](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022171443299.png)

7. 设置线程数量

   ![image-20221022171605690](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022171605690.png)

8. 点击三角运行，去结果树查看结果

   ![image-20221022171649676](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20221022171649676.png)

### 系统负载过高存在的问题

#### 问题分析

在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，由于网络原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务累计，导致服务瘫痪。

在SpringBoot程序中，默认使用内置tomcat作为web服务器。单tomcat支持最大的并发请求是有限的，如果某一接口阻塞，待执行的任务积压越来越多，那么势必会影响其他接口的调用。

![image-20221022172804967](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022172804967.png)

#### 解决方法

1. 线程池隔离

   为下单方法分配线程池A，线程池A中最多有5个线程运行。

   查询订单方法分配线程池B，线程池B中最多有4个线程运行。

2. 信号量隔离

   设置一个计数器，下单方法最大阈值为5，剩下的人再访问直接报错。（PV操作）

## Hystrix

### 服务容错的核心知识

#### 雪崩效应

在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问A服务，而A服务需要调用B服务，B服务需要调用C服务，由于网络原因或者自身的原因，如果B服务或者C服务不能及时响应，A服务将处于阻塞状态，直到B服务C服务响应。此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。

![image-20221022175420170](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022175420170.png)

雪崩是系统中的蝴蝶效应导致其发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法响应变慢，亦或是某台机器的资源耗尽。从源头上我们无法完全杜绝雪崩源头的发生，但是雪崩的根本原因来源于服务之间的强依赖，所以我们可以提前评估，做好**熔断，隔离，限流。**

#### 服务隔离

顾名思义，它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其它模块，不影响整体的系统服务。

#### 熔断降级

熔断这一概念来源于电子工程中的断路器（Circuit Breaker）。在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。

![image-20221022175514562](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022175514562.png)

所谓降级，就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。 也可以理解为兜底

#### 服务限流

限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳固运行，一旦达到的需要限制的阈值，就需要限制流量并采取少量措施以完成限制流量的目的。比方：推迟解决，拒绝解决，或者者部分拒绝解决等等。

### 对RestTemplate的支持

1. 引入hystrix的依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
```

2. 启动类中激活Hystrix

```java
@SpringBootApplication
//激活hystrix
@EnableCircuitBreaker
public class RestOrderApplication {}
```

3. 配置熔断触发的降级逻辑

```java
/**
 * 降级方法
 *  和需要收到保护的方法的返回值一致
 *  方法参数一致
 */
public Product orderFallBack(Long id) {
   Product product = new Product();
   product.setProductName("触发降级方法");
   return product;
}
```

4. 配置熔断触发的降级逻辑

```java
/**
 * 降级方法
 *  和需要收到保护的方法的返回值一致
 *  方法参数一致
 */
public Product orderFallBack(Long id) {
   Product product = new Product();
   product.setProductName("触发降级方法");
   return product;
}
```

5. 在需要保护的接口上使用@HystrixCommand配置

```java
/**
 * 使用注解配置熔断保护
 *     fallbackmethod : 配置熔断之后的降级方法
 */
@HystrixCommand(fallbackMethod = "orderFallBack")
@RequestMapping(value = "/buy/{id}",method = RequestMethod.GET)
public Product findById(@PathVariable Long id) {
   return restTemplate.getForObject("http://service-product/product/1",Product.class);
}
```

### 默认的Fallback

我们刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以我们可以把Fallback配置加在类上，实现默认fallback：

![image-20221022181642272](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221022181642272.png)

### 超时设置

在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值：

```yml
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000	#默认的连接超时时间1秒,若1秒没有返回数据,自动的触发降级逻辑
```

在规定时间内没有获取到微服务数据，将自动触发熔断降级的方法

### 对Feign的支持

1. 引入依赖（fegin中已经集成了Hystrix）

   SpringCloud Fegin默认已为Feign整合了hystrix，所以添加Feign依赖后就不用在添加hystrix

2. 在feign中配置开启Hystrix

```yml
#HEADERS : 在BASIC的基础上,记录请求和响应头信息   FULL : 记录所有
feign:
  #开启对hystrix的支持
  hystrix:
    enabled: true
```

3. 自定义一个接口实现方法，这个实现类就是熔断触发的降级逻辑

```java
@Component
public class ProductFeignClientCallBack implements ProductFeignClient {
 
   /**
    * 熔断降级的方法
    */
   public Product findById(Long id) {
      Product product = new Product();
      product.setProductName("feign调用触发熔断降级方法");
      return product;
   }
}
```

4. 修改feignClient接口添加降级方法的支持

```java
/**
 * 声明需要调用的微服务名称
 *  @FeignClient
 *      * name : 服务提供者的名称
 *      * fallback : 配置熔断发生降级方法
 *                  实现类
 */
@FeignClient(name="service-product",fallback = ProductFeignClientCallBack.class)
public interface ProductFeignClient {
 
   /**
    * 配置需要调用的微服务接口
    */
   @RequestMapping(value="/product/{id}",method = RequestMethod.GET)
   public Product findById(@PathVariable("id") Long id);
}
```

### Hystrix的监控平台

除了实现容错功能，Hystrix还提供了近乎实时的监控，HystrixCommand和HystrixObservableCommand在执行时，会生成执行结果和运行指标。比如每秒的请求数量，成功数量等。这些状态会暴露在Actuator提供的/health端点中。只需为项目添加 spring-boot-actuator 依赖，重启项目，访问http://localhost:9001/actuator/hystrix.stream ,即可看到实时的监控数据。

![image-20221023004314188](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023004314188.png)

#### Hystrix设置监控信息

1. 导入依赖

```xml
<!--引入hystrix的监控信息-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
</dependency>
```

2. 启动类上激活

```java
//激活hystrix
@EnableCircuitBreaker
public class FeignOrderApplication {}
```

3. 暴露所有actuator端点

```yml
management:
  endpoints:
    web:
      exposure:
        include: '*'
```

4. 在页面上访问

   http://localhost:9001/actuator/hystrix.stream

#### 搭建Hystrix DashBoard监控

1. 在上一步的步骤后添加EnableHystrixDashboard 注解

```java
@EnableHystrixDashboard
public class OrderApplication {}
```

2. 访问测试

   localhost:9001/hystrix

   ![image-20221023005851870](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023005851870.png)

3. 输入监控断点展示监控的详细数据

![image-20221023005901871](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023005901871.png)

**参数内容详解**

![image-20221023005937374](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023005937374.png)

#### 断路器聚合监控Turbine

在微服务架构体系中，每个服务都需要配置Hystrix DashBoard监控。如果每次只能查看单个实例的监控数据，就需要不断切换监控地址，这显然很不方便。要想看这个系统的Hystrix Dashboard数据就需要用到Hystrix Turbine。Turbine是一个聚合Hystrix 监控数据的工具，他可以将所有相关微服务的Hystrix 监控数据聚合到一起，方便使用。引入Turbine后，整个监控系统架构如下：

![image-20221023010621078](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023010621078.png)

1. 创建单独的工程
2. 引入依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-turbine</artifactId>
    </dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
</dependency>
```

3. 配置多个微服务的hystrix监控

在application.yml的配置文件中开启turbine并进行相关配置

```yml
server:
  port: 8031
spring:
  application:
    name: microservice-hystrix-turbine
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
    instance:
      prefer-ip-address: true
turbine:
  # 要监控的微服务列表，多个用,分隔
  appConfig: shop-service-order
  clusterNameExpression: "'default'"
```

- eureka相关配置 ： 指定注册中心地址

- turbine相关配置：指定需要监控的微服务列表

turbine会自动的从注册中心中获取需要监控的微服务，并聚合所有微服务中的 /hystrix.stream 数据

4. 配置启动类

```java
@SpringBootApplication
@EnableTurbine
@EnableHystrixDashboard
public class TurbineServerApplication {}
```

5. 测试

   浏览器访问 http://localhost:8031/hystrix 展示HystrixDashboard。并在url位置输入 http://local

   host:8031/turbine.stream，动态根据turbine.stream数据展示多个微服务的监控数据

![image-20221023010904611](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221023010904611.png)

#### 熔断器的状态

熔断器有三个状态 CLOSED 、 OPEN 、 HALF_OPEN 熔断器默认关闭状态，当触发熔断后状态变更为OPEN，在等待到指定的时间，Hystrix会放请求检测服务是否开启，这期间熔断器会变为 HALF_OPEN 半开启状态，熔断探测服务可用则继续变更为 CLOSED 关闭熔断器。

![image-20221025003024102](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221025003024102.png)

- Closed：关闭状态（断路器关闭），所有请求都正常访问。代理类维护了最近调用失败的次数，如果某次调用失败，则使失败次数加1。如果最近失败次数超过了在给定时间内允许失败的阈值，则代理类切换到断开(Open)状态。此时代理开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误。

- Open：打开状态（断路器打开），所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全关闭。默认失败比例的阈值是50%，请求次数最少不低于20次。

- Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放1次请求通过，若这个请求是健康的，则会关闭断路器，否则继续保持打开，再次进行5秒休眠计时

**熔断策略**

```properties
circuitBreaker.requestVolumeThreshold=5
circuitBreaker.sleepWindowInMilliseconds=10000
circuitBreaker.errorThresholdPercentage=50
```

> requestVolumeThreshold：触发熔断的最小请求次数，默认20
>
> errorThresholdPercentage：触发熔断的失败请求最小占比，默认50%
>
> sleepWindowInMilliseconds：熔断多少秒后去尝试请求

#### 熔断器的隔离策略

微服务使用Hystrix熔断器实现了服务的自动降级，让微服务具备自我保护的能力，提升了系统的稳定性，也较好的解决雪崩效应。**其使用方式目前支持两种策略：**

- **线程池隔离策略：**使用一个线程池来存储当前的请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求堆积入线程池队列。这种方式需要为每个依赖的服务申请线程池，有一定的资源消耗，好处是可以应对突发流量（流量洪峰来临时，处理不完可将数据存储到线程池队里慢慢处理）

- **信号量隔离策略：**使用一个原子计数器（或信号量）来记录当前有多少个线程在运行，请求来先判断计数器的数值，若超过设置的最大线程个数则丢弃改类型的新请求，若不超过则执行计数操作请求来计数器+1，请求返回计数器-1。这种方式是严格的控制线程且立即返回模式，无法应对突发流量（流量洪峰来临时，处理的线程超过数量，其他的请求会直接返回，不继续去请求依赖的服务）

## Sentinel

随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。Sentinel 具有以下特征:

- **丰富的应用场景**：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。

- **完备的实时监控**：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。

- **广泛的开源生态**：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 SpringCloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel。

- **完善的** **SPI** **扩展点**：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。

  ![image-20221025010345406](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221025010345406.png)

### Sentinel和Hystrix的区别

|                | **Sentinel**                                               | **Hystrix**             | **resilience4j**                 |
| -------------- | ---------------------------------------------------------- | ----------------------- | -------------------------------- |
| 隔离策略       | 信号量隔离（并发线程数限流）                               | 线程池隔离/信号量隔离   | 信号量隔离                       |
| 熔断降级策略   | 基于响应时间、异常比率、异常数                             | 基于异常比率            | 基于异常比率、响应时间           |
| 实时统计实现   | 滑动窗口（LeapArray）                                      | 滑动窗口（基于 RxJava） | Ring Bit Buffffer                |
| 动态规则配置   | 支持多种数据源                                             | 支持多种数据源          | 有限支持                         |
| 扩展性         | 多个扩展点                                                 | 插件的形式              | 接口的形式                       |
| 基于注解的支持 | 支持                                                       | 支持                    | 支持                             |
| 限流           | 基于 QPS，支持基于调用关系的限流                           | 有限的支持              | Rate Limiter                     |
| 流量整形       | 支持预热模式、匀速器模式、预热排队模式                     | 不支持                  | 简单的 Rate Limiter模式          |
| 系统自适应保护 | 支持                                                       | 不支持                  | 不支持                           |
| 控制台         | 提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等 | 简单的监控查看          | 不提供控制台，可对接其它监控系统 |

###  Sentinel中的管理控制台

1. **获取** **Sentinel** **控制台**

您可以从官方网站中下载最新版本的控制台 jar 包，下载地址如下：

https://github.com/alibaba/Sentinel/releases/download/1.6.3/sentinel-dashboard-1.6.3.jar

2. **启动**

使用如下命令启动控制台：

```shell
java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar
```

其中 `-Dserver.port=8080` 用于指定 Sentinel 控制台端口为 8080 。

从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的**登录**功能，默认用户名和密码都是 sentinel 。可以参考 鉴权模块文档 配置用户名和密码。

> 启动 Sentinel 控制台需要 JDK 版本为 1.8 及以上版本。

3. **客户端能接入控制台**

控制台启动后，客户端需要按照以下步骤接入到控制台。

4. **引入JAR包**

客户端需要引入 Transport 模块来与 Sentinel 控制台进行通信。可以通过 pom.xml 引入 JAR 包:

```xml
<dependency>
	<groupId>com.alibaba.csp</groupId>
	<artifactId>sentinel-transport-simple-http</artifactId>
</dependency>
```

5. **配置启动参数**

在工程的application.yml中添加Sentinel 控制台配置信息

```yml
spring:
  cloud:
	sentinel:
	  transport:
		dashboard: localhost:8080
```

这里的 `spring.cloud.sentinel.transport.dashboard` 配置控制台的请求路径。

6. **查看机器列表以及健康情况**

默认情况下Sentinel 会在客户端首次调用的时候进行初始化，开始向控制台发送心跳包。也可以配置`sentinel.eager=true `,取消Sentinel控制台懒加载。

打开浏览器即可展示Sentinel的管理控制台

![image-20221028014217812](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221028014217812.png)

### 基于Sentinel的服务保护

#### 通用资源保护

1. **引入依赖**

   父工程引入alibaba实现的SpringCloud

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-alibaba-dependencies</artifactId>
       <version>2.1.0.RELEASE</version>
       <type>pom</type>
       <scope>import</scope>
   </dependency>
   ```

   子工程中引入sentinel

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
   </dependency>
   ```

2. **配置熔断降级方法**

   ```java
   @GetMapping("/buy/{id}")
   @SentinelResource(value="order",blockHandler = "orderblockHandler",fallback= "orderfallback")
   public Product order(@PathVariable Long id) {
   	return restTemplate.getForObject("http://shop-serviceproduct/product/1", Product.class);
   }
   
   //降级方法
   public Product orderblockHandler(Long id) {
       Product product = new Product();
       product.setId(-1l);
       product.setProductName("触发熔断降级方法");
       return product;
   }
   
   //降级方法
   public Product orderfallback(Long id) {
       Product product = new Product();
       product.setId(-1l);
       product.setProductName("触发抛出异常方法");
       return product;
   }
   ```

##### Rest熔断方法

Spring Cloud Alibaba Sentinel 支持对 RestTemplate 的服务调用使用 Sentinel 进行保护，在构造`RestTemplate` bean的时候需要加上 `@SentinelRestTemplate` 注解。

```java
@Bean
@LoadBalanced
@SentinelRestTemplate(fallback = "handleFallback", fallbackClass = ExceptionUtil.class, blockHandler="handleBlock",blockHandlerClass=ExceptionUtil.class)
public RestTemplate getRestTemplate() {
	return new RestTemplate();
}
```

- @SentinelRestTemplate 注解的属性支持限流( blockHandler , blockHandlerClass )和降级( fallback , fallbackClass )的处理。
- 其中 blockHandler 或 fallback 属性对应的方法必须是对应 blockHandlerClass 或fallbackClass 属性中的静态方法。
- 该方法的参数跟返回值跟org.springframework.http.client.ClientHttpRequestInterceptor#interceptor 方法一致，其中参数多出了一个 BlockException 参数用于获取 Sentinel 捕获的异常。

**比如上述 @SentinelRestTemplate 注解中 ExceptionUtil 的 handleException 属性对应的方法声明如下：**

```java
/**
* 熔断降级
*/
public class ExceptionUtil {
    
	//限流熔断业务逻辑
	public static SentinelClientHttpResponse handleBlock(HttpRequest request,byte[] body,ClientHttpRequestExecution execution, lockException ex) {
    System.err.println("Oops: " + ex.getClass().getCanonicalName());
    return new SentinelClientHttpResponse("限流熔断降级");
	}
    
	//异常熔断业务逻辑
    public static SentinelClientHttpResponse handleFallback(HttpRequest request, byte[] body,ClientHttpRequestExecution execution, BlockException ex) {
    System.err.println("fallback: " + ex.getClass().getCanonicalName());
    return new SentinelClientHttpResponse("异常熔断降级");
	}
}
```

Sentinel RestTemplate 限流的资源规则提供两种粒度：

- `httpmethod:schema://host:port/path` ：协议、主机、端口和路径
- `httpmethod:schema://host:port` ：协议、主机和端口

##### Feign实现熔断

Sentinel 适配了 Feign 组件。如果想使用，除了引入 sentinel-starter 的依赖外还需要 2 个步骤：

- 配置文件打开 sentinel 对 feign 的支持： feign.sentinel.enabled=true
- 加入 openfeign starter 依赖使 sentinel starter 中的自动化配置类生效：

1. **引入依赖**

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
   </dependency>
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-openfeign</artifactId>
   </dependency>
   ```

2. **开启sentinel支持**

   在工程的application.yml中添加sentinel 对 feign 的支持

   ```yml
   feign:
     sentinel:
   	enabled: true
   ```

3. **配置FeignClient**

   和使用Hystrix的方式基本一致，需要配置FeignClient接口以及通过 fallback 指定熔断降级方法

   ```java
   //指定需要调用的微服务名称
   @FeignClient(name="shop-service-product",fallback = ProductFeginClientCallBack.class)
   public interface ProductFeginClient {
       //调用的请求路径
       @RequestMapping(value = "/product/{id}",method = RequestMethod.GET)
       public Product findById(@PathVariable("id") Long id);
   }
   ```

4. **配置熔断方法**

   ```java
   /**
   * 实现自定义的ProductFeginClient接口
   * 在接口实现类中编写熔断降级方法
   */
   @Component
   public class ProductFeginClientCallBack implements ProductFeginClient {
       
       /**
       * 降级方法
       */
       public Product findById(Long id) {
           Product product = new Product();
           product.setId(-1l);
           product.setProductName("熔断:触发降级方法");
           return product;
   	}
   }
   ```

## 微服务网关

#### 概述

在学习完前面的知识后，微服务架构已经初具雏形。但还有一些问题：不同的微服务一般会有不同的网络地址，客户端在访问这些微服务时必须记住几十甚至几百个地址，这对于客户端方来说太复杂也难以维护。如下图：

![image-20221031231730432](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221031231730432.png)

如果让客户端直接与各个微服务通讯，可能会有很多问题：

- 客户端会请求多个不同的服务，需要维护不同的请求地址，增加开发难度
- 在某些场景下存在跨域请求的问题
- 加大身份认证的难度，每个微服务需要独立认证

因此，我们需要一个微服务网关，介于客户端与服务器之间的中间层，所有的外部请求都会先经过微服务网关。客户端只需要与网关交互，只知道一个网关地址即可，这样简化了开发还有以下优点： 

1、易于监控 

2、易于认证 

3、减少了客户端与各个微服务之间的交互次数

![image-20221031231924956](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221031231924956.png)

## Zuul

### 简介

ZUUL是Netflflix开源的微服务网关，它可以和Eureka、Ribbon、Hystrix等组件配合使用，Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：

- 动态路由：动态将请求路由到不同后端集群
- 压力测试：逐渐增加指向集群的流量，以了解性能
- 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求
- 静态响应处理：边缘位置进行响应，避免转发到内部集群
- 身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求。Spring Cloud对Zuul进行了整合和增强。

Spring Cloud对Zuul进行了整合和增强

### 使用步骤

1. **创建工程导入坐标**

   在IDEA中创建ZUUL网关工程 shop_zuul_server ，并添加依赖

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
       <version>2.1.0.RELEASE</version>
   </dependency>
   ```

2. **配置启动类，开启网关服务器功能**

   创建启动类` ZuulServerApplication`

   ```java
   @SpringBootApplication
   @EnableZuulProxy // 开启Zuul的网关功能
   public class ZuulServerApplication {
   	public static void main(String[] args) {
   		SpringApplication.run(ZuulServerApplication.class, args);
   	}
   }
   ```

3. **配置文件**

   创建配置文件 application.yml ，并添加相应配置

   ```yml
   server:
     port: 8080 #服务端口
   spring:
     application:
   	name: api-gateway #指定服务名
   ```

### 路由

最直观的理解：

“路由”是指根据请求URL，将请求分配到对应的处理程序。在微服务体系中，Zuul负责接收所有的请求。根据不同的URL匹配规则，将不同的请求转发到不同的微服务处理。

#### 基础路由配置

```yml
zuul:
  routes:
	product-service: # 这里是路由id，随意写
	  path: /product-service/** # 这里是映射路径
	  url: http://127.0.0.1:9002 # 映射路径对应的实际url地址
      sensitiveHeaders: #默认zuul会屏蔽cookie，cookie不会传到下游服务，这里设置为空则取消默认的黑名单，如果设置了具体的头信息则不会传到下游服务
```

只需要在application.yml文件中配置路由规则即可：

- product-service：配置路由id，可以随意取名
- url：映射路径对应的实际url地址
- path：配置映射路径，这里将所有请求前缀为/product-service/的请求，转发到http://127.0.0.1:9002处理

#### 面向服务的路由

微服务一般是由几十、上百个服务组成，对于一个URL请求，最终会确认一个服务实例进行处理。如果对每个服务实例手动指定一个唯一访问地址，然后根据URL去手动实现请求匹配，这样做显然就不合理。

Zuul支持与Eureka整合开发，根据ServiceID自动的从注册中心中获取服务地址并转发请求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而且在添加或移除服务实例的时候不用修改Zuul的路由配置。

1. **添加eureka的依赖**

   ```xml
   <dependency>
   	<groupId>org.springframework.cloud</groupId>
   	<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
   </dependency>
   ```

2. **开启eureka的客户端服务发现（可省略）**

   ```java
   @SpringBootApplication
   @EnableZuulProxy // 开启Zuul的网关功能
   @EnableDiscoveryClient
   public class ZuulServerApplication {
   	public static void main(String[] args) {
   		SpringApplication.run(ZuulServerApplication.class, args);
   	}
   }
   ```

3. **在zuul网关服务中配置eureka的注册中心相关信息**

   ```yml
   eureka:
     client:
       serviceUrl:
         defaultZone: http://127.0.0.1:8761/eureka/
           registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s
     instance:
       preferIpAddress: true
       ip-address: 127.0.0.1
   ```

4. **修改路由中的映射配置，通过服务名称获取**

   因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。

   ```yml
   #配置路由规则
   zuul:
     routes:
       product-service: # 这里是路由id，随意写
         path: /product-service/** # 这里是映射路径
         serviceId: shop-service-product #配置转发的微服务名称
   ```

#### 简化路由配置

如果路由ID和对应的微服务的serviceId一致的话，可以简写成一行。

```yml
zuul:
  routes:
    shop-service-product: /product-service/**
```

#### Zuul加入后的架构

![image-20221101000306654](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221101000306654.png)

### 过滤器

通过之前的学习，我们得知Zuul它包含了两个核心功能：对请求的**路由**和**过滤**。其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础；而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。其实，路由功能在真正运行时，它的路由映射和请求转发同样也由几个不同的过滤器完成的。所以，过滤器可以说是Zuul实现API网关功能最为核心的部件，每一个进入Zuul的HTTP请求都会经过一系列的过滤器处理链得到请求响应并返回给客户端。

#### 简介

![image-20221101000819491](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221101000819491.png)

Zuul 中的过滤器跟我们之前使用的 javax.servlet.Filter 不一样，javax.servlet.Filter 只有一种类型，可以通过配置 urlPatterns 来拦截对应的请求。而 Zuul 中的过滤器总共有 4 种类型，且每种类型都有对应的使用场景。 

1. **PRE**：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。

2. **ROUTING**：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfifilx Ribbon请求微服务。

3. **POST**：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTPHeader、收集统计信息和指标、将响应从微服务发送给客户端等。

4. **ERROR**：在其他阶段发生错误时执行该过滤器。

```java
public abstract ZuulFilter implements IZuulFilter{
    
    /**
    *	定义过滤器类型
    *	pre
    *	routing
    *	post
    *	error
    */
    abstract public String filterType();
    
    /**
    *	指定过滤器的执行顺序
    *	返回值越小，执行顺序越高
    */
    abstract public int filterOrder();
    
    /**
    *	当前过滤器是否生效
    *	true：使用此过滤器
    *	false：不使用此过滤器
    */
    boolean shouldFilter();// 来自IZuulFilter
    
    /**
    *	执行过滤器中的业务逻辑
    */
    Object run() throws ZuulException;// IZuulFilter
}
```

#### 自定义过滤器

接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。

```java
@Component
public class LoginFilter extends ZuulFilter{
	@Override
	public String filterType() {
		// 登录校验，肯定是在前置拦截
		return "pre";
	}
    
	@Override
	public int filterOrder() {
		// 顺序设置为1
		return 1;
	}
    
	@Override
	public boolean shouldFilter() {
		// 返回true，代表过滤器生效。
		return true;
	}
    
	@Override
	public Object run() throws ZuulException {
        // 登录校验逻辑。
        // 1）获取Zuul提供的请求上下文对象
        RequestContext ctx = RequestContext.getCurrentContext();
        // 2) 从上下文中获取request对象
        HttpServletRequest req = ctx.getRequest();
        // 3) 从请求中获取token
        String token = req.getParameter("access-token");
        // 4) 判断
        if(token == null || "".equals(token.trim())){
            // 没有token，登录校验失败，拦截
            ctx.setSendZuulResponse(false);
            // 返回401状态码。也可以考虑重定向到登录页。
            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());
		}
        // 校验通过，可以考虑把用户信息放入上下文，继续向后执行
        return null;
	}
}
```

#### 源码

1. `spring.factories`文件中的`ZuulServerAutoConfiguration`自动配置类

2. `ZuulHandlerMapping`对象

   ```java
   @Bean
   public ZuulHandlerMapping zuulHandlerMapping(RouteLocator routes)
   ```

3. `ZuulHandlerMapping`继承的Spring的`AbstractUrlHandlerMapping`

   会自动加入到springMVC的handlerMapping链中，用于处理zuul的映射配置

4. 上一步会把请求发送到`ZuulServerAutoConfiguration`中的`ZuulController`中

   Controller中构造方法配置了一个`ZuulServlet`，下面将所有符合规则的请求交给`ZuulServlet`的`service`方法进行处理

   ```java
   public ZuulController() {
           this.setServletClass(ZuulServlet.class);
           this.setServletName("zuul");
           this.setSupportedMethods((String[])null);
   }
   ```

5. ZuulController执行了`handlerRequest`方法，方法中调用了父类的`handleRequestInternal`方法

   ```java
   public ModelAndView handleRequest(){
       var3 = super.handleRequestInternal(request, response);
   }
   ```

6. `handleRequestInternal`执行`this.servletInstance.service(request, response);`对请求进行处理

   ```java
   protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {
           Assert.state(this.servletInstance != null, "No Servlet instance");
           this.servletInstance.service(request, response);
           return null;
   }
   ```

7. `servletInstance.service`执行的是`ZuulServlet`中的`service`方法

   service方法包含了preRoute，route，postRoute，刚好是Zuul的声明周期。

   ```java
   public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
           try {
               this.init((HttpServletRequest)servletRequest, (HttpServletResponse)servletResponse);
               RequestContext context = RequestContext.getCurrentContext();
               context.setZuulEngineRan();
   
               try {
                   this.preRoute();
               } catch (ZuulException var12) {
                   this.error(var12);
                   this.postRoute();
                   return;
               }
   
               try {
                   this.route();
               } catch (ZuulException var13) {
                   this.error(var13);
                   this.postRoute();
                   return;
               }
   
               try {
                   this.postRoute();
               } catch (ZuulException var11) {
                   this.error(var11);
               }
           } catch (Throwable var14) {
               this.error(new ZuulException(var14, 500, "UNHANDLED_EXCEPTION_" + var14.getClass().getName()));
           } finally {
               RequestContext.getCurrentContext().unset();
           }
       }
   ```

### Zuul存在的问题

在实际使用中我们会发现直接使用Zuul会存在诸多问题，包括：

- 性能问题

Zuul1x版本本质上就是一个**同步Servlet**，采用多线程阻塞模型进行请求转发。简单讲，每来一个请求，Servlet容器要为该请求分配一个线程专门负责处理这个请求，直到响应返回客户端这个线程才会被释放返回容器线程池。如果后台服务调用比较耗时，那么这个线程就会被阻塞，阻塞期间线程资源被占用，不能干其它事情。我们知道Servlet容器线程池的大小是有限制的，当**前端请求量大，而后台慢服务比较多**时，很容易**耗尽容器线程池内的线程**，造成容器无法接受新的请求。

- 不支持任何长连接，如websocket

## GateWay

Zuul 1.x 是一个基于阻塞 IO 的 API Gateway 以及 Servlet；直到 2018 年 5 月，Zuul 2.x（基于Netty，也是非阻塞的，支持长连接）才发布，但 Spring Cloud 暂时还没有整合计划。Spring CloudGateway 比 Zuul 1.x 系列的性能和功能整体要好。

### 简介

Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式，统一访问接口。SpringCloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflflix ZUUL，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。它是基于Nttey的响应式开发模式。

### 核心概念

![image-20221104003939821](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104003939821.png)

1. **路由**（route）

   路由是网关最基础的部分，路由信息由一个ID、一个目的URL、一组断言工厂和一组Filter组成。如果断言为真，则说明请求URL和配置的路由匹配。

2. **断言**（predicates）Java8中的断言函数，Spring Cloud Gateway中的断言函数输入类型是Spring5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自Http Request中的任何信息，比如请求头和参数等。

3. **过滤器**（fifilter） 

   一个标准的Spring webFilter，Spring Cloud Gateway中的Filter分为两种类型，分别是Gateway Filter和GlobalFilter。过滤器Filter可以对请求和响应进行处理

### 路由

#### 路由配置

1. **创建工程导入依赖**

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-gateway</artifactId>
   </dependency>
   ```

2. **配置启动类**

   ```java
   @SpringBootApplication
   public class GatewayServerApplication {
   	public static void main(String[] args) {
   		SpringApplication.run(GatewayServerApplication.class, args);
   	}
   }
   ```

3. **编写配置文件**

   ```yml
   server:
     port: 8080 #服务端口
   spring:
     application:
       name: api-gateway #指定服务名
   cloud:
     gateway:
       routes:
       - id: product-service
         uri: http://127.0.0.1:9002
         predicates:
         - Path=/product/**
   ```

   - id：我们自定义的路由 ID，保持唯一

   - uri：目标服务地址

   - predicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。

   - fifilters：过滤规则，暂时没用。

   上面这段配置的意思是，配置了一个 id 为 product-service的路由规则，当访问网关请求地址以product 开头时，会自动转发到地址： http://127.0.0.1:9002/ 。

路由规则

Spring Cloud Gateway 的功能很强大，前面我们只是使用了 predicates 进行了简单的条件匹配，其实Spring Cloud Gataway 帮我们内置了很多 Predicates 功能。在 Spring Cloud Gateway 中 Spring 利用Predicate 的特性实现了各种路由匹配规则，有通过 Header、请求参数等不同的条件来进行作为条件匹配到对应的路由。

![image-20221104004438074](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221104004438074.png)

**示例**

```yml
#路由断言之后匹配
spring:
  cloud:
    gateway:
      routes:
      - id: after_route
      uri: https://xxxx.com
      predicates:
      - After=xxxxx
      
#路由断言之前匹配
spring:
  cloud:
    gateway:
      routes:
      - id: before_route
      uri: https://xxxx.com
      predicates:
      - Before=xxxxx
      
#路由断言之间
spring:
  cloud:
    gateway:
      routes:
      - id: between_route
      uri: https://xxxx.com
      predicates:
      - Between=xxxx,xxxx
      
#路由断言Cookie匹配,此predicate匹配给定名称(chocolate)和正则表达式(ch.p)
spring:
  cloud:
    gateway:
      routes:
      - id: cookie_route
      uri: https://xxxx.com
      predicates:
      - Cookie=chocolate, ch.p
        
#路由断言Header匹配，header名称匹配X-Request-Id,且正则表达式匹配\d+
spring:
  cloud:
    gateway:
      routes:
      - id: header_route
      uri: https://xxxx.com
      predicates:
      - Header=X-Request-Id, \d+
        
#路由断言匹配Host匹配，匹配下面Host主机列表,**代表可变参数
spring:
  cloud:
    gateway:
      routes:
      - id: host_route
      uri: https://xxxx.com
      predicates:
      - Host=**.somehost.org,**.anotherhost.org
        
#路由断言Method匹配，匹配的是请求的HTTP方法
spring:
  cloud:
    gateway:
      routes:
      - id: method_route
      uri: https://xxxx.com
      predicates:
      - Method=GET
        
#路由断言匹配，{segment}为可变参数
spring:
  cloud:
    gateway:
      routes:
      - id: host_route
      uri: https://xxxx.com
      predicates:
      - Path=/foo/{segment},/bar/{segment}
        
#路由断言Query匹配，将请求的参数param(baz)进行匹配，也可以进行regexp正则表达式匹配 (参数包含foo,并且foo的值匹配ba.)
spring:
  cloud:
    gateway:
      routes:
      - id: query_route
      uri: https://xxxx.com
      predicates:
      - Query=baz 或 Query=foo,ba.
        
#路由断言RemoteAddr匹配，将匹配192.168.1.1~192.168.1.254之间的ip地址，其中24为子网掩码位数即255.255.255.0
spring:
  cloud:
    gateway:
      routes:
      - id: remoteaddr_route
      uri: https://example.org
      predicates:
      - RemoteAddr=192.168.1.1/24
```

#### 动态路由

和zuul网关类似，在SpringCloud GateWay中也支持动态路由：即自动的从注册中心中获取服务列表并访问。

1. **添加注册中心依赖**

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
   </dependency>
   ```

2. **配置动态路由**

   修改 application.yml 配置文件，添加eureka注册中心的相关配置，并修改访问映射的URL为服务名称。

   ```yml
   server:
     port: 8080 #服务端口
   spring:
     application:
       name: api-gateway #指定服务名
     cloud:
       gateway:
         routes:
         - id: product-service
           uri: lb://shop-service-product #  uri以 lb: //开头（lb代表从注册中心获取服务），后面接的就是你需要转发到的服务名称
           predicates:
           - Path=/product/**
   eureka:
     client:
       serviceUrl:
         defaultZone: http://127.0.0.1:8761/eureka/
         registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s
     instance:
       preferIpAddress: true
       ip-address: 127.0.0.1
   ```

#### 重写转发路径

在SpringCloud Gateway中，路由转发是直接将匹配的路由path直接拼接到映射路径（URI）之后，那么在微服务开发中往往没有那么便利。这里就可以通过RewritePath机制来进行路径重写。

**添加RewritePath重写转发路径**

```yml
server:
  port: 8080 #服务端口
spring:
  application:
    name: api-gateway #指定服务名
  cloud:
    gateway:
      routes:
      - id: product-service
        uri: lb://shop-service-product #  uri以 lb: //开头（lb代表从注册中心获取服务），后面接的就是你需要转发到的服务名称
        predicates:
        - Path=/product/**
        filters:
        - RewritePath=/product-service/(?<segment>.*), /$\{segment}
```

通过RewritePath配置重写转发的url，将/product-service/(?.*)，重写为{segment}，然后转发到订单微服务。比如在网页上请求http://localhost:8080/product-service/product，此时会将请求转发到http://127.0.0.1:9002/product/1

### 过滤器

#### 过滤器的生命周期

Spring Cloud Gateway 的 Filter 的生命周期不像 Zuul 的那么丰富，它只有两个：“pre” 和 “post”。

**PRE：** 

这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。

**POST：**

这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。

![image-20221108004058426](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221108004058426.png)

#### 过滤器类型

Spring Cloud Gateway 的 Filter 从作用范围可分为另外两种GatewayFilter 与 GlobalFilter。

- **GatewayFilter**：应用到单个路由或者一个分组的路由上。
- **GlobalFilter**：应用到所有的路由上。

```java
/*
自定义一个过滤器，实现GlobalFilter, Ordered接口
*/
@Component
public class AuthorizeFilter implements GlobalFilter, Ordered {
    
    /*
    ServerWebExchange：相当于请求和响应的上下文（zuul中的RequestContext）
    */
	@Override
	public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 获取请求参数access-token
        String token = exchange.getRequest().getQueryParams().getFirst("token");
        // 判断是否存在
        if (StringUtils.isBlank(token)) {
            // 如果不存在，认证失败
        	log.info( "token is empty ..." );
            // 返回认证码
        	exchange.getResponse().setStatusCode( HttpStatus.UNAUTHORIZED );
            // 请求结束
        	return exchange.getResponse().setComplete();
		}
		return chain.filter(exchange);
	}
    
    @Override
    public int getOrder() {
		return 0;
	}
}
```

自定义全局过滤器需要实现GlobalFilter和Ordered接口。

- 在fifilter方法中完成过滤器的逻辑判断处理
- 在getOrder方法指定此过滤器的优先级，返回值越大级别越低
- ServerWebExchange 就相当于当前请求和响应的上下文，存放着重要的请求-响应属性、请求实例和响应实例等等。一个请求中的request，response都可以通过 ServerWebExchange 获取
- 调用 chain.filter 继续向下游执行

### 网关限流

#### 常见的限流算法

- **计数器**

  计数器限流算法是最简单的一种限流实现方式。其本质是通过维护一个单位时间内的计数器，每次请求计数器加1，当单位时间内计数器累加到大于设定的阈值，则之后的请求都被拒绝，直到单位时间已经过去，再将计数器重置为零

![image-20221108010115995](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221108010115995.png)

- **漏桶算法**

  漏桶算法可以很好地限制容量池的大小，从而防止流量暴增。漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。

  ![image-20221108010155564](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221108010155564.png)

  为了更好的控制流量，漏桶算法需要通过两个变量进行控制：一个是桶的大小，支持流量突发增多时可以存多少的水（burst），另一个是水桶漏洞的大小（rate）。

- **令牌桶算法**

  令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。

![image-20221108010328065](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221108010328065.png)

#### 基于Filter的限流

SpringCloudGateway官方就提供了基于令牌桶的限流支持。基于其内置的过滤器工厂`RequestRateLimiterGatewayFilterFactory` 实现。在过滤器工厂中是通过Redis和lua脚本结合的方式进行流量控制。

##### 使用步骤

- **导入redis依赖**

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-gateway</artifactId>
  </dependency>
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifatId>spring-boot-starter-data-redis-reactive</artifactId>
  </dependency>
  ```

- **修改application.yml文件**

  ```yml
  spring:
    application:
      name: api-gateway #指定服务名
    cloud:
      gateway:
  	  routes:
  	  - id: order-service
          uri: lb://shop-service-order
          filters:
          - RewritePath=/order-service/(?<segment>.*), /$\{segment}
  		- name: RequestRateLimiter
  		  args:
              # 使用SpEL从容器中获取对象
              key-resolver: '#{@pathKeyResolver}'
              # 令牌桶每秒填充平均速率
              redis-rate-limiter.replenishRate: 1
              # 令牌桶的总容量
              redis-rate-limiter.burstCapacity: 3
    redis:
      host: localhost
      port: 6379
  ```

  在 application.yml 中添加了redis的信息，并配置了RequestRateLimiter的限流过滤器：

  - burstCapacity，令牌桶总容量。

  - replenishRate，令牌桶每秒填充平均速率。

  - key-resolver，用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。

3. **配置KeyResolver**

   为了达到不同的限流效果和规则，可以通过实现 KeyResolver 接口，定义不同请求类型的限流键。

   ```java
   @Configuration
   public class KeyResolverConfiguration {
       /**
        * 基于请求路径的限流
        */
       @Bean
       public KeyResolver pathKeyResolver() {
           return exchange - > Mono.just(
               exchange.getRequest()
               .getPath()
               .toString()
           );
       }
       /**
        * 基于请求ip地址的限流
        */
       @Bean
       public KeyResolver ipKeyResolver() {
           return exchange - > Mono.just(
               exchange.getRequest()
               .getHeaders()
               .getFirst("X-Forwarded-For")
           );
       }
       /**
        * 基于用户的限流
        */
       @Bean
       public KeyResolver userKeyResolver() {
           return exchange - > Mono.just(
               exchange.getRequest()
               .getQueryParams()
               .getFirst("user")
           );
       }
   }
   
   ```

   通过reids的MONITOR可以监听redis的执行过程。这时候Redis中会有对应的数据：

![image-20221116235817586](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221116235817586.png)

大括号中就是我们的限流Key,这边是IP，本地的就是localhost

- timestamp:存储的是当前时间的秒数，也就是System.currentTimeMillis() / 1000或者
- Instant.now().getEpochSecond()

tokens:存储的是当前这秒钟的对应的可用的令牌数量

#### 基于Sentinel的限流

Sentinel 支持对 Spring Cloud Gateway、Zuul 等主流的 API Gateway 进行限流。

![image-20221117001723600](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221117001723600.png)

从 1.6.0 版本开始，Sentinel 提供了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：

- route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 routeId
- 自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组

Sentinel 1.6.0 引入了 Sentinel API Gateway Adapter Common 模块，此模块中包含网关限流的规则和自定义 API 的实体和管理逻辑：

- `GatewayFlowRule` ：网关限流规则，针对 API Gateway 的场景定制的限流规则，可以针对不同route 或自定义的 API 分组进行限流，支持针对请求中的参数、Header、来源 IP 等进行定制化的限流。

- `ApiDefinition` ：用户自定义的 API 定义分组，可以看做是一些 URL 匹配的组合。比如我们可以定义一个 API 叫 my_api ，请求 path 模式为 /foo/** 和 /baz/** 的都归到 my_api 这个 API分组下面。限流的时候可以针对这个自定义的 API 分组维度进行限流。

##### 使用步骤

1. 导入依赖

   ```xml
   <dependency>
       <groupId>com.alibaba.csp</groupId>
       <artifactId>sentinel-spring-cloud-gateway-adapter</artifactId>
       <version>x.y.z</version>
   </dependency>
   ```

2. 编写配置类

   ```java
   @Configuration
   public class GatewayConfiguration {
       private final List < ViewResolver > viewResolvers;
       private final ServerCodecConfigurer serverCodecConfigurer;
       public GatewayConfiguration(ObjectProvider < List < ViewResolver >> viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer) {
           this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);
           this.serverCodecConfigurer = serverCodecConfigurer;
       }
       
       /**
        * 配置限流的异常处理器:SentinelGatewayBlockExceptionHandler
        */
       @Bean
       @Order(Ordered.HIGHEST_PRECEDENCE)
       public SentinelGatewayBlockExceptionHandler
       sentinelGatewayBlockExceptionHandler() {
           return new SentinelGatewayBlockExceptionHandler(viewResolvers
               , serverCodecConfigurer);
       }
       /**
        * 配置限流过滤器
        */
       @Bean
       @Order(Ordered.HIGHEST_PRECEDENCE)
       public GlobalFilter sentinelGatewayFilter() {
           return new SentinelGatewayFilter();
       }
       /**
        * 配置初始化的限流参数
        */
       @PostConstruct
       public void initGatewayRules() {
           Set <GatewayFlowRule> rules = new HashSet<>();
           rules.add(
               new GatewayFlowRule("order-service") //资源名称
               .setCount(1) // 限流阈值
               .setIntervalSec(1) // 统计时间窗口，单位是秒，默认是 1 秒
           );
           GatewayRuleManager.loadRules(rules);
       }
   }
   
   ```

   - 基于Sentinel 的Gateway限流是通过其提供的Filter来完成的，使用时只需注入对应的SentinelGatewayFilter 实例以及 SentinelGatewayBlockExceptionHandler 实例即可。

   - @PostConstruct定义初始化的加载方法，用于指定资源的限流规则。这里资源的名称为 orderservice ，统计时间是1秒内，限流阈值是1。表示每秒只能访问一个请求。

3. 网关配置

   ```yml
   spring:
     application:
   	name: api-gateway #指定服务名
     redis:
   	host: 127.0.0.1
   	port: 6379
   	database: 0
     cloud:
   	gateway:
   	  routes:
   	  - id: order-service
   	    uri: lb://shop-service-order
   		predicates:
   		- Path=/order-service/**
   		filters:
   		- RewritePath=/order-service/(?<segment>.*), /$\{segment}
   ```

   在一秒钟内多次访问http://localhost:8080/order-service/order/buy/1就可以看到限流启作用了。

![image-20221117002415373](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221117002415373.png)

4. 自定义异常提示

   当触发限流后页面显示的是Blocked by Sentinel: FlowException。为了展示更加友好的限流提示，Sentinel支持自定义异常处理。

   您可以在 GatewayCallbackManager 注册回调进行定制：

   - setBlockHandler ：注册函数用于实现自定义的逻辑处理被限流的请求，对应接口为BlockRequestHandler 。默认实现为 DefaultBlockRequestHandler ，当被限流时会返回类似于下面的错误信息： Blocked by Sentinel: FlowException 。

   ```java
   @PostConstruct
   public void initBlockHandlers() {
       BlockRequestHandler blockRequestHandler = new BlockRequestHandler() {
           public Mono < ServerResponse > handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) {
               Map map = new HashMap < > ();
               map.put("code", 001);
               map.put("message", "对不起,接口限流了");
               return ServerResponse.status(HttpStatus.OK)
                   .
               contentType(MediaType.APPLICATION_JSON_UTF8)
                   .
               body(BodyInserters.fromObject(map));
           }
       };
       GatewayCallbackManager.setBlockHandler(blockRequestHandler);
   }
   ```

   ![image-20221117002531334](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221117002531334.png)

5. 参数限流

   上面的配置是针对整个路由来限流的，如果我们只想对某个路由的参数做限流，那么可以使用参数限流方式：

   ```java
   rules.add(new GatewayFlowRule("order-service")
       .setCount(1)
       .setIntervalSec(1)
       .setParamItem(new GatewayParamFlowItem()
           .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_URL_PARAM)
           .setFi eldName("id")
       )
   );
   ```

   通过指定PARAM_PARSE_STRATEGY_URL_PARAM表示从url中获取参数，setFieldName指定参数名称。

6. 自定义API分组

   ```java
   @PostConstruct
   private void initCustomizedApis() {
       Set < ApiDefinition > definitions = new HashSet < > ();
       ApiDefinition api1 = new ApiDefinition("product_api")
           .setPredicateItems(new HashSet < ApiPredicateItem > () {
               {
                   //以/product-service/product 开头的请求
                   add(new ApiPathPredicateItem()
                       .setPattern("/product-service/product/**")
                       .setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX));
               }
           });
       ApiDefinition api2 = new ApiDefinition("order_api")
           .setPredicateItems(new HashSet < ApiPredicateItem > () {
               {
                   ///order-service/order 完成的url路径匹配
                   add(new ApiPathPredicateItem()
                       .setPattern("/order-service/order"));
               }
           });
       definitions.add(api1);
       definitions.add(api2);
       GatewayApiDefinitionManager.loadApiDefinitions(definitions);
   }
   
   ```


### 网关高可用

**高可用HA**（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。

![image-20221207223836448](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207223836448.png)

我们实际使用 Spring Cloud Gateway 的方式如上图，不同的客户端使用不同的负载将请求分发到后端的 Gateway，Gateway 再通过HTTP调用后端服务，最后对外输出。因此为了保证 Gateway 的高可用性，前端可以同时启动多个 Gateway 实例进行负载，在 Gateway 的前端使用 Nginx 或者 F5 进行负载转发以达到高可用性。

## 微服务的链路追踪概述

### **微服务架构下的问题**

在大型系统的微服务化构建中，一个系统会被拆分成许多模块。这些模块负责不同的功能，组合成系统，最终可以提供丰富的功能。在这种架构中，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心，也就意味着这种架构形式也会存在一些问题：

- 如何快速发现问题？
- 如何判断故障影响范围？
- 如何梳理服务依赖以及依赖的合理性？
- 如何分析链路性能问题以及实时容量规划？

分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。

目前业界比较流行的链路追踪系统如：Twitter的**Zipkin**，阿里的**鹰眼**，美团的**Mtrace**，大众点评的**cat**等，大部分都是基于google发表的[**Dapper**](http://bigbully.github.io/Dapper-translation/)。Dapper阐述了分布式系统，特别是微服务架构中链路追踪的概念、数据表示、埋点、传递、收集、存储与展示等技术细节。

### **Sleuth概述**

#### 简介

Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。

#### **相关概念**

Spring Cloud Sleuth 为Spring Cloud提供了分布式根据的解决方案。它大量借用了Google Dapper的设计。先来了解一下Sleuth中的术语和相关概念。

Spring Cloud Sleuth采用的是Google的开源项目Dapper的专业术语。

- Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址) span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。

- Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。

- Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束

  - cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始

  - sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟

  - ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间

  - cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间

### **链路追踪Sleuth入门**

1. **配置依赖**

   修改微服务工程引入Sleuth依赖

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-sleuth</artifactId>
   </dependency>
   ```

2. **修改配置文件**

   修改application.yml添加日志级别

   ```yml
   logging:
     level:
       root: INFO
       org.springframework.web.servlet.DispatcherServlet: DEBUG
       org.springframework.cloud.sleuth: DEBUG
   ```

   每个微服务都需要添加如上的配置。启动微服务，调用之后，我们可以在控制台观察到sleuth的日志输出。

   ![image-20221207225954274](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207225954274.png)

其中 ff8ff8b803a3b558 是TraceId，后面跟着的是SpanId，依次调用有一个全局的TraceId，将调用链路串起来。仔细分析每个微服务的日志，不难看出请求的具体过程。

查看日志文件并不是一个很好的方法，当微服务越来越多日志文件也会越来越多，通过Zipkin可以将日志聚合，并进行可视化展示和全文检索。

### **Zipkin的概述**

Zipkin 是 Twitter 的一个开源项目，它基于 Google Dapper 实现，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。 我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的 REST API 接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。除了面向开发的 API 接口之外，它也提供了方便的 UI 组件来帮助我们直观的搜索跟踪信息和分析请求链路明细，比如：可以查询某段时间内各用户请求的处理时间等。 Zipkin 提供了可插拔数据存储方式：InMemory、MySql、Cassandra 以及 Elasticsearch。

![image-20221207230304948](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207230304948.png)

上图展示了 Zipkin 的基础架构，它主要由 4 个核心组件构成：

- Collector：收集器组件，它主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为Zipkin 内部处理的 Span 格式，以支持后续的存储、分析、展示等功能。
- Storage：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中。
- RESTful API：API 组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。
- Web UI：UI 组件，基于 API 组件实现的上层应用。通过 UI 组件用户可以方便而有直观地查询和分析跟踪信息。

Zipkin 分为两端，一个是 Zipkin 服务端，一个是 Zipkin 客户端，客户端也就是微服务的应用。

客户端会配置服务端的 URL 地址，一旦发生服务间的调用的时候，会被配置在微服务里面的 Sleuth 的监听器监听，并生成相应的 Trace 和 Span 信息发送给服务端。

发送的方式主要有两种，一种是 HTTP 报文的方式，还有一种是消息总线的方式如 RabbitMQ。

不论哪种方式，我们都需要：

- 一个 Eureka 服务注册中心，这里我们就用之前的 eureka 项目来当注册中心。
- 一个 Zipkin 服务端。
- 多个微服务，这些微服务中配置Zipkin 客户端。

###  **Zipkin Server的部署和配置**

1. **Zipkin Server下载**

   从spring boot 2.0开始，官方就不再支持使用自建Zipkin Server的方式进行服务链路追踪，而是直接提供了编译好的 jar 包来给我们使用。可以从官方网站下载先下载[Zipkin](https://search.maven.org/remote_content?g=io.zipkin.java&a=zipkin-server&v=LATEST&c=exec)的web UI，我们这里下载的是zipkin-server-2.12.9-exec.jar

2. **启动**

   在命令行输入`java -jar zipkin-server-2.12.9-exec.jar`启动 Zipkin Server

   ![image-20221207230909491](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207230909491.png)

- 默认Zipkin Server的请求端口为 **9411**
- Zipkin Server的启动参数可以通过官方提供的[yml配置文件查找](https://github.com/openzipkin/zipkin/blob/master/zipkin-server/src/main/resources/zipkin-server-shared.yml)
- 在浏览器输入 http://127.0.0.1:9411即可进入到Zipkin Server的管理后台

### **客户端Zipkin+Sleuth整合**

通过查看日志分析微服务的调用链路并不是一个很直观的方案，结合zipkin可以很直观地显示微服务之间的调用关系。

1. **客户端添加依赖**

   客户端指的是需要被追踪的微服务

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-zipkin</artifactId>
   </dependency>
   ```

2. **修改客户端配置文件**

   ```yml
   zipkin:
     base-url: http://127.0.0.1:9411/ #zipkin server的请求地址
     sender:
       type: web #请求方式,默认以http的方式向zipkin server发送追踪数据
   sleuth:
     sampler:
       probability: 1.0 #采样的百分比
   ```

   指定了zipkin server的地址，下面制定需采样的百分比，默认为0.1，即10%，这里配置1，是记录全部的sleuth信息，是为了收集到更多的数据（仅供测试用）。在分布式系统中，过于频繁的采样会影响系统性能，所以这里配置需要采用一个合适的值。

3. **测试**

   以此启动每个微服务，启动Zipkin Service。通过浏览器发送一次微服务请求。打开 Zipkin Service控制台，我们可以根据条件追踪每次请求调用过程。

   ![image-20221207231354595](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207231354595.png)

   单击该trace可以看到请求的细节

   ![image-20221207231423362](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207231423362.png)

### **基于消息中间件收集数据**

在默认情况下，Zipkin客户端和Server之间是使用HTTP请求的方式进行通信（即同步的请求方式），在网络波动，Server端异常等情况下可能存在信息收集不及时的问题。Zipkin支持与rabbitMQ整合完成异步消息传输。

加了MQ之后，通信过程如下图所示：

![image-20221207231719874](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207231719874.png)

#### **RabbitMQ的安装与启动**

略

#### 服务端启动

```shell
java -jar zipkin-server-2.12.9-exec.jar --RABBIT_ADDRESSES=127.0.0.1:5672
```

- RABBIT_ADDRESSES ： 指定RabbitMQ地址
- RABBIT_USER： 用户名（默认guest）
- RABBIT_PASSWORD ： 密码（默认guest）

启动Zipkin Server之后，我们打开RabbitMQ的控制台可以看到多了一个Queue

![image-20221207234028410](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207234028410.png)

其中`zipkin`就是为我们自动创建的Queue队列

#### 客户端配置

1. **配置依赖**

   ```yml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-sleuth</artifactId>
   </dependency>
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-zipkin</artifactId>
   </dependency>
   <dependency>
       <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-sleuth-zipkin</artifactId>
   </dependency>
   <dependency>
       <groupId>org.springframework.amqp</groupId>
       <artifactId>spring-rabbit</artifactId>
   </dependency>
   ```

   导入`spring-rabbit`依赖，是Spring提供的对rabbit的封装，客户端会根据配置自动的生产消息并发送到目标队列中

2. **配置消息中间件rabbit mq地址等信息**

   ```yml
   zipkin:
     #base-url: http://127.0.0.1:9411/ #zipkin server的请求地址
     sender:
       type: rabbit
       #type: web #请求方式,默认以http的方式向zipkin server发送追踪数据
     sleuth:
       sampler:
         probability: 1.0 #采样的百分比
     rabbitmq:
       host: localhost
       port: 5672
       username: guest
       password: guest
       listener: # 这里配置了重试策略
         direct:
           retry:
             enabled: true
         simple:
           retry:
             enabled: true
   ```

   - 修改消息的投递方式，改为rabbit即可。

   - 添加rabbitmq的相关配置

3. **测试**

   关闭Zipkin Server，并随意请求连接。打开rabbitmq管理后台可以看到，消息已经推送到rabbitmq。

   当Zipkin Server启动时，会自动的从rabbitmq获取消息并消费，展示追踪数据

   可以看到如下效果：

   - 请求的耗时时间不会出现突然耗时特长的情况

   - 当ZipkinServer不可用时（比如关闭、网络不通等），追踪信息不会丢失，因为这些信息会保存在Rabbitmq服务器上，直到Zipkin服务器可用时，再从Rabbitmq中取出这段时间的信息

### 存储跟踪数据

Zipkin Server默认时间追踪数据信息保存到内存，这种方式不适合生产环境。因为一旦Service关闭重启或者服务崩溃，就会导致历史数据消失。Zipkin支持将追踪数据持久化到mysql数据库或者存储到elasticsearch中。这里以mysql为例。

#### 准备数据库

可以从官网找到Zipkin Server持久mysql的数据库脚本。

#### **配置启动服务端**

```shell
java -jar zipkin-server-2.12.9-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_DB=zipkin --MYSQL_USER=root --MYSQL_PASS=111111
```

- STORAGE_TYPE : 存储类型
- MYSQL_HOST： mysql主机地址
- MYSQL_TCP_PORT：mysql端口
- MYSQL_DB： mysql数据库名称
- MYSQL_USER：mysql用户名
- MYSQL_PASS ：mysql密码

配置好服务端之后，可以在浏览器请求几次。回到数据库查看会发现数据已经持久化到mysql中

![image-20221207233059321](https://raw.githubusercontent.com/yu980219/image-host/master/hexo/image-20221207233059321.png)
