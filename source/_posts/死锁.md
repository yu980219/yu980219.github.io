---
title: 死锁
tags: [OS, Java]
categories:
  - 操作系统
index_img: /img/os.jpg
date: 2021/10/26 16:17:16
---

## 死锁

### 哲学家就餐问题

#### 问题描述

哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：

- 吃饭
- 思考

吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗米饭，每两个哲学家之间有一只筷子。因为用一只筷子很难吃到米饭，所以假设哲学家必须用两只筷子吃东西。他们只能使用自己左右手边的那两只筷子。

![这里写图片描述](https://gitee.com/yu980219/picture-warehouse/raw/master/images/os/20150605092138563)

#### 场景模拟

来模拟一下就餐的情况

> 筷子分别用1-5编号代替，五名哲学家的名字分别从A-E

```java
public class Demo{

    public static void main(String[] args) {
        Chopstick c1 = new Chopstick(1);
        Chopstick c2 = new Chopstick(2);
        Chopstick c3 = new Chopstick(3);
        Chopstick c4 = new Chopstick(4);
        Chopstick c5 = new Chopstick(5);

        /**
         * 根据图片的情况
         * A左右筷子分别是5和1
         * B左右筷子分别是1和2
         * ...
         */
        new Philosopher("A", c5, c1).start();
        new Philosopher("B", c1, c2).start();
        new Philosopher("C", c2, c3).start();
        new Philosopher("D", c3, c4).start();
        new Philosopher("E", c4, c5).start();
    }
}

/**
 * 哲学家
 */
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    String name;

    public Philosopher(String name, Chopstick left, Chopstick right) {
        this.name = name;
        this.left = left;
        this.right = right;
    }

    @Override
    public void run() {
        while (true) {
            // 尝试拿左手边的筷子
            synchronized (left) {
                // 尝试拿右手边的筷子
                synchronized (right) {
                    eat();
                }
            }
        }
    }

    private void eat() {
        System.out.println(name + " eat!");
    }
}

/**
 * 筷子类
 */
class Chopstick {
    // 每只筷子的编号
    Integer id;

    public Chopstick(Integer id) {
        this.id = id;
    }
}
```

最开始程序还能进行，执行到最后发现，程序不动了。

![image-20221021142734189](https://gitee.com/yu980219/picture-warehouse/raw/master/images/os/image-20221021142734189.png)

如果5个哲学家同时拿起左边的筷子，并且等待右边的筷子的同时，又不放下左边的筷子。就会导致五个哲学家都吃不到米饭。

#### 解决方案

##### 一、线程粗化

> 把5把锁合并成一把锁，只有抢到这一把锁，才可以执行。

```java
public class Demo1 {

    public static void main(String[] args) {
        Chopstick c1 = new Chopstick(1);
        Chopstick c2 = new Chopstick(2);
        Chopstick c3 = new Chopstick(3);
        Chopstick c4 = new Chopstick(4);
        Chopstick c5 = new Chopstick(5);

        // 定义了一个大锁
        String mutex = "大锁";

        /**
         * 根据图片的情况
         * A左右筷子分别是5和1
         * B左右筷子分别是1和2
         * ...
         */
        new Philosopher("A", c5, c1, mutex).start();
        new Philosopher("B", c1, c2, mutex).start();
        new Philosopher("C", c2, c3, mutex).start();
        new Philosopher("D", c3, c4, mutex).start();
        new Philosopher("E", c4, c5, mutex).start();
    }
}

/**
 * 哲学家
 */
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    String name;
    String mutex;

    public Philosopher(String name, Chopstick left, Chopstick right, String mutex) {
        this.name = name;
        this.left = left;
        this.right = right;
        this.mutex = mutex;
    }

    @Override
    public void run() {
        while (true) {
            // 拿到大锁，才可以吃饭
            synchronized (mutex) {
                eat();
            }
        }
    }

    private void eat() {
        System.out.println(name + " eat!");
    }
}

/**
 * 筷子类
 */
class Chopstick {
    // 每只筷子的编号
    Integer id;

    public Chopstick(Integer id) {
        this.id = id;
    }
}
```

- 缺点：效率太低，明明大家拿到2个筷子就可以吃饭，却同一时刻只能一个人用餐。

##### 二、最少保证

> 代码里，每个哲学家都是先拿左筷子，再拿右筷子。我们让其中一个人，先拿右筷子，再拿左筷子。再次结合下面这张图，假设E是右撇子，A,B,C,D分别同时拿起了左手边的筷子5,1,2,3

<img src="https://gitee.com/yu980219/picture-warehouse/raw/master/images/os/image-20221021145109430.png" alt="image-20221021145109430" style="zoom: 67%;" />

> 而E是右撇子，他要先拿5，但5被占用了，所以他不得不放弃争抢这次资源，而D顺利成章地拿到了4，这样D拥有了3和4，然后吃完释放，C又拿起了2和3，再释放...

```java
// 这里就不贴所有的代码了，我们把样例中的E哲学家变成右撇子。让他先拿5再拿4
new Philosopher("A", c5, c1).start();
new Philosopher("B", c1, c2).start();
new Philosopher("C", c2, c3).start();
new Philosopher("D", c3, c4).start();
// new Philosopher("E", c4, c5).start();
new Philosopher("E", c5, c4).start();
```

- 缺点：这个效率同样不高，因为D要吃完C才能吃，C要吃完B才能吃，这样就形成了一条链，如果这条链上有500，5000人呢？

##### 三、奇偶互反

> 让奇数位置的哲学家先拿左筷子，偶数位置的哲学家先拿右筷子。
>
> 如果A,C,E为奇数；B,D为偶数。
>
> 如果A拿到了5，B只能拿2，AB之间的1，就被空了出来，保证A能拿到；
>
> 同理B如果拿到了2，A只能拿5，AB之间的1，也被空了出来，B也能拿到。
>
> 当他们用餐完毕，释放完以后，可以继续按这个规则，进餐。不会发生死锁。

```java
public class Demo {

    public static void main(String[] args) {
        Chopstick c1 = new Chopstick(1);
        Chopstick c2 = new Chopstick(2);
        Chopstick c3 = new Chopstick(3);
        Chopstick c4 = new Chopstick(4);
        Chopstick c5 = new Chopstick(5);

        /**
         * 根据图片的情况
         * A左右筷子分别是5和1
         * B左右筷子分别是1和2
         * ...
         */
        new Philosopher("A", c5, c1).start();
        new Philosopher("B", c1, c2).start();
        new Philosopher("C", c2, c3).start();
        new Philosopher("D", c3, c4).start();
        new Philosopher("E", c4, c5).start();
    }
}

/**
 * 哲学家
 */
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    String name;

    public Philosopher(String name, Chopstick left, Chopstick right) {
        this.name = name;
        this.left = left;
        this.right = right;
    }

    @Override
    public void run() {
        // 模拟 A C E是奇数，实际做的时候 可以用编号对2求余。
        if ("A".equals(this.name) || "C".equals(this.name) || "E".equals(this.name)) {
            while (true) {
                // 尝试拿左手边的筷子
                synchronized (left) {
                    // 尝试拿右手边的筷子
                    synchronized (right) {
                        eat();
                    }
                }
            }
        } else {
            while (true) {
                // 尝试拿右手边的筷子
                synchronized (right) {
                    // 尝试拿左手边的筷子
                    synchronized (left) {
                        eat();
                    }
                }
            }
        }

    }

    private void eat() {
        System.out.println(name + " eat!");
    }
}

/**
 * 筷子类
 */
class Chopstick {
    // 每只筷子的编号
    Integer id;

    public Chopstick(Integer id) {
        this.id = id;
    }
}
```

这个是效率最高的方法