---
title: 设计模式
tags: [设计原则]
categories:
  - 设计模式
  - 六大设计原则
index_img: /img/default.jpeg
date: 2022/12/15 02:38:00
---
# 六大设计原则

文章摘自《设计模式之禅(第二版)》- 秦小波

## 一、单一职责原则

> 英文名称是Single Responsibility Principle，简称是SRP。
>
> 原话解释：*There should never be more than one reason for a class to change.*

**定义：应该有且仅有一个原因引起类的变更。**

**示例**：电话通话的时候有4个过程发生：拨号、通话、回应、挂机，那我们写一个接口。

![image-20221213231244890](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221213231244890.png)

```java
public interface IPhone {
    //拨通电话
    public void dial(String phoneNumber);
    //通话
    public void chat(Object o);
    //通话完毕，挂电话
    public void hangup();
}
```

单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情，看看上面的接口只负责一件事情吗？是只有一个原因引起变化吗？好像不是！

IPhone这个接口可不是只有一个职责，它包含了两个职责：一个是协议管理，一个是数据传送。

- `dial()`和`hangup()`两个方法实现的是协议管理，分别负责拨号接通和挂机；

- `chat()`实现的是数据的传送，把我们说的话转换成模拟信号或数字信号传递到对方，然后再把对方传递过来的信号还原成我们听得懂的语言。

**思考：**

协议接通的变化会引起这个接口或实现类的变化吗？会的！

那数据传送（想想看，电话不仅仅可以通话，还可以上网）的变化会引起这个接口或实现类的变化吗？会的！

通过这样的分析，我们发现类图上的IPhone接口包含了两个职责，而且这两个职责的变化不相互影响，那就考虑拆分成两个接口。

![image-20221213232355372](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221213232355372.png)

这样的设计才是完美的，一个类实现了两个接口，把两个职责融合在一个类中。

*你会觉得这个Phone有两个原因引起变化了呀，是的，但是别忘记了我们是面向接口编程，我们对外公布的是接口而不是实现类。*

**单一职责的好处：**

- 类的复杂性降低，实现什么职责都有清晰明确的定义；
- 可读性提高，复杂性降低，那当然可读性提高了；
- 可维护性提高，可读性提高，那当然更容易维护了；
- 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

**注意：**单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因**项目**而异，因**环境**而异。

## 二、里氏替换原则

> 里氏替换原则：Liskov Substitution Principle，LSP

在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下**优点**：

- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；

- 提高代码的重用性；

- 子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；

- 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；

- 提高产品或项目的开放性。

自然界的所有事物都是优点和缺点并存的，即使是鸡蛋，有时候也能挑出骨头来，继承的**缺点**如下：

- 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；
- 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
- 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。

**定义：**

**第一种定义：**

也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）

**第二种定义：**

Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）

**解释：**第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。

-----

里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。

1. **子类必须完全实现父类的方法**

**示例：**

大家都打过CS吧，非常经典的FPS类游戏，我们来描述一下里面用到的枪。

> Soldier：士兵
>
> AbstractGun：枪支

![image-20221213234842022](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221213234842022.png)

在士兵类中定义了一个方法`killEnemy`，使用枪来杀敌人，具体使用什么枪来杀敌人，调用的时候才知道。

**枪支的抽象类：**

```java
public abstract class AbstractGun {
    //枪用来干什么的？杀敌！
    public abstract void shoot();
}
```

**手枪、步枪、机枪的实现类：**

```java
public class Handgun extends AbstractGun {
    //手枪的特点是携带方便，射程短
    @Override
    public void shoot() {
    	System.out.println("手枪射击...");
    }
}

public class Rifle extends AbstractGun{
    //步枪的特点是射程远，威力大
    public void shoot(){
    	System.out.println("步枪射击...");
    }
}

public class MachineGun extends AbstractGun{
    public void shoot(){
    	System.out.println("机枪扫射...");
    }
}
```

**士兵的实现类：**

```java
public class Soldier {
    //定义士兵的枪支
    private AbstractGun gun;
    
    //给士兵一支枪
    public void setGun(AbstractGun _gun){
    	this.gun = _gun;
    }
    
    public void killEnemy(){
    	System.out.println("士兵开始杀敌人...");
    	gun.shoot();
    }
}
```

**场景类：**

```java
public class Client {
    public static void main(String[] args) {
        //产生三毛这个士兵
        Soldier sanMao = new Soldier();
        
        //给三毛一支枪
        sanMao.setGun(new Rifle());
    	sanMao.killEnemy();
    }
}
```

> 运行结果：
>
> 士兵开始杀敌人...
>
> 步枪射击...

在这个程序中，我们给三毛这个士兵一把步枪，然后就开始杀敌了。如果三毛要使用机枪，当然也可以，直接把`sanMao.setGun(new Rifle())`修改为`sanMao.setGun(new MachineGun())`即可，在编写程序时`Solider`士兵类根本就不用知道是哪个型号的枪（子类）被传入。

**注意：**在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。

我们再来想一想，如果我们有一个玩具手枪，该如何定义呢？我们先在类图2-1上增加一个类`ToyGun`，然后继承于`AbstractGun`类。

![image-20221213235629832](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221213235629832.png)

玩具枪是不能用来射击的，杀不死人的，这个不应该写在shoot方法中。

**玩具枪源代码：**

```java
public class ToyGun extends AbstractGun {
    //玩具枪是不能射击的，但是编译器又要求实现这个方法，怎么办？虚构一个呗！
    @Override
    public void shoot() {
    	//玩具枪不能射击，这个方法就不实现了
    }
}
```

**场景类：**

```java
public class Client {
    public static void main(String[] args) {
        //产生三毛这个士兵
        Soldier sanMao = new Soldier();
        sanMao.setGun(new ToyGun());
        sanMao.killEnemy();
    }
}
```

> 士兵开始杀敌人...

坏了，士兵拿着玩具枪来杀敌人，射不出子弹呀！如果在CS游戏中有这种事情发生，那你就等着被人爆头吧，然后看着自己凄惨地倒地。在这种情况下，我们发现业务调用类已经出现了问题，正常的业务逻辑已经不能运行，那怎么办？好办，有两种解决办法：

-  在Soldier类中增加instanceof的判断，如果是玩具枪，就不用来杀敌人。这个方法可以解决问题，但是你要知道，在程序中，每增加一个类，所有与这个父类有关系的类都必须修改，你觉得可行吗？如果你的产品出现了这个问题，因为修正了这样一个Bug，就要求所有与这个父类有关系的类都增加一个判断，客户非跳起来跟你干架不可！你还想要客户忠诚于你吗？显然，这个方案被否定了。

- ToyGun脱离继承，建立一个独立的父类，为了实现代码复用，可以与AbastractGun建立关联委托关系。

  ![image-20221213235900984](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221213235900984.png)

**思考：**子类是否能够完整地实现父类的业务，否则就会出现像上面的拿枪杀敌人时却发现是把玩具枪的笑话。

**注意：**如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。

2. **子类可以有自己的个性**

子类当然可以有自己的行为和外观了，也就是方法和属性，那这里为什么要再提呢？是因为里氏替换原则可以正着用，但是不能反过来用。

在子类出现的地方，父类未必就可以胜任。还是以刚才的关于枪支的例子为例，步枪有几个比较“响亮”的型号，比如AK47、AUG狙击步枪等，把这两个型号的枪引入后的Rifle子类图。

![image-20221214000248005](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221214000248005.png)

AUG继承了Rifle类，狙击手（Snipper）则直接使用AUG狙击步枪。

**AUG狙击枪源码代码：**

```java
public class AUG extends Rifle {
    //狙击枪都携带一个精准的望远镜
    public void zoomOut(){
    	System.out.println("通过望远镜察看敌人...");
    }
    public void shoot(){
    	System.out.println("AUG射击...");
    }
}
```

**AUG狙击手类的源码代码：**

```java
public class Snipper {
    public void killEnemy(AUG aug){
        //首先看看敌人的情况，别杀死敌人，自己也被人干掉
        aug.zoomOut();
        //开始射击
        aug.shoot();
    }
}
```

**狙击手使用AUG杀死敌人:**

```java
public class Client {
    public static void main(String[] args) {
        //产生三毛这个狙击手
        Snipper sanMao = new Snipper();
        sanMao.setRifle(new AUG());
        sanMao.killEnemy();
    }
}
```

> 通过望远镜察看敌人...
>
> AUG射击...

在这里，系统直接调用了子类，狙击手是很依赖枪支的，别说换一个型号的枪了，就是换一个同型号的枪也会影响射击，所以这里就直接把子类传递了进来。这个时候，我们能不能直接使用父类传递进来呢？

**使用父类作为参数：**

```java
public class Client {
    public static void main(String[] args) {
        //产生三毛这个狙击手
        Snipper sanMao = new Snipper();
        sanMao.setRifle((AUG)(new Rifle()));
        sanMao.killEnemy();
    }
}
```

显示是不行的，会在运行期抛出`java.lang.ClassCastException`异常，这也是大家经常说的向下转型（downcast）是不安全的，从里氏替换原则来看，就是有子类出现的地方父类未必就可以出现。

3. **覆盖或实现父类的方法时输入参数可以被放大**

**Father类源代码：**

```java
public class Father {
    public Collection doSomething(HashMap map){
        System.out.println("父类被执行...");
        return map.values();
    }
}
```

**子类源代码：**

```java
public class Son extends Father {
    //放大输入参数类型
    public Collection doSomething(Map map){
        System.out.println("子类被执行...");
        return map.values();
    }
}
```

**场景类源代码：**

```java
public class Client {
    public static void invoker(){
        //父类存在的地方，子类就应该能够存在
        Father f = new Father();
        HashMap map = new HashMap();
        f.doSomething(map);
    }
    
    public static void main(String[] args) {
    	invoker();
    }
}
```

> 父类被执行...

根据里氏替换原则，父类出现的地方子类就可以出现，我们把上面的粗体部分修改为子类。

**子类替换父类后的源代码：**

```java
public class Client {
    public static void invoker(){
        //父类存在的地方，子类就应该能够存在
        Son f =new Son();
        HashMap map = new HashMap();
        f.doSomething(map);
    }
    
    public static void main(String[] args) {
        invoker();
    }
}
```

运行结果还是一样，看明白是怎么回事了吗？父类方法的输入参数是HashMap类型，子类的输入参数是Map类型，也就是说子类的输入参数类型的范围扩大了，子类代替父类传递到调用者中，子类的方法永远都不会被执行。这是正确的，如果你想让子类的方法运行，就必须覆写父类的方法。大家可以这样想，在一个Invoker类中关联了一个父类，调用了一个父类的方法，子类可以覆写这个方法，也可以重载这个方法，前提是要扩大这个前置条件，就是输入参数的类型宽于父类的类型覆盖范围。这样说可能比较难理解，我们再反过来想一下，如果Father类的输入参数类型宽于子类的输入参数类型，会出现什么问题呢？会出现父类存在的地方，子类就未必可以存在，因为一旦把子类作为参数传入，调用者就很可能进入子类的方法范畴。我们把上面的例子修改一下，扩大父类的前置条件，

**父类的前置条件较大：**

```java
public class Father {
    public Collection doSomething(Map map){
        System.out.println("父类被执行...");
        return map.values();
    }
}
```

**子类的前置条件较小：**

```java
public class Son extends Father {
    //缩小输入参数范围
    public Collection doSomething(HashMap map){
        System.out.println("子类被执行...");
        return map.values();
    }
}
```

**场景类源代码：**

```java
public class Client {
    public static void invoker(){
        //有父类的地方就有子类
        Father f= new Father();
        HashMap map = new HashMap();
        f.doSomething(map);
    }
    public static void main(String[] args) {
        invoker();
    }
}
```

> 父类被执行...

那我们再把里氏替换原则引入进来会有什么问题？

**采用里氏替换原则后的业务场景类：**

```java
public class Client {
    public static void invoker(){
        //有父类的地方就有子类
        Son f =new Son();
        HashMap map = new HashMap();
        f.doSomething(map);
    }
    public static void main(String[] args) {
        invoker();
    }
}
```

> 子类被执行...

完蛋了吧？！子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱，因为在实际应用中父类一般都是抽象类，子类是实现类，你传递一个这样的实现类就会“歪曲”了父类的意图，引起一堆意想不到的业务逻辑混乱，所以子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。

4. **覆写或实现父类的方法时输出结果可以被缩小**

这是什么意思呢，父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类，为什么呢？分两种情况，如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的，参考上面讲的前置条件。

**总结：**采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。

## 三、依赖倒置原则

> 依赖倒置原则（Dependence Inversion Principle,DIP）
>
> High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.

翻译过来，包含三层含义：

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
- 抽象不应该依赖细节；
- 细节应该依赖抽象。

高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。

那什么是抽象？什么又是细节呢？在Java语言中，

抽象就是指接口或抽象类，两者都是不能直接被实例化的；

细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。

依赖倒置原则在Java语言中的表现就是：

- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；

- 接口或抽象类不依赖于实现类；
-  实现类依赖接口或抽象类。

更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。

**示例：**

现在的汽车越来越便宜了，一个卫生间的造价就可以买到一辆不错的汽车，有汽车就必然有人来驾驶，司机驾驶奔驰车的类图。

![image-20221214004905796](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221214004905796.png)

奔驰车可以提供一个方法run，代表车辆运行，

**司机源代码：**

```java
public class Driver {
    //司机的主要职责就是驾驶汽车
    public void drive(Benz benz){
        benz.run();
    }
}
```

司机通过调用奔驰车的run方法开动奔驰车

**奔驰车源代码：**

```java
public class Benz {
    //汽车肯定会跑
    public void run(){
        System.out.println("奔驰汽车开始运行...");
    }
}
```

**场景类源代码：**

```java
public class Client {
    public static void main(String[] args) {
        Driver zhangSan = new Driver();
        Benz benz = new Benz();
        //张三开奔驰车
        zhangSan.drive(benz);
    }
}
```

通过以上的代码，完成了司机开动奔驰车的场景，到目前为止，这个司机开奔驰车的项目没有任何问题。我们常说“危难时刻见真情”，我们把这句话移植到技术上就成了“变更才显真功夫”，业务需求变更永无休止，技术前进就永无止境，在发生变更时才能发觉我们的设计或程序是否是松耦合。我们在一段貌似磐石的程序上加上一块小石头：张三司机不仅要开奔驰车，还要开宝马车，又该怎么实现呢？麻烦出来了，那好，我们走一步是一步，我们先把宝马车产生出来

**宝马车源代码：**

```java
public class BMW {
    //宝马车当然也可以开动了
    public void run(){
        System.out.println("宝马汽车开始运行...");
    }
}
```

宝马车也产生了，但是我们却没有办法让张三开动起来，为什么？张三没有开动宝马车的方法呀！一个拿有C驾照的司机竟然只能开奔驰车而不能开宝马车，这也太不合理了！在现实世界都不允许存在这种情况，何况程序还是对现实世界的抽象，我们的设计出现了问题：司机类和奔驰车类之间是紧耦合的关系，其导致的结果就是系统的可维护性大大降低，可读性降低，两个相似的类需要阅读两个文件，你乐意吗？还有稳定性，什么是稳定性？固化的、健壮的才是稳定的，这里只是增加了一个车类就需要修改司机类，这不是稳定性，这是易变性。被依赖者的变更竟然让依赖者来承担修改的成本，这样的依赖关系谁肯承担！



根据以上证明，如果不使用依赖倒置原则就会加重类间的耦合性，降低系统的稳定性，增加并行开发引起的风险，降低代码的可读性和可维护性。承接上面的例子，引入依赖倒置原则后的类图。

![image-20221214005252180](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221214005252180.png)

建立两个接口：IDriver和ICar，分别定义了司机和汽车的各个职能，司机就是驾驶汽车，必须实现drive()方法。

**司机接口：**

```java
public interface IDriver {
    //是司机就应该会驾驶汽车
    public void drive(ICar car);
}
```

**司机类的实现：**

```java
public class Driver implements IDriver{
    //司机的主要职责就是驾驶汽车
    public void drive(ICar car){
        car.run();
    }
}
```

在IDriver中，通过传入ICar接口实现了抽象之间的依赖关系，Driver实现类也传入了ICar接口，至于到底是哪个型号的Car，需要在高层模块中声明。

**汽车接口及两个实现类：**

```java
public interface ICar {
    //是汽车就应该能跑
    public void run();
}

public class Benz implements ICar{
    //汽车肯定会跑
    public void run(){
        System.out.println("奔驰汽车开始运行...");
    }
}

public class BMW implements ICar{
    //宝马车当然也可以开动了
    public void run(){
        System.out.println("宝马汽车开始运行...");
    }
}
```

在业务场景中，我们贯彻“抽象不应该依赖细节”，也就是我们认为抽象（ICar接口）不依赖BMW和Benz两个实现类（细节），因此在高层次的模块中应用都是抽象。

**业务场景：**

```java
public class Client {
    public static void main(String[] args) {
        IDriver zhangSan = new Driver();
        ICar benz = new Benz();
        //张三开奔驰车
        zhangSan.drive(benz);
    }
}
```

Client属于高层业务逻辑，它对低层模块的依赖都建立在抽象上，zhangSan的表面类型是IDriver，Benz的表面类型是ICar，也许你要问，在这个高层模块中也调用到了低层模块，比如new Driver()和new Benz()等，如何解释？确实如此，zhangSan的表面类型是IDriver，是一个接口，是抽象的、非实体化的，在其后的所有操作中，zhangSan都是以IDriver类型进行操作，屏蔽了细节对抽象的影响。当然，张三如果要开宝马车，也很容易，我们只要修改业务场景类就可以。

**张三驾驶宝马车的实现过程：**

```java
public class Client {
    public static void main(String[] args) {
        IDriver zhangSan = new Driver();
        ICar bmw = new BMW();
        //张三开奔驰车
        zhangSan.drive(bmw);
    }
}
```

在新增加低层模块时，只修改了业务场景类，也就是高层模块，对其他低层模块如Driver类不需要做任何修改，业务就可以运行，把“变更”引起的风险扩散降到最低。

**总结：**

依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以：

- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
- 变量的表面类型尽量是接口或者是抽象类
- 任何类都不应该从具体类派生
- 尽量不要覆写基类的方法
- 结合里氏替换原则使用

## 四、接口隔离原则

接口分为两种：

- 实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，这是一种接口。比如你定义Person这个类，然后使用Person zhangSan=new Person()产生了一个实例，这个实例要遵从的标准就是Person这个类，Person类就是zhangSan的接口。疑惑？看不懂？不要紧，那是因为让Java语言浸染的时间太长了，只要知道从这个角度来看，Java中的类也是一种接口。
- 类接口（Class Interface），Java中经常使用的interface关键字定义的接口。

什么是隔离？

- Clients should not be forced to depend upon interfaces that they don't use.（客户端不应该依赖它不需要的接口。）
- The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）

这两个定义概括为一句话：**建立单一接口，不要建立臃肿庞大的接口。**

**示例：**

我们举例来说明接口隔离原则到底对我们提出了什么要求。现在男生对小姑娘的称呼，使用频率最高的应该是“美女”了吧，你在大街上叫一声：“嗨，美女！”估计10个有8个回头，其中包括那位著名的如花。美女的标准各不相同，首先就需要定义一下什么是美女：首先要面貌好看，其次是身材要窈窕，然后要有气质，当然了，这三者各人的排列顺序不一样，总之要成为一名美女就必须具备：面貌、身材和气质，我们用类图体现一下星探（当然，你也可以把自己想象成星探）找美女的过程。

![image-20221215013157868](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221215013157868.png)

定义了一个IPettyGirl接口，声明所有的美女都应该有goodLooking、niceFigure和greatTemperament，然后又定义了一个抽象类AbstractSearcher，其作用就是搜索美女并显示其信息，只要美女都按照这个规范定义，Searcher（星探）就轻松多了。

**美女类：**

```java
public interface IPettyGirl {
    //要有姣好的面孔
    public void goodLooking();
    //要有好身材
    public void niceFigure();
    //要有气质
    public void greatTemperament();
}
```

**美女实现类：**

```java
public class PettyGirl implements IPettyGirl {
    private String name;
    //美女都有名字
    public PettyGirl(String _name){
        this.name=_name;
    }
    //脸蛋漂亮
    public void goodLooking() {
        System.out.println(this.name + "---脸蛋很漂亮!");
    }
    //气质要好
    public void greatTemperament() {
        System.out.println(this.name + "---气质非常好!");
    }
    //身材要好
    public void niceFigure() {
        System.out.println(this.name + "---身材非常棒!");
    }
}
```

通过三个方法，把对美女的要求都定义出来了，按照这个标准，如花姑娘被排除在美女标准之外了。有美女，就有搜索美女的星探。

**星探抽象类源代码：**

```java
public abstract class AbstractSearcher {
    protected IPettyGirl pettyGirl;
    public AbstractSearcher(IPettyGirl _pettyGirl){
        this.pettyGirl = _pettyGirl;
    }
    //搜索美女，列出美女信息
    public abstract void show();
}
```

**星探类：**

```java
public class Searcher extends AbstractSearcher{
    public Searcher(IPettyGirl _pettyGirl){
        super(_pettyGirl);
    }
    //展示美女的信息
    public void show(){
        System.out.println("--------美女的信息如下：---------------");
        //展示面容
        super.pettyGirl.goodLooking();
        //展示身材
        super.pettyGirl.niceFigure();
        //展示气质
        super.pettyGirl.greatTemperament();
    }
}
```

场景中的两个角色美女和星探都已经出现了，需要写一个场景类来串联起各个角色。

**场景类：**

```java
public class Client {
    //搜索并展示美女信息
    public static void main(String[] args) {
        //定义一个美女
        IPettyGirl yanYan = new PettyGirl("嫣嫣");
        AbstractSearcher searcher = new Searcher(yanYan);
        searcher.show();
    }
}
```

> --------美女的信息如下：---------------
>
> 嫣嫣---脸蛋很漂亮!
>
> 嫣嫣---身材非常棒!
>
> 嫣嫣---气质非常好!

思考一下IPettyGirl这个接口，这个接口是否做到了最优化设计？

我们的审美观点都在改变，美女的定义也在变化。唐朝的杨贵妃如果活在现在这个年代非羞愧而死不可，为什么？胖呀！但是胖并不影响她入选中国四大美女，说明当时的审美观与现在是有差异的。当然，随着时代的发展我们的审美观也在变化，当你发现有一个女孩，脸蛋不怎么样，身材也一般般，但是气质非常好，我相信大部分人都会把这样的女孩叫美女，审美素质提升了，就产生了气质型美女，但是我们的接口却定义了美女必须是三者都具备，按照这个标准，气质型美女就不能算美女，那怎么办？可能你要说了，我重新扩展一个美女类，只实现greatTemperament方法，其他两个方法置空，什么都不写，不就可以了吗？聪明，但是行不通！为什么呢？星探AbstractSearcher依赖的是IPettyGirl接口，它有三个方法，你只实现了两个方法，星探的方法是不是要修改？我们上面的程序打印出来的信息少了两条，还让星探怎么去辨别是不是美女呢？

分析到这里，我们发现接口IPettyGirl的设计是有缺陷的，过于庞大了，容纳了一些可变的因素，根据接口隔离原则，星探AbstractSearcher应该依赖于具有部分特质的女孩子，而我们却把这些特质都封装了起来，放到了一个接口中，封装过度了！问题找到了，我们重新设计一下类图。

![image-20221215013744728](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221215013744728.png)

把原IPettyGirl接口拆分为两个接口，一种是外形美的美女IGoodBodyGirl，这类美女的特点就是脸蛋和身材极棒，超一流，但是没有审美素质，比如随地吐痰，文化程度比较低；

另外一种是气质美的美女IGreatTemperamentGirl，谈吐和修养都非常高。

我们把一个比较臃肿的接口拆分成了两个专门的接口，灵活性提高了，可维护性也增加了，不管以后是要外形美的美女还是气质美的美女都可以轻松地通过PettyGirl定义。

**两种类型的美女定义：**

```java
public interface IGoodBodyGirl {
    //要有姣好的面孔
    public void goodLooking();
    //要有好身材
    public void niceFigure();
}

public interface IGreatTemperamentGirl {
    //要有气质
    public void greatTemperament();
}
```

按照脸蛋、身材、气质都具备才算美女，实现类实现两个接口

**最标准的美女：**

```java
public class PettyGirl implements IGoodBodyGirl,IGreatTemperamentGirl {
    private String name;
    //美女都有名字
    public PettyGirl(String _name){
        this.name=_name;
    }
    //脸蛋漂亮
    public void goodLooking() {
        System.out.println(this.name + "---脸蛋很漂亮!");
    }
    //气质要好
    public void greatTemperament() {
        System.out.println(this.name + "---气质非常好!");
    }
    //身材要好
    public void niceFigure() {
        System.out.println(this.name + "---身材非常棒!");
    }
}
```

通过这样的重构以后，不管以后是要气质美女还是要外形美女，都可以保持接口的稳定。当然，你可能要说了，以后可能审美观点再发生改变，只有脸蛋好看就是美女，那这个IGoodBody接口还是要修改的呀，确实是，但是设计是有限度的，不能无限地考虑未来的变更情况，否则就会陷入设计的泥潭中而不能自拔。

以上把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，让星探AbstractSearcher依赖两个专用的接口比依赖一个综合的接口要灵活。接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。

**定义：**

接口隔离原则是对接口进行规范约束，其包含以下4层含义：

- 接口要尽量小
- 接口要高内聚
- 定制服务
- 接口设计是有限度的

## 五、迪米特法则

> 迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least KnowledgePrinciple，LKP）

虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。

通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。

**定义：**

1. **只和朋友交流**

迪米特法则还有一个英文解释是：Only talk to your immediate friends（只与直接的朋友通信。）

**示例：**

老师想让体育委员确认一下全班女生来齐没有，就对他说：“你去把全班女生清一下。”

![image-20221215015101115](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221215015101115.png)

Teacher类的commond方法负责发送命令给体育会员，命令他清点女生。

**老师类：**

```java
public class Teacher {
    //老师对学生发布命令，清一下女生
    public void commond(GroupLeader groupLeader){
        List listGirls = new ArrayList();
        //初始化女生
        for(int i=0;i<20;i++){
            listGirls.add(new Girl());
        }
        //告诉体育委员开始执行清查任务
        groupLeader.countGirls(listGirls);
    }
}
```

老师只有一个方法commond，先定义出所有的女生，然后发布命令给体育委员，去清点一下女生的数量。

**体育委员类实现过程：**

```java
public class GroupLeader {
    //清查女生数量
    public void countGirls(List<Girl> listGirls){
        System.out.println("女生数量是："+listGirls.size());
    }
}
```

老师类和体育委员类都对女生类产生依赖，而且女生类不需要执行任何动作。

**女生类：**

```java
public class Girl {
}
```

故事中的三个角色都已经有了，再定义一个场景类来描述这个故事：

**场景类：**

```java
public class Client {
    public static void main(String[] args) {
        Teacher teacher= new Teacher();
        //老师发布命令
        teacher.commond(new GroupLeader());
    }
}
```

> 女生数量是：20

体育委员按照老师的要求对女生进行了清点，并得出了数量。我们回过头来思考一下这个程序有什么问题，首先确定Teacher类有几个朋友类，它仅有一个朋友类——

GroupLeader。为什么Girl不是朋友类呢？Teacher也对它产生了依赖关系呀！

朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类，而Girl这个类就是出现在commond方法体内，因此不属于Teacher类的朋友类。

迪米特法则告诉我们一个类只和朋友类交流，但是我们刚刚定义的commond方法却与Girl类有了交流，声明了一个`List<Girls>`动态数组，也就是与一个陌生的类Girl有了交流，这样就破坏了Teacher的健壮性。方法是类的一个行为，类竟然不知道自己的行为与其他类产生依赖关系，这是不允许的，严重违反了迪米特法则。

问题已经发现，我们修改一下程序，将类图稍作修改。

![image-20221215015414863](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221215015414863.png)

在类图中去掉Teacher对Girl类的依赖关系

**修改后的老师类：**

```java
public class Teacher {
    //老师对学生发布命令，清一下女生
    public void commond(GroupLeader groupLeader){
        //告诉体育委员开始执行清查任务
        groupLeader.countGirls();
    }
}
```

**修改后的体育委员类：**

```java
public class GroupLeader {
    private List<Girl> listGirls;
    //传递全班的女生进来
    public GroupLeader(List<Girl> _listGirls){
        this.listGirls = _listGirls;
    }
    //清查女生数量
    public void countGirls(){
        System.out.println("女生数量是："+this.listGirls.size());
    }
}
```

在GroupLeader类中定义了一个构造函数，通过构造函数传递了依赖关系

**修改后的场景类：**

```java
public class Client {
    public static void main(String[] args) {
        //产生一个女生群体
        List<Girl> listGirls = new ArrayList<Girl>();
        //初始化女生
        for(int i=0;i<20;i++){
            listGirls.add(new Girl());
        }
        Teacher teacher= new Teacher();
        //老师发布命令
        teacher.commond(new GroupLeader(listGirls));
    }
}
```

对程序进行了简单的修改，把Teacher中对`List<Girl>`的初始化移动到了场景类中，同时在GroupLeader中增加了对Girl的注入，避开了Teacher类对陌生类Girl的访问，降低了系统间的耦合，提高了系统的健壮性。

**注意：**一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。

2. **朋友间也是有距离的**

**示例：**

我们在安装软件的时候，经常会有一个导向动作，第一步是确认是否安装，第二步确认License，再然后选择安装目录……这是一个典型的顺序执行动作，具体到程序中就是：调用一个或多个类，先执行第一个方法，然后是第二个方法，根据返回结果再来看是否可以调用第三个方法，或者第四个方法，等等

![image-20221215015851748](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221215015851748.png)

很简单的类图，实现软件安装的过程，其中first方法定义第一步做什么，second方法定义第二步做什么，third方法定义第三步做什么。

**导向类：**

```java
public class Wizard {
    private Random rand = new Random(System.currentTimeMillis());
    //第一步
    public int first(){
        System.out.println("执行第一个方法...");
        return rand.nextInt(100);
    }
    //第二步
    public int second(){
        System.out.println("执行第二个方法...");
        return rand.nextInt(100);
    }
    //第三个方法
    public int third(){
        System.out.println("执行第三个方法...");
        return rand.nextInt(100);
    }
}
```

在Wizard类中分别定义了三个步骤方法，每个步骤中都有相关的业务逻辑完成指定的任务，我们使用一个随机函数来代替业务执行的返回值。

**InstallSoftware类：**

```java
public class InstallSoftware {
    public void installWizard(Wizard wizard){
        int first = wizard.first();
        //根据first返回的结果，看是否需要执行second
        if(first>50){
            int second = wizard.second();
            if(second>50){
                int third = wizard.third();
                if(third >50){
                    wizard.first();
                }
            }
        }
    }
}
```

**场景类：**

```java
public class Client {
    public static void main(String[] args) {
        InstallSoftware invoker = new InstallSoftware();
        invoker.installWizard(new Wizard());
    }
}
```

以上程序很简单，运行结果和随机数有关，每次的执行结果都不相同，需要读者自己运行并查看结果。程序虽然简单，但是隐藏的问题可不简单，思考一下程序有什么问题。

Wizard类把太多的方法暴露给InstallSoftware类，两者的朋友关系太亲密了，耦合关系变得异常牢固。如果要将Wizard类中的first方法返回值的类型由int改为boolean，就需要修改InstallSoftware类，从而把修改变更的风险扩散开了。因此，这样的耦合是极度不合适的，我们需要对设计进行重构，

![image-20221215020213522](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221215020213522.png)

在Wizard类中增加一个installWizard方法，对安装过程进行封装，同时把原有的三个**public**方法修改为**private**方法，

**修改后的导向类实现过程：**

```java
public class Wizard {
    private Random rand = new Random(System.currentTimeMillis());
    //第一步
    private int first(){
        System.out.println("执行第一个方法...");
        return rand.nextInt(100);
    }
    //第二步
    private int second(){
        System.out.println("执行第二个方法...");
        return rand.nextInt(100);
    }
    //第三个方法
    private int third(){
        System.out.println("执行第三个方法...");
        return rand.nextInt(100);
    }
    
    //软件安装过程
    public void installWizard(){
        int first = this.first();
        //根据first返回的结果，看是否需要执行second
        if(first>50){
            int second = this.second();
            if(second>50){
                int third = this.third();
                if(third >50){
                    this.first();
            	}
            }
        }
    }
}
```

将三个步骤的访问权限修改为private，同时把InstallSoftware中的方法installWizad移动到Wizard方法中。通过这样的重构后，Wizard类就只对外公布了一个public方法，即使要修改first方法的返回值，影响的也仅仅只是Wizard本身，其他类不受影响，这显示了类的高内聚特性。

对InstallSoftware类进行少量的修改。

**修改后的InstallSoftware类：**

```java
public class InstallSoftware {
    public void installWizard(Wizard wizard){
        //直接调用
        wizard.installWizard();
    }
}
```

通过进行重构，类间的耦合关系变弱了，结构也清晰了，变更引起的风险。

一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。

**注意：**

迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。

3. **是自己的就是自己的**

在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？

你可以坚持这样一个原则：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。

4. **谨慎使用Serializable**

在实际应用中，这个问题是很少出现的，即使出现也会立即被发现并得到解决。是怎么回事呢？举个例子来说，在一个项目中使用RMI（Remote Method Invocation，远程方法调用）方式传递一个VO（Value Object，值对象），这个对象就必须实现Serializable接口（仅仅是一个标志性接口，不需要实现具体的方法），也就是把需要网络传输的对象进行序列化，否则就会出现NotSerializableException异常。突然有一天，客户端的VO修改了一个属性的访问权限，从private变更为public，访问权限扩大了，如果服务器上没有做出相应的变更，就会报序列化失败，就这么简单。但是这个问题的产生应该属于项目管理范畴，一个类或接口在客户端已经变更了，而服务器端却没有同步更新，难道不是项目管理的失职吗？

## 六、开闭原则

**定义：**Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）

软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。

**示例：**

以书店销售书籍为例

![image-20221215021804080](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221215021804080.png)

IBook定义了数据的三个属性：名称、价格和作者。小说类NovelBook是一个具体的实现类，是所有小说书籍的总称，BookStore指的是书店。

书籍接口：

```java
public interface IBook {
    //书籍有名称
    public String getName();
    //书籍有售价
    public int getPrice();
    //书籍有作者
    public String getAuthor();
}
```

目前书店只出售小说类书籍。

小说类：

```java
public class NovelBook implements IBook {
    //书籍名称
    private String name;
    //书籍的价格
    private int price;
    //书籍的作者
    private String author;
    //通过构造函数传递书籍数据
    public NovelBook(String _name,int _price,String _author){
        this.name = _name;
        this.price = _price;
        this.author = _author;
    }
    //获得作者是谁
    public String getAuthor() {
        return this.author;
    }
    //书籍叫什么名字
    public String getName() {
        return this.name;
    }
    //获得书籍的价格
    public int getPrice() {
        return this.price;
    }
}
```

书店售书类：

```java
public class BookStore {
    private final static ArrayList<IBook> bookList = new ArrayList<IBook>();
    //static静态模块初始化数据，实际项目中一般是由持久层完成
    static{
        bookList.add(new NovelBook("天龙八部",3200,"金庸"));
        bookList.add(new NovelBook("巴黎圣母院",5600,"雨果"));
        bookList.add(new NovelBook("悲惨世界",3500,"雨果"));
        bookList.add(new NovelBook("金瓶梅",4300,"兰陵笑笑生"));
    }
    //模拟书店买书
    public static void main(String[] args) {
        NumberFormat formatter = NumberFormat.getCurrencyInstance();
        formatter.setMaximumFractionDigits(2);
        System.out.println("-----------书店卖出去的书籍记录如下：-----------");
        for(IBook book:bookList){
            System.out.println("书籍名称：" + book.getName()+"\t书籍作者：" +
            book.getAuthor()+"\t书籍价格："+ formatter.format (book.getPrice()/
            100.0)+"元");
        }
    }
}
```

> -----------------书店卖出去的书籍记录如下：--------------
>
> 书籍名称：天龙八部 书籍作者：金庸 书籍价格：￥25.60元
>
> 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：￥50.40元
>
> 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：￥28.00元
>
> 书籍名称：金瓶梅 书籍作者：兰陵笑笑生 书籍价格：￥38.70元

项目投产了，书籍正常销售出去，书店也赢利了。从2008年开始，全球经济开始下滑，对零售业影响比较大，书店为了生存开始打折销售：所有40元以上的书籍9折销售，其他的8折销售。对已经投产的项目来说，这就是一个变化，我们应该如何应对这样一个需求变化？

-  修改接口

在IBook上新增加一个方法getOffPrice()，专门用于进行打折处理，所有的实现类实现该方法。但是这样修改的后果就是，实现类NovelBook要修改，BookStore中的main方法也修改，同时IBook作为接口应该是稳定且可靠的，不应该经常发生变化，否则接口作为契约的作用就失去了效能。因此，该方案否定。

- 修改实现类

修改NovelBook类中的方法，直接在getPrice()中实现打折处理，好办法，我相信大家在项目中经常使用的就是这样的办法，通过class文件替换的方式可以完成部分业务变化（或是缺陷修复）。该方法在项目有明确的章程（团队内约束）或优良的架构设计时，是一个非常优秀的方法，但是该方法还是有缺陷的。例如采购书籍人员也是要看价格的，由于该方法已经实现了打折处理价格，因此采购人员看到的也是打折后的价格，会因信息不对称而出现决策失误的情况。因此，该方案也不是一个最优的方案。

- 通过扩展实现变化

增加一个子类OffNovelBook，覆写getPrice方法，高层次的模块（也就是static静态模块区）通过OffNovelBook类产生新的对象，完成业务变化对系统的最小化开发。好办法，修改也少，风险也小

![image-20221215022202797](https://gitee.com/haktiong/picture-warehouse/raw/master/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image-20221215022202797.png)

OffNovelBook类继承了NovelBook，并覆写了getPrice方法，不修改原有的代码。

打折销售的小说类：

```java
public class OffNovelBook extends NovelBook {
    public OffNovelBook(String _name,int _price,String _author){
        super(_name,_price,_author);
    }
    //覆写销售价格
    @Override
    public int getPrice(){
        //原价
        int selfPrice = super.getPrice();
        int offPrice=0;
        if(selfPrice>4000){ //原价大于40元，则打9折
            offPrice = selfPrice * 90 /100;
        }else{
            offPrice = selfPrice * 80 /100;
        }
        return offPrice;
    }
}
```

很简单，仅仅覆写了getPrice方法，通过扩展完成了新增加的业务。

书店打折销售类：

```java
public class BookStore {
    private final static ArrayList<IBook> bookList = new ArrayList<IBook>();
    //static静态模块初始化数据，实际项目中一般是由持久层完成
    static{
        bookList.add(new OffNovelBook("天龙八部",3200,"金庸"));
        bookList.add(new OffNovelBook("巴黎圣母院",5600,"雨果"));
        bookList.add(new OffNovelBook("悲惨世界",3500,"雨果"));
        bookList.add(new OffNovelBook("金瓶梅",4300,"兰陵笑笑生"));
    }
    //模拟书店买书
    public static void main(String[] args) {
        NumberFormat formatter = NumberFormat.getCurrencyInstance();
        formatter.setMaximumFractionDigits(2);
        System.out.println("-----------书店卖出去的书籍记录如下：-----------");
        for(IBook book:bookList){
            System.out.println("书籍名称：" + book.getName()+"\t书籍作者：" + book.getAuthor()+ "\t书籍价格：" + formatter.format (book.getPrice()/100.0)+"元");
        }
    }
}
```

我们只修改了粗体部分，其他的部分没有任何改动，运行结果如下所示。

> ----------------------书店卖出去的书籍记录如下：---------------------
>
> 书籍名称：天龙八部 书籍作者：金庸 书籍价格：￥25.60元
>
> 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：￥50.40元
>
> 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：￥28.00元
>
> 书籍名称：金瓶梅 书籍作者：兰陵笑笑生 书籍价格：￥38.70元

OK，打折销售开发完成了。看到这里，各位可能有想法了：增加了一个OffNoveBook类后，你的业务逻辑还是修改了，你修改了static静态模块区域。这部分确实修改了，该部分属于高层次的模块，是由持久层产生的，在业务规则改变的情况下高层模块必须有部分改变以适应新业务，改变要尽量地少，防止变化风险的扩散。